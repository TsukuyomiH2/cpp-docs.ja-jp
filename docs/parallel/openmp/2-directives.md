---
title: 2. ディレクティブ
ms.date: 01/18/2019
ms.assetid: d1a69374-6c03-45fb-8c86-e91cea8adae8
ms.openlocfilehash: 125d2d83b277e62d007e3a208e426ea717d52790
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/16/2020
ms.locfileid: "79424195"
---
# <a name="2-directives"></a>2. ディレクティブ

ディレクティブは、C およびC++標準で定義されている `#pragma` ディレクティブに基づいています。  OpenMP C とC++ API をサポートするコンパイラには、すべての openmp コンパイラディレクティブをアクティブ化して解釈できるコマンドラインオプションが含まれています。

## <a name="21-directive-format"></a>2.1 ディレクティブの形式

OpenMP ディレクティブの構文は、[付録 C](c-openmp-c-and-cpp-grammar.md)の文法によって正式に指定されており、次のように非公式に指定されています。

```cpp
#pragma omp directive-name  [clause[ [,] clause]...] new-line
```

各ディレクティブは `#pragma omp`で開始され、同じ名前を持つ他の (OpenMP またはベンダーの拡張の OpenMP) プラグマディレクティブとの競合の可能性を低減します。 ディレクティブの残りの部分は、コンパイラディレクティブの C およびC++標準の規則に従います。 特に、`#`の前後で空白文字を使用できます。また、ディレクティブ内の単語を区切るために空白文字を使用する必要がある場合もあります。 `#pragma omp` 後のプリプロセストークンには、マクロ置換が適用されます。

ディレクティブでは大文字と小文字が区別されます。 ディレクティブに句が出現する順序は重要ではありません。 ディレクティブの句は、各句の説明に示されている制限に従って、必要に応じて繰り返すことができます。 *変数リスト*が句に含まれている場合は、変数のみを指定する必要があります。 ディレクティブごと*に1つのディレクティブ名*だけを指定できます。  たとえば、次のディレクティブは使用できません。

```cpp
/* ERROR - multiple directive names not allowed */
#pragma omp parallel barrier
```

OpenMP ディレクティブは、1つの後続のステートメントにのみ適用されます。これは、構造化されたブロックである必要があります。

## <a name="22-conditional-compilation"></a>2.2 条件付きコンパイル

`_OPENMP` マクロ名は、10進定数*yyyymm*として OpenMP 準拠の実装によって定義されます。これは、承認された仕様の年と月になります。 このマクロは、`#define` または `#undef` 前処理ディレクティブの対象にすることはできません。

```cpp
#ifdef _OPENMP
iam = omp_get_thread_num() + index;
#endif
```

ベンダーが OpenMP の拡張機能を定義する場合は、追加の定義済みマクロを指定することができます。

## <a name="23-parallel-construct"></a>2.3 parallel コンストラクト

次のディレクティブは、並列領域を定義します。これは、多くのスレッドで並列に実行されるプログラムの領域です。 このディレクティブは、並列実行を開始する基本的なコンストラクトです。

```cpp
#pragma omp parallel [clause[ [, ]clause] ...] new-line   structured-block
```

*句*は次のいずれかです。

- `if(`*スカラー式*`)`
- `private(`*変数リスト*`)`
- `firstprivate(`*変数リスト*`)`
- `default(shared | none)`
- `shared(`*変数リスト*`)`
- `copyin(`*変数リスト*`)`
- `reduction(`*演算子*`:`*変数リスト*`)`
- `num_threads(`*整数式*`)`

スレッドが並列コンストラクトになると、次のいずれかのケースに該当する場合にスレッドのチームが作成されます。

- `if` 句が存在しません。
- `if` 式は、0以外の値に評価されます。

このスレッドは、スレッド番号が0のチームのマスタスレッドになり、チーム内のすべてのスレッド (マスタースレッドを含む) が並列でリージョンを実行します。 `if` 式の値が0の場合、領域はシリアル化されます。

要求されるスレッドの数を決定するために、次の規則が順番に考慮されます。 条件が満たされた最初の規則が適用されます。

1. `num_threads` 句が存在する場合、整数式の値は要求されたスレッドの数になります。

1. `omp_set_num_threads` ライブラリ関数が呼び出された場合、最後に実行された呼び出しの引数の値が、要求されたスレッドの数になります。

1. 環境変数 `OMP_NUM_THREADS` が定義されている場合、この環境変数の値は、要求されたスレッドの数になります。

1. 上記のいずれの方法も使用しない場合、要求されるスレッドの数は実装によって定義されます。

`num_threads` 句が指定されている場合は、`omp_set_num_threads` ライブラリ関数によって要求されるスレッドの数、または、適用される並列領域の `OMP_NUM_THREADS` 環境変数に優先します。 後の並列領域は影響を受けません。

並列領域を実行するスレッドの数は、スレッド数の動的調整が有効になっているかどうかによっても異なります。 動的調整が無効になっている場合、要求されたスレッド数によって並列領域が実行されます。 動的調整が有効になっている場合、要求されたスレッド数は、並列領域を実行できるスレッドの最大数になります。

スレッド数の動的調整が無効になっている間に並列領域が発生し、並列領域に要求されたスレッドの数が、ランタイムシステムが提供できる数を超えている場合、プログラムの動作は、実装で定義されます。 たとえば、実装では、プログラムの実行を中断したり、並列領域をシリアル化したりすることができます。

`omp_set_dynamic` ライブラリ関数と `OMP_DYNAMIC` 環境変数を使用して、スレッド数の動的調整を有効または無効にすることができます。

特定の時点でスレッドを実際にホストしている物理プロセッサの数は、実装によって定義されます。 作成されると、チーム内のスレッドの数は、その並列領域の継続時間に対して一定のままになります。 ユーザーによって明示的に変更することも、並列領域間でランタイムシステムによって自動的に変更することもできます。

並列領域の動的な範囲内に含まれるステートメントは、各スレッドによって実行されます。また、各スレッドは、他のスレッドとは異なるステートメントのパスを実行できます。 並列領域の構文の範囲外で見つかったディレクティブは、孤立したディレクティブと呼ばれます。

並列領域の最後には暗黙的なバリアがあります。 並列領域の最後で実行を継続するのは、チームのマスタースレッドだけです。

並列領域を実行しているチームのスレッドが別の並列コンストラクトを検出すると、新しいチームが作成され、その新しいチームのマスターになります。 入れ子になった並列領域は、既定でシリアル化されます。 その結果、既定では、入れ子になった並列領域は1つのスレッドで構成されるチームによって実行されます。 既定の動作は、ランタイムライブラリ関数 `omp_set_nested` または `OMP_NESTED`環境変数のいずれかを使用して変更できます。 ただし、入れ子になった並列領域を実行するチーム内のスレッドの数は実装によって定義されます。

`parallel` ディレクティブには次の制限があります。

- ディレクティブには、最大で1つの `if` 句を含めることができます。

- If 式または `num_threads` 式の中で副作用が発生したかどうかは、指定されていません。

- 並列領域内で実行される `throw` は、同じ構造化ブロックの動的な範囲内で実行が再開される必要があります。また、例外をスローしたのと同じスレッドでキャッチする必要があります。

- ディレクティブには、1つの `num_threads` 句のみを使用できます。 `num_threads` 式は、並列領域のコンテキストの外側で評価され、正の整数値に評価される必要があります。

- `if` 句と `num_threads` 句の評価順序は指定されていません。

### <a name="cross-references"></a>相互参照

- `private`、`firstprivate`、`default`、`shared`、`copyin`、および `reduction` の各句 ([セクション 2.7.2](#272-data-sharing-attribute-clauses))
- [OMP_NUM_THREADS](4-environment-variables.md#42-omp_num_threads)環境変数
- [omp_set_dynamic](3-run-time-library-functions.md#317-omp_set_dynamic-function)ライブラリ関数
- [OMP_DYNAMIC](4-environment-variables.md#43-omp_dynamic)環境変数
- [omp_set_nested](3-run-time-library-functions.md#319-omp_set_nested-function)関数
- [OMP_NESTED](4-environment-variables.md#44-omp_nested)環境変数
- [omp_set_num_threads](3-run-time-library-functions.md#311-omp_set_num_threads-function)ライブラリ関数

## <a name="24-work-sharing-constructs"></a>2.4 作業共有コンストラクト

作業共有コンストラクトは、関連付けられているステートメントの実行を、それを発生させたチームのメンバー間で分散します。 作業共有ディレクティブは、新しいスレッドを起動しません。また、ワーク共有コンストラクトへのエントリには暗黙のバリアがありません。

チーム内のすべてのスレッドで、一連の作業共有コンストラクトと `barrier` ディレクティブが同じである必要があります。

OpenMP では、次の作業共有コンストラクトが定義されています。これらの構成要素については、次のセクションで説明します。

- ディレクティブ[の場合](#241-for-construct)
- [sections](#242-sections-construct)ディレクティブ
- [単一](#243-single-construct)ディレクティブ

### <a name="241-for-construct"></a>2.4.1 for コンストラクト

`for` ディレクティブは、関連付けられているループの反復処理が並列で実行されることを指定する反復的なワーク共有コンストラクトを識別します。 `for` ループの反復は、バインド先の並列コンストラクトを実行しているチーム内に既に存在する複数のスレッドに分散されます。 `for` コンストラクトの構文は次のとおりです。

```cpp
#pragma omp for [clause[[,] clause] ... ] new-line for-loop
```

句は次のいずれかです。

- `private(`*変数リスト*`)`
- `firstprivate(`*変数リスト*`)`
- `lastprivate(`*変数リスト*`)`
- `reduction(`*演算子*`:`*変数リスト*`)`
- `ordered`
- `schedule(` の*種類*[`,` *chunk_size*] `)`
- `nowait`

`for` ディレクティブは、対応する `for` ループの構造に制限を課します。 具体的には、対応する `for` ループには正規の図形が必要です。

`for (` *init-expr* `;` *var 論理 op b* `;` *incr-expr* `)`

*init-expr*<br/>
次のいずれか:

- *var* = *lb*
- *整数型の var* = *lb*

*incr-expr*<br/>
次のいずれか:

- `++` の*変数*
- *var* `++`
- `--` の*変数*
- *var* `--`
- *変数*`+=` *incr*
- *変数*`-=` *incr*
- *var* `=` *var* `+` *incr*
- *var* `=` *incr* `+` *var*
- *var* `=` *var* `-` *incr*

*var*<br/>
符号付き整数変数。 この変数が共有されていない場合は、`for`の間、暗黙的にプライベートになります。 `for` ステートメントの本体内でこの変数を変更しないでください。 変数が `lastprivate`指定されていない限り、ループの後の値は不確定になります。

*論理操作*<br/>
次のいずれか:

- `<`
- `<=`
- `>`
- `>=`

*lb*、 *b*、および*incr*<br>
ループインバリアント整数式。 これらの式の評価中に同期が行われないため、評価された副作用によって不確定な結果が生成されます。

正規の形式を使用すると、ループのエントリに対してループの反復回数を計算できます。 この計算は、整数の上位変換の後に、 *var*の型の値を使用して行われます。 特に、 *b* `-` *lb* `+` *incr*の値をその型で表すことができない場合、結果は不確定になります。 さらに、*論理 op*が `<` または `<=`の場合は、ループの各反復処理で、増分*式*によって*var*が増加する必要があります。   *論理 op*が `>` または `>=`の場合は、ループの各反復処理で、 *incr-expr*によって*var*が小さくなる必要があります。

`schedule` 句は、`for` ループの反復処理をチームのスレッド間でどのように分割するかを指定します。 プログラムの正確性は、特定の反復処理を実行するスレッドに依存しないようにする必要があります。 *Chunk_size*の値 (指定されている場合) は、正の値を持つループインバリアント整数式である必要があります。 この式の評価中に同期が行われないため、評価された副作用によって不確定な結果が生成されます。 スケジュールの*種類*には、次のいずれかの値を指定できます。

表 2-1: `schedule` 句の*種類*の値

|||
|-|-|
|静的|`schedule(static,` *chunk_size* `)` が指定されている場合、イテレーションは*chunk_size*によって指定されたサイズのチャンクに分割されます。 チャンクは、スレッド番号の順序でラウンドロビン方式でチーム内のスレッドに静的に割り当てられます。 *Chunk_size*が指定されていない場合、反復領域は約同じサイズのチャンクに分割され、1つのチャンクが各スレッドに割り当てられます。|
|動的|`schedule(dynamic,` *chunk_size* `)` が指定されている場合、イテレーションは一連のチャンクに分割され、それぞれに*chunk_size*イテレーションが含まれます。 各チャンクは、割り当てを待機しているスレッドに割り当てられます。 スレッドは、反復処理のチャンクを実行し、次の割り当てを待機します。その後、割り当てられたチャンクが残っていません。 最後に割り当てられるチャンクには、イテレーションの数が少ない場合があります。 *Chunk_size*が指定されていない場合、既定値は1です。|
|ガイド付き|`schedule(guided,` *chunk_size* `)` が指定されている場合、イテレーションはサイズの小さいチャンク単位のスレッドに割り当てられます。 スレッドは、割り当てられたイテレーションのチャンクを完了すると、何も残っていなくなるまで、動的に別のチャンクに割り当てられます。 *Chunk_size*が1の場合、各チャンクのサイズは、割り当てられていないイテレーションの数をスレッド数で割った値になります。 これらのサイズは、ほぼ指数関数的に1に減少します。 1を*超える値が*指定された*chunk_size*の場合、最後のチャンクの反復回数が*k*未満である点を除いて、サイズはほぼ指数関数*的に減少*します。 *Chunk_size*が指定されていない場合、既定値は1です。|
|runtime|`schedule(runtime)` が指定されている場合、スケジュールに関する決定は実行時まで延期されます。 環境変数 `OMP_SCHEDULE`を設定することにより、実行時にチャンクのスケジュールの*種類*とサイズを選択できます。 この環境変数が設定されていない場合、結果のスケジュールは実装定義になります。 `schedule(runtime)` が指定されている場合、 *chunk_size*を指定することはできません。|

明示的に定義された `schedule` 句が存在しない場合、既定の `schedule` は実装によって定義されます。

OpenMP 準拠プログラムは、適切な実行のために特定のスケジュールに依存しないでください。 プログラムは、上記の説明に正確に準拠したスケジュールの*種類*に依存しないようにする必要があります。これは、さまざまなコンパイラで同じスケジュールの*種類*の実装にバリエーションを持たせることができるためです。 説明を使用すると、特定の状況に適したスケジュールを選択できます。

`ordered` ディレクティブが `for` コンストラクトにバインドされている場合、`ordered` 句が存在する必要があります。

`nowait` 句が指定されていない場合、`for` コンストラクトの最後に暗黙的なバリアがあります。

`for` ディレクティブには次の制限があります。

- `for` ループは構造化ブロックである必要があります。また、その実行は、`break` ステートメントによって終了されないようにする必要があります。

- `for` ディレクティブに関連付けられている `for` ループのループコントロール式の値は、チーム内のすべてのスレッドで同じである必要があります。

- `for` ループ反復変数は、符号付き整数型である必要があります。

- `for` ディレクティブには、1つの `schedule` 句のみを使用できます。

- `for` ディレクティブには、1つの `ordered` 句のみを使用できます。

- `for` ディレクティブには、1つの `nowait` 句のみを使用できます。

- *Chunk_size*、 *lb*、 *b*、または*incr*の式の中で副作用が発生するかどうかは指定されていません。

- *Chunk_size*式の値は、チーム内のすべてのスレッドで同じである必要があります。

#### <a name="cross-references"></a>相互参照

- `private`、`firstprivate`、`lastprivate`、および `reduction` の各句 ([セクション 2.7.2](#272-data-sharing-attribute-clauses))
- [OMP_SCHEDULE](4-environment-variables.md#41-omp_schedule)環境変数
- [順序付け](#266-ordered-construct)られたコンストラクト
- [schedule](d-using-the-schedule-clause.md)句

### <a name="242-sections-construct"></a>2.4.2 sections コンストラクト

`sections` ディレクティブは、チーム内のスレッド間で分割される構造のセットを指定する、非反復的なワーク共有コンストラクトを識別します。 各セクションは、チーム内のスレッドによって1回実行されます。 `sections` ディレクティブの構文は次のとおりです。

```cpp
#pragma omp sections [clause[[,] clause] ...] new-line
   {
   [#pragma omp section new-line]
      structured-block
   [#pragma omp section new-linestructured-block ]
...
}
```

句は次のいずれかです。

- `private(`*変数リスト*`)`
- `firstprivate(`*変数リスト*`)`
- `lastprivate(`*変数リスト*`)`
- `reduction(`*演算子*`:`*変数リスト*`)`
- `nowait`

各セクションの前には `section` ディレクティブがありますが、最初のセクションでは `section` ディレクティブは省略可能です。 `section` ディレクティブは、`sections` ディレクティブの構文の範囲内に記述する必要があります。 `nowait` が指定されていない限り、`sections` コンストラクトの最後に暗黙的なバリアがあります。

`sections` ディレクティブには次の制限があります。

- `section` ディレクティブは、`sections` ディレクティブの構文の範囲外に記述することはできません。

- `sections` ディレクティブには、1つの `nowait` 句のみを使用できます。

#### <a name="cross-references"></a>相互参照

- `private`、`firstprivate`、`lastprivate`、および `reduction` の各句 ([セクション 2.7.2](#272-data-sharing-attribute-clauses))

### <a name="243-single-construct"></a>2.4.3 single コンストラクト

`single` ディレクティブは、関連付けられた構造化ブロックが、チーム内の1つのスレッド (必ずしもマスタースレッドではない) によって実行されることを指定するコンストラクトを識別します。 `single` ディレクティブの構文は次のとおりです。

```cpp
#pragma omp single [clause[[,] clause] ...] new-linestructured-block
```

句は次のいずれかです。

- `private(`*変数リスト*`)`
- `firstprivate(`*変数リスト*`)`
- `copyprivate(`*変数リスト*`)`
- `nowait`

`nowait` 句が指定されていない場合、`single` コンストラクトの後に暗黙的なバリアがあります。

`single` ディレクティブには次の制限があります。

- `single` ディレクティブには、1つの `nowait` 句のみを使用できます。
- `copyprivate` 句は、`nowait` 句と一緒に使用することはできません。

#### <a name="cross-references"></a>相互参照

- `private`、`firstprivate`、および `copyprivate` 句 ([セクション 2.7.2](#272-data-sharing-attribute-clauses))

## <a name="25-combined-parallel-work-sharing-constructs"></a>2.5 結合された並列作業共有構成体

結合された並列作業共有構成体は、1つの作業共有コンストラクトのみを持つ並行領域を指定するためのショートカットです。 これらのディレクティブのセマンティクスは、`parallel` ディレクティブを明示的に指定するのと同じであり、その後に1つの作業共有コンストラクトが続きます。

次のセクションでは、結合された並列作業共有の構成要素について説明します。

- [parallel for](#251-parallel-for-construct)ディレクティブ
- [parallel sections](#252-parallel-sections-construct)ディレクティブ

### <a name="251-parallel-for-construct"></a>2.5.1 parallel for コンストラクト

`parallel for` ディレクティブは、1つの `for` ディレクティブだけを含む `parallel` 領域のショートカットです。 `parallel for` ディレクティブの構文は次のとおりです。

```cpp
#pragma omp parallel for [clause[[,] clause] ...] new-linefor-loop
```

このディレクティブを使用すると、`parallel` ディレクティブと `for` ディレクティブのすべての句を使用できます。ただし、`nowait` 句を除き、同じ意味と制限があります。 セマンティクスは、`parallel` ディレクティブを明示的に指定することと同じで、その直後に `for` ディレクティブを指定します。

#### <a name="cross-references"></a>相互参照

- [parallel](#23-parallel-construct)ディレクティブ
- ディレクティブ[の場合](#241-for-construct)
- [データ属性句](#272-data-sharing-attribute-clauses)

### <a name="252-parallel-sections-construct"></a>2.5.2 parallel sections コンストラクト

`parallel sections` ディレクティブには、1つの `sections` ディレクティブだけを持つ `parallel` 領域を指定するためのショートカットフォームが用意されています。 セマンティクスは、`parallel` ディレクティブを明示的に指定することと同じで、その直後に `sections` ディレクティブを指定します。 `parallel sections` ディレクティブの構文は次のとおりです。

```cpp
#pragma omp parallel sections  [clause[[,] clause] ...] new-line
   {
   [#pragma omp section new-line]
      structured-block
   [#pragma omp section new-linestructured-block  ]
   ...
}
```

*句*は、`parallel` ディレクティブと `sections` ディレクティブで許可されている句のいずれかにすることができます。ただし、`nowait` 句は除きます。

#### <a name="cross-references"></a>相互参照

- [parallel](#23-parallel-construct)ディレクティブ
- [sections](#242-sections-construct)ディレクティブ

## <a name="26-master-and-synchronization-directives"></a>2.6 マスターおよび同期ディレクティブ

次のセクションでは、について説明します。

- [マスター](#261-master-construct)コンストラクト
- [重大な](#262-critical-construct)構成体
- [バリア](#263-barrier-directive)ディレクティブ
- [atomic](#264-atomic-construct)コンストラクト
- [flush](#265-flush-directive)ディレクティブ
- [順序付け](#266-ordered-construct)られたコンストラクト

### <a name="261-master-construct"></a>2.6.1 マスターコンストラクト

`master` ディレクティブは、チームのマスタースレッドによって実行される構造化ブロックを指定するコンストラクトを識別します。 `master` ディレクティブの構文は次のとおりです。

```cpp
#pragma omp master new-linestructured-block
```

チーム内の他のスレッドは、関連付けられている構造化ブロックを実行しません。 Master コンストラクトへの入力または終了時に暗黙的なバリアはありません。

### <a name="262-critical-construct"></a>2.6.2 critical コンストラクト

`critical` ディレクティブは、関連する構造化ブロックの実行を一度に1つのスレッドに制限するコンストラクトを識別します。 `critical` ディレクティブの構文は次のとおりです。

```cpp
#pragma omp critical [(name)]  new-linestructured-block
```

オプションの*名前*は、重要なリージョンを識別するために使用できます。 クリティカル領域を識別するために使用される識別子は、外部リンケージを持ち、ラベル、タグ、メンバー、および通常の識別子によって使用される名前空間とは別の名前空間にあります。

スレッドは、他のスレッドが同じ名前で (プログラム内の任意の場所で) クリティカルな領域を実行しないようになるまで、クリティカルなリージョンの開始時に待機します。 名前のないすべての `critical` ディレクティブは、指定されていない名前にマップされます。

### <a name="263-barrier-directive"></a>2.6.3 バリアディレクティブ

`barrier` ディレクティブは、チーム内のすべてのスレッドを同期します。 検出されると、チーム内の各スレッドは、他のすべてのスレッドがこの時点に到達するまで待機します。 `barrier` ディレクティブの構文は次のとおりです。

```cpp
#pragma omp barrier new-line
```

チーム内のすべてのスレッドがバリアを検出すると、チーム内の各スレッドは、バリアディレクティブの後にあるステートメントの実行を並列で開始します。 `barrier` ディレクティブには構文の一部として C 言語のステートメントがないため、プログラム内での配置にはいくつかの制限があります。 正式な文法の詳細については、「[付録 C](c-openmp-c-and-cpp-grammar.md)」を参照してください。次の例では、これらの制限について説明します。

```cpp
/* ERROR - The barrier directive cannot be the immediate
*          substatement of an if statement
*/
if (x!=0)
   #pragma omp barrier
...

/* OK - The barrier directive is enclosed in a
*      compound statement.
*/
if (x!=0) {
   #pragma omp barrier
}
```

### <a name="264-atomic-construct"></a>2.6.4 atomic コンストラクト

`atomic` ディレクティブを使うと、複数の同時書き込みスレッドが同時に発生する可能性があるのではなく、特定のメモリ位置がアトミックに更新されるようになります。 `atomic` ディレクティブの構文は次のとおりです。

```cpp
#pragma omp atomic new-lineexpression-stmt
```

式ステートメントには、次のいずれかの形式を指定する必要があります。

- *x binop* `=` *expr*
- *x* `++`
- `++` *x*
- *x* `--`
- `--` *x*

上記の式では、次のようになります。

- *x*は、スカラー型の左辺値式です。

- *expr*はスカラー型の式であり、 *x*によって指定されたオブジェクトを参照しません。

- *binop*はオーバーロードされた演算子ではなく、`+`、`*`、`-`、`/`、`&`、`^`、`|`、`<<`、`>>`のいずれかです。

実装では、すべての `atomic` ディレクティブを、同じ一意の*名前*を持つ `critical` ディレクティブに置き換えるかどうかが実装定義されていますが、`atomic` ディレクティブを使用すると、より適切な最適化を行うことができます。 多くの場合、オーバーヘッドが最も少ないアトミック更新を実行できるハードウェアの指示があります。

*X*によって指定されたオブジェクトの読み込みとストアのみがアトミックです。*expr*の評価はアトミックではありません。 競合状態を回避するには、その場所のすべての更新プログラムを `atomic` ディレクティブで保護する必要があります。ただし、競合状態が発生しないことがわかっている場合を除きます。

`atomic` ディレクティブには次の制限があります。

- プログラム全体のストレージ位置 x へのすべてのアトミック参照には、互換性のある型が必要です。

#### <a name="examples"></a>例

```cpp
extern float a[], *p = a, b;
/* Protect against races among multiple updates. */
#pragma omp atomic
a[index[i]] += b;
/* Protect against races with updates through a. */
#pragma omp atomic
p[i] -= 1.0f;

extern union {int n; float x;} u;
/* ERROR - References through incompatible types. */
#pragma omp atomic
u.n++;
#pragma omp atomic
u.x -= 1.0f;
```

### <a name="265-flush-directive"></a>2.6.5 flush ディレクティブ

`flush` ディレクティブは、明示的か暗黙的かにかかわらず、"スレッド間" シーケンスポイントを指定します。これにより、チーム内のすべてのスレッドが、メモリ内の特定のオブジェクト (下で指定) の一貫したビューを持つようになります。 これは、これらのオブジェクトを参照する式の前の評価が完了し、後続の評価がまだ開始されていないことを意味します。 たとえば、コンパイラは、レジスタからメモリにオブジェクトの値を復元する必要があります。また、ハードウェアによっては、メモリに書き込みバッファーをフラッシュし、メモリからオブジェクトの値を再読み込みすることが必要になる場合があります。

`flush` ディレクティブの構文は次のとおりです。

```cpp
#pragma omp flush [(variable-list)]  new-line
```

同期を必要とするオブジェクトがすべて変数によって指定されている場合は、これらの変数を省略可能*な変数リスト*で指定できます。 ポインターが*変数リスト*に存在する場合は、ポインターが参照するオブジェクトではなく、ポインター自体がフラッシュされます。

*変数リスト*のない `flush` ディレクティブは、自動ストレージ存続期間が指定されたアクセスできないオブジェクトを除くすべての共有オブジェクトを同期します。 (これには、*変数リスト*を使用する `flush` よりも多くのオーバーヘッドが発生する可能性があります)。*変数リスト*のない `flush` ディレクティブは、次のディレクティブに対して暗黙的に指定されます。

- `barrier`
- `critical` を入力して終了する
- `ordered` を入力して終了する
- `parallel` を入力して終了する
- `for` からの終了時
- `sections` からの終了時
- `single` からの終了時
- `parallel for` を入力して終了する
- `parallel sections` を入力して終了する

`nowait` 句が存在する場合、ディレクティブは暗黙的に指定されません。 `flush` ディレクティブは、次のいずれに対しても暗黙的に指定されていないことに注意してください。

- 入力時に `for`
- `master` の開始時または終了時
- 入力時に `sections`
- 入力時に `single`

Volatile で修飾された型のオブジェクトの値にアクセスする参照は、前のシーケンスポイントでそのオブジェクトを指定する `flush` ディレクティブがあるかのように動作します。 Volatile で修飾された型のオブジェクトの値を変更する参照は、そのオブジェクトを後続のシーケンスポイントで指定する `flush` ディレクティブがあるかのように動作します。

`flush` ディレクティブには構文の一部として C 言語のステートメントがないため、プログラム内での配置にはいくつかの制限があります。 正式な文法の詳細については、「[付録 C](c-openmp-c-and-cpp-grammar.md)」を参照してください。次の例では、これらの制限について説明します。

```cpp
/* ERROR - The flush directive cannot be the immediate
*          substatement of an if statement.
*/
if (x!=0)
   #pragma omp flush (x)
...

/* OK - The flush directive is enclosed in a
*      compound statement
*/
if (x!=0) {
   #pragma omp flush (x)
}
```

`flush` ディレクティブには次の制限があります。

- `flush` ディレクティブで指定された変数は、参照型を持つことはできません。

### <a name="266-ordered-construct"></a>2.6.6 ordered ordered コンストラクト

`ordered` ディレクティブの後に続く構造化ブロックは、順次ループでイテレーションが実行される順序で実行されます。 `ordered` ディレクティブの構文は次のとおりです。

```cpp
#pragma omp ordered new-linestructured-block
```

`ordered` ディレクティブは、`for` または `parallel for` コンストラクトの動的な範囲内である必要があります。 `ordered` コンストラクトのバインド先の `for` または `parallel for` ディレクティブには、 [「2.4.1」](#241-for-construct)で説明されているように `ordered` 句を指定する必要があります。 `ordered` 句を使用して `for` または `parallel for` コンストラクトを実行すると、`ordered` コンストラクトは、ループの順次実行で実行される順序で厳密に実行されます。

`ordered` ディレクティブには次の制限があります。

- `for` コンストラクトを持つループの反復処理では、同じ順序付きディレクティブを複数回実行することはできません。また、複数の `ordered` ディレクティブを実行することはできません。

## <a name="27-data-environment"></a>2.7 データ環境

このセクションでは、次のように、並列領域の実行中にデータ環境を制御するためのディレクティブといくつかの句について説明します。

- ファイルスコープ、名前空間スコープ、または静的ブロックスコープ変数をスレッドに対してローカルにするために、 [threadprivate](#271-threadprivate-directive)ディレクティブが用意されています。

- 並列または作業共有コンストラクトの存続期間中に変数の共有属性を制御するためにディレクティブで指定できる句については、 [「2.7.2」を参照](#272-data-sharing-attribute-clauses)してください。

### <a name="271-threadprivate-directive"></a>2.7.1 threadprivate ディレクティブ

`threadprivate` ディレクティブを使用すると、*変数リスト*に指定されている名前付きのファイルスコープ、名前空間スコープ、または静的ブロックスコープ変数がスレッドに対してプライベートになります。 *変数リスト*は、不完全な型を持たない変数のコンマ区切りのリストです。 `threadprivate` ディレクティブの構文は次のとおりです。

```cpp
#pragma omp threadprivate(variable-list) new-line
```

`threadprivate` 変数の各コピーは、プログラム内の指定されていないポイントで、そのコピーへの最初の参照の前に1回、通常の方法 (つまり、マスターコピーがプログラムの直列実行で初期化されるため) に初期化されます。 オブジェクトが `threadprivate` 変数の明示的な初期化子で参照されていて、変数のコピーへの最初の参照の前にオブジェクトの値が変更されている場合、その動作は指定されていないことに注意してください。

任意のプライベート変数と同様に、スレッドは `threadprivate` オブジェクトの別のスレッドコピーを参照することはできません。 プログラムのシリアル領域とマスター領域の間に、参照は、オブジェクトのマスタースレッドのコピーに対して行われます。

最初の並列領域が実行された後、`threadprivate` オブジェクト内のデータは、動的スレッド機構が無効になっていて、すべての並列領域でスレッド数が変更されていない場合にのみ保持されることが保証されます。

`threadprivate` ディレクティブの制限は次のとおりです。

- ファイルスコープ変数または名前空間スコープ変数の `threadprivate` ディレクティブは、定義または宣言の外側に記述する必要があります。また、リスト内のいずれかの変数へのすべての参照の前に、構文を付ける必要があります。

- ファイルまたは名前空間スコープで `threadprivate` ディレクティブの変数*リスト*の各変数は、ディレクティブの前に構文的に指定されたファイルまたは名前空間スコープの変数宣言を参照する必要があります。

- 静的ブロックスコープ変数の `threadprivate` ディレクティブは、入れ子になったスコープではなく、変数のスコープ内に出現する必要があります。 ディレクティブは、そのリスト内の任意の変数へのすべての参照の前に構文的に付ける必要があります。

- ブロックスコープ内の `threadprivate` ディレクティブの*変数リスト*の各変数は、ディレクティブの前に構文付けされた同じスコープ内の変数宣言を参照する必要があります。 変数宣言では、static ストレージクラス指定子を使用する必要があります。

- 変数が1つの翻訳単位の `threadprivate` ディレクティブで指定されている場合は、その変数が宣言されているすべての翻訳単位の `threadprivate` ディレクティブで指定する必要があります。

- `threadprivate` 変数は、`copyin`、`copyprivate`、`schedule`、`num_threads`、または `if` 句以外の句では指定できません。

- `threadprivate` 変数のアドレスは、アドレス定数ではありません。

- `threadprivate` 変数は、不完全な型または参照型を含むことはできません。

- 非 POD クラス型の `threadprivate` 変数は、明示的な初期化子を使用して宣言されている場合、アクセス可能で明確なコピーコンストラクターを持つ必要があります。

次の例では、初期化子に表示される変数を変更すると、特定できない動作が発生する可能性があります。また、補助オブジェクトとコピーコンストラクターを使用して、この問題を回避する方法についても説明します。

```cpp
int x = 1;
T a(x);
const T b_aux(x); /* Capture value of x = 1 */
T b(b_aux);
#pragma omp threadprivate(a, b)

void f(int n) {
   x++;
   #pragma omp parallel for
   /* In each thread:
   * Object a is constructed from x (with value 1 or 2?)
   * Object b is copy-constructed from b_aux
   */
   for (int i=0; i<n; i++) {
      g(a, b); /* Value of a is unspecified. */
   }
}
```

#### <a name="cross-references"></a>相互参照

- [動的スレッド](3-run-time-library-functions.md#317-omp_set_dynamic-function)
- [OMP_DYNAMIC](4-environment-variables.md#43-omp_dynamic)環境変数

### <a name="272-data-sharing-attribute-clauses"></a>2.7.2 のデータ共有属性句

いくつかのディレクティブでは、領域の存続期間中、ユーザーが変数の共有属性を制御できるようにする句が受け入れられます。 属性句の共有は、句が出現するディレクティブの構文範囲内の変数にのみ適用されます。 すべてのディレクティブで、次の句のすべてが許可されているわけではありません。 特定のディレクティブで有効な句の一覧については、ディレクティブを参照してください。

並列または作業共有のコンストラクトが検出されたときに変数が表示され、共有属性の句または `threadprivate` ディレクティブで変数が指定されていない場合、変数は共有されます。 並列領域の動的な範囲内で宣言された静的変数は共有されます。 ヒープに割り当てられたメモリ (たとえば、C またC++はの `new` 演算子でC++の `malloc()` の使用) は共有されます。 (ただし、このメモリへのポインターは、プライベートまたは共有にすることができます)。並列領域の動的な範囲内で宣言された自動ストレージ存続期間を持つ変数はプライベートです。

ほとんどの句では、*変数リスト*の引数を受け取ります。これは、表示される変数のコンマ区切りのリストです。 データ共有属性句で参照されている変数にテンプレートから派生した型が含まれていて、その変数への参照がプログラム内に存在しない場合、動作は未定義になります。

ディレクティブ句内に出現するすべての変数が表示されている必要があります。 句は必要に応じて繰り返すことができますが、複数の句で変数を指定することはできません。ただし、`firstprivate` と `lastprivate` 句の両方で変数を指定することはできます。

次のセクションでは、データ共有属性句について説明します。

- [private](#2721-private)
- [firstprivate](#2722-firstprivate)
- [lastprivate](#2723-lastprivate)
- [共用](#2724-shared)
- [既定値](#2725-default)
- [reduction](#2726-reduction)
- [copyin](#2727-copyin)
- [copyprivate](#2728-copyprivate)

#### <a name="2721-private"></a>2.7.2.1 private

`private` 句では、変数リスト内の変数を、チーム内の各スレッドに対してプライベートとして宣言します。 `private` 句の構文は次のとおりです。

```cpp
private(variable-list)
```

`private` 句で指定された変数の動作は次のとおりです。 自動ストレージ存続期間を持つ新しいオブジェクトがコンストラクトに割り当てられます。 新しいオブジェクトのサイズとアラインメントは、変数の型によって決まります。 この割り当ては、チーム内のスレッドごとに1回実行され、必要に応じてクラスオブジェクトに対して既定のコンストラクターが呼び出されます。それ以外の場合、初期値は不確定になります。  変数によって参照される元のオブジェクトは、コンストラクターへのエントリ時に不定の値を持ち、構造体の動的な範囲内では変更できません。また、コンストラクトから終了すると、不確定の値が保持されます。

ディレクティブコンストラクトの構文の範囲では、変数はスレッドによって割り当てられた新しいプライベートオブジェクトを参照します。

`private` 句には次の制限があります。

- `private` 句で指定されたクラス型の変数には、アクセス可能で明確な既定のコンストラクターが必要です。

- `private` 句で指定された変数には、`mutable` メンバーを持つクラス型が含まれていない限り、`const`修飾型を持つことはできません。

- `private` 句で指定された変数は、不完全な型または参照型を含むことはできません。

- `parallel` ディレクティブの `reduction` 句に表示される変数は、parallel コンストラクトにバインドされる作業共有ディレクティブの `private` 句では指定できません。

#### <a name="2722-firstprivate"></a>2.7.2.2 firstprivate

`firstprivate` 句は、`private` 句によって提供される機能のスーパーセットを提供します。 `firstprivate` 句の構文は次のとおりです。

```cpp
firstprivate(variable-list)
```

*変数リスト*で指定された変数には、 [2.7.2.1 セクション](#2721-private)で説明されているように、`private` 句のセマンティクスがあります。 初期化または構築は、スレッドごとに1回実行された場合と同様に発生します。これは、スレッドがコンストラクトを実行する前に行われます。 Parallel コンストラクトの `firstprivate` 句の場合、新しいプライベートオブジェクトの初期値は、それを発生させたスレッドの並列コンストラクトの直前に存在する元のオブジェクトの値になります。 ワーク共有コンストラクトの `firstprivate` 句の場合、作業共有コンストラクトを実行する各スレッドの新しいプライベートオブジェクトの初期値は、同じスレッドが作業共有コンストラクトを検出した時点より前に存在していた元のオブジェクトの値です。 また、オブジェクトにC++ついては、各スレッドの新しいプライベートオブジェクトが、元のオブジェクトから構築されたコピーです。

`firstprivate` 句には次の制限があります。

- `firstprivate` 句で指定された変数は、不完全な型または参照型を含むことはできません。

- `firstprivate` として指定されたクラス型の変数には、アクセス可能で明確なコピーコンストラクターが必要です。

- 並列領域内でプライベートであるか、または `parallel` ディレクティブの `reduction` 句に記述されている変数は、parallel コンストラクトにバインドされているワークシェアリングディレクティブの `firstprivate` 句では指定できません。

#### <a name="2723-lastprivate"></a>2.7.2.3 lastprivate

`lastprivate` 句は、`private` 句によって提供される機能のスーパーセットを提供します。 `lastprivate` 句の構文は次のとおりです。

```cpp
lastprivate(variable-list)
```

*変数リスト*で指定された変数には、`private` 句のセマンティクスがあります。 作業共有コンストラクトを識別するディレクティブに `lastprivate` 句が指定されている場合、関連付けられているループの最後の繰り返しである各 `lastprivate` 変数の値、または構文の最後の section ディレクティブが、変数の元のオブジェクトに代入されます。 `for` または `parallel for`の最後の反復処理によって値が割り当てられていない変数、または `sections` または `parallel sections` ディレクティブの構文的に最後のセクションによって値が割り当てられていない変数は、コンストラクトの後に不確定の値を持ちます。 未割り当てサブオブジェクトにも、コンストラクトの後に不定の値があります。

`lastprivate` 句には次の制限があります。

- `private` のすべての制限が適用されます。

- `lastprivate` として指定されたクラス型の変数には、アクセス可能で明確なコピー代入演算子が必要です。

- 並列領域内でプライベートであるか、または `parallel` ディレクティブの `reduction` 句に記述されている変数は、parallel コンストラクトにバインドされているワークシェアリングディレクティブの `lastprivate` 句では指定できません。

#### <a name="2724-shared"></a>2.7.2.4 shared

この句は、チーム内のすべてのスレッドの中で*変数リスト*に表示される変数を共有します。 チーム内のすべてのスレッドは、`shared` 変数に対して同じストレージ領域にアクセスします。

`shared` 句の構文は次のとおりです。

```cpp
shared(variable-list)
```

#### <a name="2725-default"></a>2.7.2.5 default

`default` 句を使用すると、ユーザーは変数のデータ共有属性に影響を与えることができます。 `default` 句の構文は次のとおりです。

```cpp
default(shared | none)
```

`default(shared)` を指定することは、`threadprivate` または `const`修飾されていない限り、`shared` の句に現在表示されている変数を明示的に一覧表示することと同じです。 明示的な `default` 句が存在しない場合、既定の動作は `default(shared)` が指定されている場合と同じです。

`default(none)` を指定するには、parallel コンストラクトの構文の範囲内にある変数への参照ごとに、次の少なくとも1つを true にする必要があります。

- 変数は、参照を含む構造体のデータ共有属性句に明示的にリストされます。

- 変数は、parallel コンストラクト内で宣言されます。

- 変数は `threadprivate`です。

- 変数には、`const`で修飾された型があります。

- 変数は、`for` または `parallel for` ディレクティブの直後にある `for` ループのループコントロール変数で、変数参照がループ内に表示されます。

囲まれたディレクティブの `firstprivate`、`lastprivate`、または `reduction` 句で変数を指定すると、それを囲むコンテキスト内の変数への暗黙的な参照が発生します。 このような暗黙的な参照についても、上記の要件が適用されます。

`parallel` ディレクティブで指定できるのは、1つの `default` 句だけです。

変数の既定のデータ共有属性は、次の例に示すように、`private`、`firstprivate`、`lastprivate`、`reduction`、および `shared` の各句を使用してオーバーライドできます。

```cpp
#pragma  omp  parallel  for  default(shared)  firstprivate(i)\
   private(x)  private(r)  lastprivate(i)
```

#### <a name="2726-reduction"></a>2.7.2.6 reduction

この句は、*変数リスト*に表示されるスカラー変数を、operator *op*と共に減らします。 `reduction` 句の構文は次のとおりです。

`reduction(` *op* `:`*変数リスト*`)`

通常、リダクションは、次のいずれかの形式のステートメントに対して指定されます。

- *x* `=` *x* *op* *expr*
- *x* *binop* `=` *expr*
- *x* `=` *expr* *op* *x* (減算を除く)
- *x* `++`
- `++` *x*
- *x* `--`
- `--` *x*

各値の説明:

*x*<br/>
リストで指定されているリダクション変数の1つ。

*変数リスト*<br/>
スカラーリダクション変数のコンマ区切りのリスト。

*expr*<br/>
*X*を参照しないスカラー型の式。

*ファンド*<br/>
オーバーロードされた演算子ではありませんが、`+`、`*`、`-`、`&`、`^`、`|`、`&&`、`||`のいずれかです。

*ビン op*<br/>
オーバーロードされた演算子ではありませんが、`+`、`*`、`-`、`&`、`^`、`|`のいずれかです。

`reduction` 句の例を次に示します。

```cpp
#pragma omp parallel for reduction(+: a, y) reduction(||: am)
for (i=0; i<n; i++) {
   a += b[i];
   y = sum(y, c[i]);
   am = am || b[i] == c[i];
}
```

この例に示すように、演算子は関数呼び出し内で非表示にすることができます。 ユーザーは、`reduction` 句に指定された演算子がリダクション操作と一致することに注意する必要があります。

この例では `||` 演算子の右オペランドに副作用はありませんが、許可されていますが、注意して使用する必要があります。 このコンテキストでは、ループの順次実行中に発生しないことが保証されている副作用が並列実行中に発生する可能性があります。 この違いは、イテレーションの実行順序が不確定であることが原因で発生する可能性があります。

演算子は、減少のためにコンパイラによって使用されるプライベート変数の初期値を決定し、終了演算子を決定するために使用されます。 演算子を明示的に指定すると、リダクションステートメントをコンストラクトの構文の範囲外にすることができます。 ディレクティブには任意の数の `reduction` 句を指定できますが、変数はそのディレクティブに対して最大で1つの `reduction` 句に記述できます。

`private` 句が使用されているかのように、スレッドごとに1つずつ、*変数リスト*の各変数のプライベートコピーが作成されます。 プライベートコピーは、演算子に従って初期化されます (次の表を参照)。

`reduction` 句が指定された領域の最後で、元のオブジェクトが更新され、元の値と各プライベートコピーの最終的な値との組み合わせによって、指定された演算子が使用されます。 リダクション演算子はすべて連想 (減算を除く) であり、コンパイラは最終的な値の計算を自由に再関連付けできます。 (減算リダクションの部分的な結果は、最終的な値を形成するために追加されます)。

最初のスレッドが外側の句に達したときに、元のオブジェクトの値が不確定になり、リダクションの計算が完了するまでそのままになります。  通常、計算はコンストラクトの最後に完了します。ただし、`nowait` を適用するコンストラクトで `reduction` 句を使用した場合、すべてのスレッドが `reduction` 句を完了するようにバリア同期が実行されるまで、元のオブジェクトの値は不確定のままになります。

次の表に、有効な演算子と、その正規の初期化値の一覧を示します。 実際の初期化値は、リダクション変数のデータ型と一致します。

|演算子|初期化|
|--------------|--------------------|
|`+`|0|
|`*`|1|
|`-`|0|
|`&`|~0|
|`|`|0|
|`^`|0|
|`&&`|1|
|`||`|0|

`reduction` 句には次の制限があります。

- `reduction` 句の変数の型は、ポインター型と参照型を使用できないことを除いて、リダクション演算子に対して有効である必要があります。

- `reduction` 句で指定された変数は、`const`修飾されていない必要があります。

- 並列領域内でプライベートであるか、または `parallel` ディレクティブの `reduction` 句に記述されている変数は、parallel コンストラクトにバインドされているワークシェアリングディレクティブの `reduction` 句では指定できません。

   ```cpp
   #pragma omp parallel private(y)
   { /* ERROR - private variable y cannot be specified
                in a reduction clause */
      #pragma omp for reduction(+: y)
      for (i=0; i<n; i++)
         y += b[i];
   }

   /* ERROR - variable x cannot be specified in both
              a shared and a reduction clause */
   #pragma omp parallel for shared(x) reduction(+: x)
   ```

#### <a name="2727-copyin"></a>2.7.2.7 copyin

`copyin` 句は、並行領域を実行するチーム内の各スレッドの `threadprivate` 変数に同じ値を割り当てるためのメカニズムを提供します。 `copyin` 句で指定された各変数について、チームのマスタースレッド内の変数の値が、並行領域の先頭のスレッドプライベートコピーに割り当てられているかのようにコピーされます。 `copyin` 句の構文は次のとおりです。

```cpp

copyin(
variable-list
)
```

`copyin` 句には次の制限があります。

- `copyin` 句で指定する変数には、アクセス可能で明確なコピー代入演算子が必要です。

- `copyin` 句で指定する変数は、`threadprivate` 変数である必要があります。

#### <a name="2728-copyprivate"></a>2.7.2.8 copyprivate

`copyprivate` 句は、プライベート変数を使用して、チームのあるメンバーから他のメンバーに値をブロードキャストするメカニズムを提供します。 このような共有変数を指定する場合は、共有変数を値として使用するのが難しい場合があります (たとえば、各レベルで異なる変数を必要とする再帰の場合など)。 `copyprivate` 句は、`single` ディレクティブでのみ使用できます。

`copyprivate` 句の構文は次のとおりです。

```cpp

copyprivate(
variable-list
)
```

変数リスト内の変数に対する `copyprivate` 句の効果は、`single` コンストラクトに関連付けられている構造化ブロックの実行後、およびチーム内のすべてのスレッドがコンストラクトの最後にバリアを離れた前に発生します。 次に、チーム内の他のすべてのスレッドで、*変数リスト*の各変数に対して、その変数が (代入によって) 定義されて、その構成要素の構造化ブロックを実行したスレッド内の対応する変数の値が定義されます。

`copyprivate` 句には次の制限があります。

- `copyprivate` 句で指定された変数は、同じ `single` ディレクティブの `private` または `firstprivate` 句には記述できません。

- 並列領域の動的範囲内で `copyprivate` 句を含む `single` ディレクティブが検出された場合、`copyprivate` 句で指定されたすべての変数は、それを囲むコンテキスト内でプライベートである必要があります。

- `copyprivate` 句で指定する変数には、アクセス可能な明確なコピー代入演算子が必要です。

## <a name="28-directive-binding"></a>2.8 ディレクティブバインド

ディレクティブの動的バインドは、次の規則に従う必要があります。

- `for`、`sections`、`single`、`master`、および `barrier` ディレクティブは、そのディレクティブに存在する可能性のあるすべての `parallel`句の値に関係なく、動的に囲まれた `if` が存在する場合は、そのにバインドされます。 並列領域が現在実行されていない場合は、マスタースレッドだけで構成されるチームによって、ディレクティブが実行されます。

- `ordered` ディレクティブは、動的に囲まれた `for`にバインドします。

- `atomic` ディレクティブは、現在のチームだけでなく、すべてのスレッドの `atomic` ディレクティブに対して排他アクセスを強制します。

- `critical` ディレクティブは、現在のチームだけでなく、すべてのスレッドの `critical` ディレクティブに対して排他アクセスを強制します。

- ディレクティブは、最も近い動的な `parallel`の外側にあるディレクティブにバインドすることはできません。

## <a name="29-directive-nesting"></a>2.9 ディレクティブの入れ子

ディレクティブの動的な入れ子は、次の規則に従う必要があります。

- `parallel` ディレクティブは、入れ子になった並列処理が有効になっている場合を除き、現在のスレッドだけで構成される新しいチームを、別の `parallel` 内部で動的に確立します。

- 同じ `parallel` にバインドする `for`、`sections`、および `single` ディレクティブは、入れ子にすることはできません。

- 同じ名前を持つ `critical` ディレクティブを相互に入れ子にすることはできません。 この制限は、デッドロックを防ぐためには不十分であることに注意してください。

- ディレクティブが領域と同じ `ordered`にバインドされている場合、`for`、`sections`、および `single` ディレクティブは、`critical`、`master`、および `parallel` の領域の動的な範囲内では許可されません。

- ディレクティブが領域と同じ `single`にバインドされている場合、`barrier` ディレクティブは、`for`、`ordered`、`sections`、`master`、`critical`、および `parallel` の各領域の動的な範囲内では許可されません。

- `master` ディレクティブは、`for`、`sections`、および `single` ディレクティブの動的な範囲内では許可されません。これは、`master` ディレクティブが、ワークシェアリングディレクティブと同じ `parallel` にバインドされている場合です。

- ディレクティブが領域と同じ `parallel` にバインドされている場合、`critical` 領域の動的な範囲では `ordered` ディレクティブを使用できません。

- 並列領域内で動的に実行された場合に許可されるディレクティブは、並列領域の外側で実行される場合にも許可されます。 ユーザー指定の並列領域の外側で動的に実行される場合、このディレクティブは、マスタースレッドだけで構成されるチームによって実行されます。
