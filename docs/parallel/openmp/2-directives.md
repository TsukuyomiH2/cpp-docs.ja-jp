---
title: 2. ディレクティブ
ms.date: 01/18/2019
ms.assetid: d1a69374-6c03-45fb-8c86-e91cea8adae8
ms.openlocfilehash: 5b2649a65efd3368cf8a4d2649a424b1a539f1ef
ms.sourcegitcommit: ec6dd97ef3d10b44e0fedaa8e53f41696f49ac7b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/25/2020
ms.locfileid: "88841975"
---
# <a name="2-directives"></a>2. ディレクティブ

ディレクティブは `#pragma` 、c および C++ 標準で定義されているディレクティブに基づいています。  OpenMP C および C++ API をサポートするコンパイラには、すべての OpenMP コンパイラディレクティブをアクティブ化して解釈できるコマンドラインオプションが含まれています。

## <a name="21-directive-format"></a>2.1 ディレクティブの形式

OpenMP ディレクティブの構文は、 [付録 C](c-openmp-c-and-cpp-grammar.md)の文法によって正式に指定されており、次のように非公式に指定されています。

```cpp
#pragma omp directive-name  [clause[ [,] clause]...] new-line
```

各ディレクティブはで始まり  `#pragma omp` 、同じ名前を持つ他の (openmp またはベンダーの拡張の openmp) プラグマディレクティブとの競合の可能性を低減します。 ディレクティブの残りの部分は、コンパイラディレクティブの C および C++ 標準の規則に従います。 特に、の前後で空白文字を使用できます。また、場合によっては、 `#` ディレクティブ内の単語を区切るために空白文字を使用する必要があります。 に続くプリプロセストークン `#pragma omp` は、マクロ置換の対象となります。

ディレクティブでは大文字と小文字が区別されます。 ディレクティブに句が出現する順序は重要ではありません。 ディレクティブの句は、各句の説明に示されている制限に従って、必要に応じて繰り返すことができます。 *変数リスト*が句に含まれている場合は、変数のみを指定する必要があります。 ディレクティブごと *に1つのディレクティブ名* だけを指定できます。  たとえば、次のディレクティブは使用できません。

```cpp
/* ERROR - multiple directive names not allowed */
#pragma omp parallel barrier
```

OpenMP ディレクティブは、1つの後続のステートメントにのみ適用されます。これは、構造化されたブロックである必要があります。

## <a name="22-conditional-compilation"></a>2.2 条件付きコンパイル

`_OPENMP`マクロ名は、OpenMP 準拠の実装によって、10進数の定数*yyyymm*として定義されます。これは、承認された仕様の年と月になります。 このマクロは、 `#define` またはプリプロセスディレクティブの対象にすることはできません `#undef` 。

```cpp
#ifdef _OPENMP
iam = omp_get_thread_num() + index;
#endif
```

ベンダーが OpenMP の拡張機能を定義する場合は、追加の定義済みマクロを指定することができます。

## <a name="23-parallel-construct"></a>2.3 parallel コンストラクト

次のディレクティブは、並列領域を定義します。これは、多くのスレッドで並列に実行されるプログラムの領域です。 このディレクティブは、並列実行を開始する基本的なコンストラクトです。

```cpp
#pragma omp parallel [clause[ [, ]clause] ...] new-line   structured-block
```

*句*は次のいずれかです。

- `if(`*スカラー式*`)`
- `private(`*変数リスト*`)`
- `firstprivate(`*変数リスト*`)`
- `default(shared | none)`
- `shared(`*変数リスト*`)`
- `copyin(`*変数リスト*`)`
- `reduction(`*演算子* `:`*変数リスト*  `)`
- `num_threads(`*整数-式*`)`

スレッドが並列コンストラクトになると、次のいずれかのケースに該当する場合にスレッドのチームが作成されます。

- `if`句が存在しません。
- 式は、 `if` 0 以外の値に評価されます。

このスレッドは、スレッド番号が0のチームのマスタスレッドになり、チーム内のすべてのスレッド (マスタースレッドを含む) が並列でリージョンを実行します。 式の値が0の場合、 `if` 領域はシリアル化されます。

要求されるスレッドの数を決定するために、次の規則が順番に考慮されます。 条件が満たされた最初の規則が適用されます。

1. `num_threads`句が存在する場合、整数式の値は要求されたスレッドの数になります。

1. `omp_set_num_threads`ライブラリ関数が呼び出された場合、最後に実行された呼び出しの引数の値が、要求されたスレッドの数になります。

1. 環境変数が定義されている場合 `OMP_NUM_THREADS` 、この環境変数の値は、要求されたスレッドの数になります。

1. 上記のいずれの方法も使用しない場合、要求されるスレッドの数は実装によって定義されます。

`num_threads`句が指定されている場合は、ライブラリ関数によって要求されたスレッドの数、 `omp_set_num_threads` または、それが適用されている `OMP_NUM_THREADS` 並列領域の環境変数に優先します。 後の並列領域は影響を受けません。

並列領域を実行するスレッドの数は、スレッド数の動的調整が有効になっているかどうかによっても異なります。 動的調整が無効になっている場合、要求されたスレッド数によって並列領域が実行されます。 動的調整が有効になっている場合、要求されたスレッド数は、並列領域を実行できるスレッドの最大数になります。

スレッド数の動的調整が無効になっている間に並列領域が発生し、並列領域に要求されたスレッドの数が、ランタイムシステムが提供できる数を超えている場合、プログラムの動作は実装によって定義されます。 たとえば、実装では、プログラムの実行を中断したり、並列領域をシリアル化したりすることができます。

`omp_set_dynamic`ライブラリ関数と `OMP_DYNAMIC` 環境変数を使用して、スレッド数の動的調整を有効または無効にすることができます。

特定の時点でスレッドを実際にホストしている物理プロセッサの数は、実装によって定義されます。 作成されると、チーム内のスレッドの数は、その並列領域の継続時間に対して一定のままになります。 ユーザーによって明示的に変更することも、並列領域間でランタイムシステムによって自動的に変更することもできます。

並列領域の動的な範囲内に含まれるステートメントは、各スレッドによって実行されます。また、各スレッドは、他のスレッドとは異なるステートメントのパスを実行できます。 並列領域の構文の範囲外で見つかったディレクティブは、孤立したディレクティブと呼ばれます。

並列領域の最後には暗黙的なバリアがあります。 並列領域の最後で実行を継続するのは、チームのマスタースレッドだけです。

並列領域を実行しているチームのスレッドが別の並列コンストラクトを検出すると、新しいチームが作成され、その新しいチームのマスターになります。 入れ子になった並列領域は、既定でシリアル化されます。 その結果、既定では、入れ子になった並列領域は1つのスレッドで構成されるチームによって実行されます。 既定の動作は、ランタイムライブラリ関数または環境変数のいずれかを使用して変更でき `omp_set_nested` `OMP_NESTED` ます。 ただし、入れ子になった並列領域を実行するチーム内のスレッドの数は実装によって定義されます。

`parallel`ディレクティブには次の制限があります。

- ディレクティブには、最大で1つの `if` 句を含めることができます。

- If 式または式の中で副作用が発生したかどうかは、指定さ `num_threads` れていません。

- `throw`並列領域内で実行されるは、同じ構造化ブロックの動的な範囲内で実行が再開される必要があり、例外をスローしたのと同じスレッドでキャッチする必要があります。

- `num_threads`ディレクティブに使用できる句は1つだけです。 `num_threads`式は、並列領域のコンテキストの外側で評価され、正の整数値に評価される必要があります。

- 句と句の評価順序 `if` `num_threads` は指定されていません。

### <a name="cross-references"></a>相互参照

- `private`、 `firstprivate` 、 `default` 、 `shared` 、 `copyin` 、および `reduction` 句 ([セクション 2.7.2](#272-data-sharing-attribute-clauses))
- [OMP_NUM_THREADS](4-environment-variables.md#42-omp_num_threads) 環境変数
- [omp_set_dynamic](3-run-time-library-functions.md#317-omp_set_dynamic-function) ライブラリ関数
- [OMP_DYNAMIC](4-environment-variables.md#43-omp_dynamic) 環境変数
- [omp_set_nested](3-run-time-library-functions.md#319-omp_set_nested-function) 関数
- [OMP_NESTED](4-environment-variables.md#44-omp_nested) 環境変数
- [omp_set_num_threads](3-run-time-library-functions.md#311-omp_set_num_threads-function) ライブラリ関数

## <a name="24-work-sharing-constructs"></a>2.4 作業共有コンストラクト

作業共有コンストラクトは、関連付けられているステートメントの実行を、それを発生させたチームのメンバー間で分散します。 作業共有ディレクティブは、新しいスレッドを起動しません。また、ワーク共有コンストラクトへのエントリには暗黙のバリアがありません。

検出された作業共有のコンストラクトとディレクティブのシーケンスは、 `barrier` チーム内のすべてのスレッドで同じである必要があります。

OpenMP では、次の作業共有コンストラクトが定義されています。これらの構成要素については、次のセクションで説明します。

- ディレクティブ[の場合](#241-for-construct)
- [sections](#242-sections-construct) ディレクティブ
- [単一](#243-single-construct) ディレクティブ

### <a name="241-for-construct"></a>2.4.1 for コンストラクト

ディレクティブは、 `for` 関連付けられているループの反復処理が並列で実行されることを指定する反復作業共有コンストラクトを識別します。 ループの反復は、 `for` バインド先の並列コンストラクトを実行しているチーム内に既に存在する複数のスレッドに分散されます。 コンストラクトの構文 `for` は次のとおりです。

```cpp
#pragma omp for [clause[[,] clause] ... ] new-line for-loop
```

句は次のいずれかです。

- `private(`*変数リスト*`)`
- `firstprivate(`*変数リスト*`)`
- `lastprivate(`*変数リスト*`)`
- `reduction(`*演算子* `:`*変数リスト*`)`
- `ordered`
- `schedule(`*kind* [ `,` *chunk_size*]`)`
- `nowait`

ディレクティブは、 `for` 対応するループの構造に制限を設け `for` ます。 具体的には、対応するループには `for` 正規の図形が必要です。

`for (`*init-expr* `;`*var 論理 op b* `;`*incr-expr*`)`

*init-expr*<br/>
次のいずれかになります。

- *var*  = *lb*
- *整数型の var*  = *lb*

*incr-expr*<br/>
次のいずれかになります。

- `++`*var*
- *var*`++`
- `--`*var*
- *var*`--`
- *var* `+=`*incr*
- *var* `-=`*incr*
- *var* `=`*var* `+`*incr*
- *var* `=`*incr* `+`*var*
- *var* `=`*var* `-`*incr*

*var*<br/>
符号付き整数変数。 この変数が共有されない場合は、の間、暗黙的にプライベートになり `for` ます。 ステートメントの本体内でこの変数を変更しないでください `for` 。 変数を指定しない限り `lastprivate` 、ループの後の値は不確定になります。

*論理操作*<br/>
次のいずれかになります。

- `<`
- `<=`
- `>`
- `>=`

*lb*、 *b*、および *incr*<br>
ループインバリアント整数式。 これらの式の評価中に同期が行われないため、評価された副作用によって不確定な結果が生成されます。

正規の形式を使用すると、ループのエントリに対してループの反復回数を計算できます。 この計算は、整数の上位変換の後に、 *var*の型の値を使用して行われます。 特に、 *b* `-` *lb* `+` *incr* の値をその型で表すことができない場合、結果は不確定になります。 さらに、*論理*操作が `<` またはの場合は、 `<=` ループの各反復処理によって*var*が増加する必要があります。 *incr-expr*   *論理 op*がまたは `>` `>=` の場合、各ループの反復処理のたびに、 *incr-expr*によって*var*が小さくなる必要があります。

句は、 `schedule` ループの反復処理をチームのスレッド間でどのように分割するかを指定し `for` ます。 プログラムの正確性は、特定の反復処理を実行するスレッドに依存しないようにする必要があります。 *Chunk_size*の値 (指定されている場合) は、正の値を持つループインバリアント整数式である必要があります。 この式の評価中に同期が行われないため、評価された副作用によって不確定な結果が生成されます。 スケジュールの *種類* には、次のいずれかの値を指定できます。

表 2-1: `schedule` 句の *種類* の値

|値|説明|
|-|-|
|static|`schedule(static,` *Chunk_size* `)` が指定されている場合、イテレーションは*chunk_size*によって指定されたサイズのチャンクに分割されます。 チャンクは、スレッド番号の順序でラウンドロビン方式でチーム内のスレッドに静的に割り当てられます。 *Chunk_size*が指定されていない場合、反復領域は約同じサイズのチャンクに分割され、1つのチャンクが各スレッドに割り当てられます。|
|動的|`schedule(dynamic,` *Chunk_size* `)` が指定されている場合、イテレーションは一連のチャンクに分割され、それぞれに*chunk_size*のイテレーションが含まれます。 各チャンクは、割り当てを待機しているスレッドに割り当てられます。 スレッドは、反復処理のチャンクを実行し、次の割り当てを待機します。その後、割り当てられたチャンクが残っていません。 最後に割り当てられるチャンクには、イテレーションの数が少ない場合があります。 *Chunk_size*が指定されていない場合、既定値は1です。|
|ガイド付き|`schedule(guided,` *Chunk_size* `)` が指定されている場合、イテレーションはサイズの小さいチャンク単位のスレッドに割り当てられます。 スレッドは、割り当てられたイテレーションのチャンクを完了すると、何も残っていなくなるまで、動的に別のチャンクに割り当てられます。 *Chunk_size*が1の場合、各チャンクのサイズは、割り当てられていないイテレーションの数をスレッド数で割った値になります。 これらのサイズは、ほぼ指数関数的に1に減少します。 1を*超える値が*指定された*chunk_size*の場合、最後のチャンクの反復回数が*k*未満である点を除いて、サイズはほぼ指数関数*的に減少*します。 *Chunk_size*が指定されていない場合、既定値は1です。|
|ランタイム|を指定した場合 `schedule(runtime)` 、スケジュールに関する決定は実行時まで延期されます。 実行時に、環境変数を設定することによって、スケジュールの *種類* とチャンクサイズを選択でき `OMP_SCHEDULE` ます。 この環境変数が設定されていない場合、結果のスケジュールは実装定義になります。 を指定した場合  `schedule(runtime)` 、 *chunk_size* を指定することはできません。|

明示的に定義された句が存在しない `schedule` 場合、既定値 `schedule` は実装によって定義されます。

OpenMP 準拠プログラムは、適切な実行のために特定のスケジュールに依存しないでください。 プログラムは、上記の説明に正確に準拠したスケジュールの *種類* に依存しないようにする必要があります。これは、さまざまなコンパイラで同じスケジュールの *種類* の実装にバリエーションを持たせることができるためです。 説明を使用すると、特定の状況に適したスケジュールを選択できます。

`ordered`ディレクティブがコンストラクトにバインドされている場合は、句が存在する必要があり `ordered` `for` ます。

`for`句が指定されていない場合、コンストラクトの最後に暗黙的なバリアがあり `nowait` ます。

`for`ディレクティブには次の制限があります。

- `for`ループは構造化ブロックである必要があります。さらに、ステートメントによって実行を終了することもできません **`break`** 。

- `for`ディレクティブに関連付けられているループのループコントロール式の値は、 `for` チーム内のすべてのスレッドで同じである必要があります。

- `for`ループ反復変数は、符号付き整数型である必要があります。

- `schedule`ディレクティブに使用できる句は1つだけ `for` です。

- `ordered`ディレクティブに使用できる句は1つだけ `for` です。

- `nowait`ディレクティブに使用できる句は1つだけ `for` です。

- *Chunk_size*、 *lb*、 *b*、または*incr*の式の中で副作用が発生するかどうかは指定されていません。

- *Chunk_size*式の値は、チーム内のすべてのスレッドで同じである必要があります。

#### <a name="cross-references"></a>相互参照

- `private`、 `firstprivate` 、 `lastprivate` 、および `reduction` 句 ([セクション 2.7.2](#272-data-sharing-attribute-clauses))
- [OMP_SCHEDULE](4-environment-variables.md#41-omp_schedule) 環境変数
- [順序付け](#266-ordered-construct) られたコンストラクト
- [schedule](d-using-the-schedule-clause.md) 句

### <a name="242-sections-construct"></a>2.4.2 sections コンストラクト

ディレクティブは、 `sections` チーム内のスレッド間で分割される構造のセットを指定する、非反復的な作業共有コンストラクトを識別します。 各セクションは、チーム内のスレッドによって1回実行されます。 ディレクティブの構文は次のとおり `sections` です。

```cpp
#pragma omp sections [clause[[,] clause] ...] new-line
   {
   [#pragma omp section new-line]
      structured-block
   [#pragma omp section new-linestructured-block ]
...
}
```

句は次のいずれかです。

- `private(`*変数リスト*`)`
- `firstprivate(`*変数リスト*`)`
- `lastprivate(`*変数リスト*`)`
- `reduction(`*演算子* `:`*変数リスト*  `)`
- `nowait`

各セクションの前にはディレクティブがありますが、 `section` ディレクティブは最初のセクションで `section` は省略可能です。 ディレクティブは、 `section` ディレクティブの構文の範囲内に記述する必要があり `sections` ます。 `sections`が指定されていない場合、コンストラクトの最後に暗黙的なバリアがあり `nowait` ます。

`sections`ディレクティブには次の制限があります。

- ディレクティブ `section` の構文の範囲外にディレクティブを記述することはできません `sections` 。

- `nowait`ディレクティブに使用できる句は1つだけ `sections` です。

#### <a name="cross-references"></a>相互参照

- `private`、 `firstprivate` 、 `lastprivate` 、および `reduction` 句 ([セクション 2.7.2](#272-data-sharing-attribute-clauses))

### <a name="243-single-construct"></a>2.4.3 single コンストラクト

ディレクティブは、 `single` 関連付けられた構造化ブロックがチーム内の1つのスレッドによって実行される (必ずしもマスタースレッドではない) ことを指定するコンストラクトを識別します。 ディレクティブの構文は次のとおり `single` です。

```cpp
#pragma omp single [clause[[,] clause] ...] new-linestructured-block
```

句は次のいずれかです。

- `private(`*変数リスト*`)`
- `firstprivate(`*変数リスト*`)`
- `copyprivate(`*変数リスト*`)`
- `nowait`

`single`句が指定されていない場合、コンストラクトの後に暗黙的なバリアがあり `nowait` ます。

`single`ディレクティブには次の制限があります。

- `nowait`ディレクティブに使用できる句は1つだけ `single` です。
- 句を `copyprivate` 句と共に使用することはできません `nowait` 。

#### <a name="cross-references"></a>相互参照

- `private`、 `firstprivate` 、および `copyprivate` 句 ([セクション 2.7.2](#272-data-sharing-attribute-clauses))

## <a name="25-combined-parallel-work-sharing-constructs"></a>2.5 結合された並列作業共有構成体

結合された並列作業共有構成体は、1つの作業共有コンストラクトのみを持つ並行領域を指定するためのショートカットです。 これらのディレクティブのセマンティクスは、ディレクティブを明示的に指定し、 `parallel` その後に1つの作業共有コンストラクトを指定することと同じです。

次のセクションでは、結合された並列作業共有の構成要素について説明します。

- [parallel for](#251-parallel-for-construct) ディレクティブ
- [parallel sections](#252-parallel-sections-construct) ディレクティブ

### <a name="251-parallel-for-construct"></a>2.5.1 parallel for コンストラクト

`parallel for`ディレクティブは、 `parallel` 1 つのディレクティブだけを含む領域のショートカットです `for` 。 ディレクティブの構文は次のとおり `parallel for` です。

```cpp
#pragma omp parallel for [clause[[,] clause] ...] new-linefor-loop
```

このディレクティブを使用すると、句を除くディレクティブとディレクティブのすべての句が `parallel` `for` `nowait` 同じ意味と制限を持つことができます。 セマンティクスは、ディレクティブの直後にディレクティブを指定する `parallel` ことと同じ `for` です。

#### <a name="cross-references"></a>相互参照

- [parallel](#23-parallel-construct) ディレクティブ
- ディレクティブ[の場合](#241-for-construct)
- [データ属性句](#272-data-sharing-attribute-clauses)

### <a name="252-parallel-sections-construct"></a>2.5.2 parallel sections コンストラクト

ディレクティブには、 `parallel sections` 1 つのディレクティブだけを持つ領域を指定するためのショートカットフォームが用意されて `parallel` `sections` います。 セマンティクスは、ディレクティブの直後にディレクティブを指定する `parallel` ことと同じ `sections` です。 ディレクティブの構文は次のとおり `parallel sections` です。

```cpp
#pragma omp parallel sections  [clause[[,] clause] ...] new-line
   {
   [#pragma omp section new-line]
      structured-block
   [#pragma omp section new-linestructured-block  ]
   ...
}
```

句は、句を除き、ディレクティブとディレクティブで受け入れられる句のいずれかに *することが* でき `parallel` `sections` `nowait` ます。

#### <a name="cross-references"></a>相互参照

- [parallel](#23-parallel-construct) ディレクティブ
- [sections](#242-sections-construct) ディレクティブ

## <a name="26-master-and-synchronization-directives"></a>2.6 マスターおよび同期ディレクティブ

次のセクションでは、について説明します。

- [マスター](#261-master-construct) コンストラクト
- [重大な](#262-critical-construct) 構成体
- [バリア](#263-barrier-directive) ディレクティブ
- [atomic](#264-atomic-construct) コンストラクト
- [flush](#265-flush-directive) ディレクティブ
- [順序付け](#266-ordered-construct) られたコンストラクト

### <a name="261-master-construct"></a>2.6.1 マスターコンストラクト

ディレクティブは、 `master` チームのマスタースレッドによって実行される構造化ブロックを指定するコンストラクトを識別します。 ディレクティブの構文は次のとおり `master` です。

```cpp
#pragma omp master new-linestructured-block
```

チーム内の他のスレッドは、関連付けられている構造化ブロックを実行しません。 Master コンストラクトへの入力または終了時に暗黙的なバリアはありません。

### <a name="262-critical-construct"></a>2.6.2 critical コンストラクト

ディレクティブは、 `critical` 関連する構造化ブロックの実行を一度に1つのスレッドに制限するコンストラクトを識別します。 ディレクティブの構文は次のとおり `critical` です。

```cpp
#pragma omp critical [(name)]  new-linestructured-block
```

オプションの *名前* は、重要なリージョンを識別するために使用できます。 クリティカル領域を識別するために使用される識別子は、外部リンケージを持ち、ラベル、タグ、メンバー、および通常の識別子によって使用される名前空間とは別の名前空間にあります。

スレッドは、他のスレッドが同じ名前で (プログラム内の任意の場所で) クリティカルな領域を実行しないようになるまで、クリティカルなリージョンの開始時に待機します。 名前のないすべて `critical` のディレクティブは、指定されていない名前にマップされます。

### <a name="263-barrier-directive"></a>2.6.3 バリアディレクティブ

ディレクティブは、 `barrier` チーム内のすべてのスレッドを同期します。 検出されると、チーム内の各スレッドは、他のすべてのスレッドがこの時点に到達するまで待機します。 ディレクティブの構文は次のとおり `barrier` です。

```cpp
#pragma omp barrier new-line
```

チーム内のすべてのスレッドがバリアを検出すると、チーム内の各スレッドは、バリアディレクティブの後にあるステートメントの実行を並列で開始します。 ディレクティブには `barrier` 構文の一部として C 言語のステートメントが含まれていないため、プログラム内での配置にはいくつかの制限があります。 正式な文法の詳細については、「 [付録 C](c-openmp-c-and-cpp-grammar.md)」を参照してください。次の例では、これらの制限について説明します。

```cpp
/* ERROR - The barrier directive cannot be the immediate
*          substatement of an if statement
*/
if (x!=0)
   #pragma omp barrier
...

/* OK - The barrier directive is enclosed in a
*      compound statement.
*/
if (x!=0) {
   #pragma omp barrier
}
```

### <a name="264-atomic-construct"></a>2.6.4 atomic コンストラクト

ディレクティブを使うと、 `atomic` 複数の同時書き込みスレッドの可能性に応じて、特定のメモリ位置がアトミックに更新されるようになります。 ディレクティブの構文は次のとおり `atomic` です。

```cpp
#pragma omp atomic new-lineexpression-stmt
```

式ステートメントには、次のいずれかの形式を指定する必要があります。

- *x ビン op* `=`*expr*
- *x*`++`
- `++` *x*
- *x*`--`
- `--` *x*

上記の式では、次のようになります。

- *x* は、スカラー型の左辺値式です。

- *expr* はスカラー型の式であり、 *x*によって指定されたオブジェクトを参照しません。

- *binop* はオーバーロードされた演算子ではなく、、、、、、、、 `+` `*` `-` `/` `&` `^` `|` `<<` 、または `>>` のいずれかです。

実装では、すべてのディレクティブを同じ一意の名前を持つディレクティブに置き換えるかどうかが実装定義されて `atomic` いますが、ディレクティブを使用すると、 `critical` より適切な最適化を行うことが*name* `atomic` できます。 多くの場合、オーバーヘッドが最も少ないアトミック更新を実行できるハードウェアの指示があります。

*X*によって指定されたオブジェクトの読み込みとストアのみがアトミックです。*expr*の評価はアトミックではありません。 競合状態を回避するために、競合状態が発生しないことがわかっているものを除き、同じ場所にあるすべての更新プログラムをディレクティブで保護する必要があり `atomic` ます。

`atomic`ディレクティブには次の制限があります。

- プログラム全体のストレージ位置 x へのすべてのアトミック参照には、互換性のある型が必要です。

#### <a name="examples"></a>例

```cpp
extern float a[], *p = a, b;
/* Protect against races among multiple updates. */
#pragma omp atomic
a[index[i]] += b;
/* Protect against races with updates through a. */
#pragma omp atomic
p[i] -= 1.0f;

extern union {int n; float x;} u;
/* ERROR - References through incompatible types. */
#pragma omp atomic
u.n++;
#pragma omp atomic
u.x -= 1.0f;
```

### <a name="265-flush-directive"></a>2.6.5 flush ディレクティブ

ディレクティブは、 `flush` 明示的か暗黙的かにかかわらず、"スレッド間" シーケンスポイントを指定します。これにより、チーム内のすべてのスレッドが、メモリ内の特定のオブジェクト (下で指定) の一貫したビューを持つようになります。 これは、これらのオブジェクトを参照する式の前の評価が完了し、後続の評価がまだ開始されていないことを意味します。 たとえば、コンパイラは、レジスタからメモリにオブジェクトの値を復元する必要があります。また、ハードウェアによっては、メモリに書き込みバッファーをフラッシュし、メモリからオブジェクトの値を再読み込みすることが必要になる場合があります。

ディレクティブの構文は次のとおり `flush` です。

```cpp
#pragma omp flush [(variable-list)]  new-line
```

同期を必要とするオブジェクトがすべて変数によって指定されている場合は、これらの変数を省略可能 *な変数リスト*で指定できます。 ポインターが *変数リスト*に存在する場合は、ポインターが参照するオブジェクトではなく、ポインター自体がフラッシュされます。

`flush`*変数リスト*のないディレクティブは、自動ストレージ存続期間が指定されているアクセスできないオブジェクトを除くすべての共有オブジェクトを同期します。 (これには、変数リストを使用するよりもオーバーヘッドが多くなる可能性があり `flush` ます)。 *variable-list*`flush`*変数リスト*のないディレクティブは、次のディレクティブに対して暗黙的に指定されます。

- `barrier`
- [開始] と [終了] `critical`
- [開始] と [終了] `ordered`
- [開始] と [終了] `parallel`
- 終了時 `for`
- 終了時 `sections`
- 終了時 `single`
- [開始] と [終了] `parallel for`
- [開始] と [終了] `parallel sections`

句が存在する場合、ディレクティブは暗黙的に指定されません `nowait` 。 `flush`ディレクティブは、次のいずれに対しても暗黙的に指定されていないことに注意してください。

- 入力時 `for`
- 入力時または終了時 `master`
- 入力時 `sections`
- 入力時 `single`

Volatile で修飾された型のオブジェクトの値にアクセスする参照は、 `flush` 前のシーケンスポイントでそのオブジェクトを指定するディレクティブがあったかのように動作します。 Volatile で修飾された型のオブジェクトの値を変更する参照は、その `flush` オブジェクトを後続のシーケンスポイントで指定するディレクティブがあったかのように動作します。

ディレクティブには `flush` 構文の一部として C 言語のステートメントが含まれていないため、プログラム内での配置にはいくつかの制限があります。 正式な文法の詳細については、「 [付録 C](c-openmp-c-and-cpp-grammar.md)」を参照してください。次の例では、これらの制限について説明します。

```cpp
/* ERROR - The flush directive cannot be the immediate
*          substatement of an if statement.
*/
if (x!=0)
   #pragma omp flush (x)
...

/* OK - The flush directive is enclosed in a
*      compound statement
*/
if (x!=0) {
   #pragma omp flush (x)
}
```

`flush`ディレクティブには次の制限があります。

- ディレクティブで指定された変数は、 `flush` 参照型を持つことはできません。

### <a name="266-ordered-construct"></a>2.6.6 ordered ordered コンストラクト

ディレクティブの後に続く構造化ブロック `ordered` は、順次ループでイテレーションが実行される順序で実行されます。 ディレクティブの構文は次のとおり `ordered` です。

```cpp
#pragma omp ordered new-linestructured-block
```

`ordered`ディレクティブは、またはコンストラクトの動的な範囲内である必要があり `for` `parallel for` ます。 `for` `parallel for` コンストラクトをバインドするディレクティブまたはディレクティブには、 `ordered` `ordered` [「2.4.1」](#241-for-construct)で説明されているように句を指定する必要があります。 `for`句を使用してまたはコンストラクトを実行する `parallel for` `ordered` 場合、 `ordered` コンストラクトは、ループの順次実行で実行される順序で厳密に実行されます。

`ordered`ディレクティブには次の制限があります。

- コンストラクトを使用したループの反復処理では、 `for` 同じ順序付きディレクティブを複数回実行することはできません。また、複数のディレクティブを実行することはできません `ordered` 。

## <a name="27-data-environment"></a>2.7 データ環境

このセクションでは、次のように、並列領域の実行中にデータ環境を制御するためのディレクティブといくつかの句について説明します。

- ファイルスコープ、名前空間スコープ、または静的ブロックスコープ変数をスレッドに対してローカルにするために、 [threadprivate](#271-threadprivate-directive) ディレクティブが用意されています。

- 並列または作業共有コンストラクトの存続期間中に変数の共有属性を制御するためにディレクティブで指定できる句については、 [「2.7.2」を参照](#272-data-sharing-attribute-clauses)してください。

### <a name="271-threadprivate-directive"></a>2.7.1 threadprivate ディレクティブ

`threadprivate`ディレクティブを使用すると、*変数リスト*に指定されている名前付きのファイルスコープ、名前空間スコープ、または静的ブロックスコープ変数がスレッドに対してプライベートになります。 *変数リスト* は、不完全な型を持たない変数のコンマ区切りのリストです。 ディレクティブの構文は次のとおり `threadprivate` です。

```cpp
#pragma omp threadprivate(variable-list) new-line
```

変数の各コピー `threadprivate` は、プログラム内の指定されていない時点で、そのコピーへの最初の参照の前に1回、通常の方法 (つまり、マスターコピーがプログラムの直列実行で初期化されるため) に初期化されます。 オブジェクトが変数の明示的な初期化子で参照されていて、 `threadprivate` 変数のコピーへの最初の参照の前にオブジェクトの値が変更されている場合、動作は指定されていないことに注意してください。

プライベート変数と同様に、スレッドは、オブジェクトの別のスレッドコピーを参照することはできません `threadprivate` 。 プログラムのシリアル領域とマスター領域の間に、参照は、オブジェクトのマスタースレッドのコピーに対して行われます。

最初の並列領域が実行された後、オブジェクト内のデータ `threadprivate` は、動的スレッド機構が無効になっていて、すべての並列領域でスレッド数が変更されていない場合にのみ保持されることが保証されます。

ディレクティブの制限 `threadprivate` は次のとおりです。

- `threadprivate`ファイルスコープ変数または名前空間スコープ変数のディレクティブは、定義または宣言の外側に記述する必要があります。また、リスト内のいずれかの変数へのすべての参照の前に、構文的に指定する必要があります。

- ファイルまたは名前空間スコープのディレクティブの *変数リスト* に含まれる各変数 `threadprivate` は、ファイルまたは名前空間スコープのディレクティブの前に構文的に指定された変数宣言を参照する必要があります。

- `threadprivate`静的ブロックスコープ変数のディレクティブは、入れ子になったスコープではなく、変数のスコープ内に出現する必要があります。 ディレクティブは、そのリスト内の任意の変数へのすべての参照の前に構文的に付ける必要があります。

- ブロックスコープ内のディレクティブの *変数リスト* 内の各変数は、 `threadprivate` ディレクティブの前に構文的に指定された同じスコープ内の変数宣言を参照する必要があります。 変数宣言では、static ストレージクラス指定子を使用する必要があります。

- 変数が1つの翻訳単位のディレクティブで指定されている場合は、その変数が宣言され `threadprivate` `threadprivate` ているすべての翻訳単位のディレクティブで指定する必要があります。

- `threadprivate`変数は `copyin` 、、、 `copyprivate` `schedule` 、 `num_threads` 、または `if` 句以外の句では指定できません。

- 変数のアドレスが `threadprivate` アドレス定数ではありません。

- `threadprivate`変数に不完全な型または参照型を指定することはできません。

- `threadprivate`非 POD クラス型の変数は、明示的な初期化子を使用して宣言されている場合、アクセス可能で明確なコピーコンストラクターを持つ必要があります。

次の例では、初期化子に表示される変数を変更すると、特定できない動作が発生する可能性があります。また、補助オブジェクトとコピーコンストラクターを使用して、この問題を回避する方法についても説明します。

```cpp
int x = 1;
T a(x);
const T b_aux(x); /* Capture value of x = 1 */
T b(b_aux);
#pragma omp threadprivate(a, b)

void f(int n) {
   x++;
   #pragma omp parallel for
   /* In each thread:
   * Object a is constructed from x (with value 1 or 2?)
   * Object b is copy-constructed from b_aux
   */
   for (int i=0; i<n; i++) {
      g(a, b); /* Value of a is unspecified. */
   }
}
```

#### <a name="cross-references"></a>相互参照

- [動的スレッド](3-run-time-library-functions.md#317-omp_set_dynamic-function)
- [OMP_DYNAMIC](4-environment-variables.md#43-omp_dynamic) 環境変数

### <a name="272-data-sharing-attribute-clauses"></a>2.7.2 のデータ共有属性句

いくつかのディレクティブでは、領域の存続期間中、ユーザーが変数の共有属性を制御できるようにする句が受け入れられます。 属性句の共有は、句が出現するディレクティブの構文範囲内の変数にのみ適用されます。 すべてのディレクティブで、次の句のすべてが許可されているわけではありません。 特定のディレクティブで有効な句の一覧については、ディレクティブを参照してください。

並列または作業共有のコンストラクトが検出されたときに変数が表示され、共有属性の句またはディレクティブで変数が指定されていない場合、 `threadprivate` 変数は共有されます。 並列領域の動的な範囲内で宣言された静的変数は共有されます。 ヒープに割り当てられたメモリ (たとえば、 `malloc()` c または c++ ではを、c++ では演算子を使用し **`new`** ます) は共有されます。 (ただし、このメモリへのポインターは、プライベートまたは共有にすることができます)。並列領域の動的な範囲内で宣言された自動ストレージ存続期間を持つ変数はプライベートです。

ほとんどの句では、 *変数リスト* の引数を受け取ります。これは、表示される変数のコンマ区切りのリストです。 データ共有属性句で参照されている変数にテンプレートから派生した型が含まれていて、その変数への参照がプログラム内に存在しない場合、動作は未定義になります。

ディレクティブ句内に出現するすべての変数が表示されている必要があります。 句は必要に応じて繰り返すことができますが、複数の句で変数を指定することはできません。ただし、変数はと句の両方で指定でき `firstprivate` `lastprivate` ます。

次のセクションでは、データ共有属性句について説明します。

- [private](#2721-private)
- [firstprivate](#2722-firstprivate)
- [lastprivate](#2723-lastprivate)
- [共用](#2724-shared)
- [default](#2725-default)
- [reduction](#2726-reduction)
- [copyin](#2727-copyin)
- [copyprivate](#2728-copyprivate)

#### <a name="2721-private"></a>2.7.2.1 private

句は、 `private` 変数リストの変数を、チーム内の各スレッドに対してプライベートに宣言します。 句の構文は次のとおり `private` です。

```cpp
private(variable-list)
```

句で指定された変数の動作 `private` は次のとおりです。 自動ストレージ存続期間を持つ新しいオブジェクトがコンストラクトに割り当てられます。 新しいオブジェクトのサイズとアラインメントは、変数の型によって決まります。 この割り当ては、チーム内のスレッドごとに1回実行され、必要に応じてクラスオブジェクトに対して既定のコンストラクターが呼び出されます。それ以外の場合、初期値は不確定になります。  変数によって参照される元のオブジェクトは、コンストラクターへのエントリ時に不定の値を持ち、構造体の動的な範囲内では変更できません。また、コンストラクトから終了すると、不確定の値が保持されます。

ディレクティブコンストラクトの構文の範囲では、変数はスレッドによって割り当てられた新しいプライベートオブジェクトを参照します。

句の制限 `private` は次のとおりです。

- 句で指定されたクラス型の変数には、 `private` アクセス可能で明確な既定のコンストラクターが必要です。

- 句で指定された変数には、 `private` **`const`** メンバーを持つクラス型が含まれていない限り、で修飾された型を持つことはできません `mutable` 。

- 句で指定された変数は、 `private` 不完全な型または参照型を含むことはできません。

- ディレクティブの句に使用されている変数は、 `reduction` `parallel` `private` parallel コンストラクトにバインドされているワークシェアリングディレクティブの句では指定できません。

#### <a name="2722-firstprivate"></a>2.7.2.2 firstprivate

句は、 `firstprivate` 句によって提供される機能のスーパーセットを提供し `private` ます。 句の構文は次のとおり `firstprivate` です。

```cpp
firstprivate(variable-list)
```

「2.7.2.1」で説明されているように、*変数リスト*で指定された変数には句のセマンティクスがあり `private` ます。 [section 2.7.2.1](#2721-private) 初期化または構築は、スレッドごとに1回実行された場合と同様に発生します。これは、スレッドがコンストラクトを実行する前に行われます。 `firstprivate`Parallel コンストラクトの句の場合、新しいプライベートオブジェクトの初期値は、それを検出したスレッドの並列コンストラクトの直前に存在する元のオブジェクトの値になります。 `firstprivate`ワークシェアリングコンストラクトの句の場合、作業共有コンストラクトを実行する各スレッドの新しいプライベートオブジェクトの初期値は、同じスレッドが作業共有コンストラクトに遭遇した時点より前に存在していた元のオブジェクトの値です。 さらに、C++ オブジェクトの場合、各スレッドの新しいプライベートオブジェクトは、元のオブジェクトから構築されたコピーです。

句の制限 `firstprivate` は次のとおりです。

- 句で指定された変数は、 `firstprivate` 不完全な型または参照型を含むことはできません。

- として指定されたクラス型の変数は、 `firstprivate` アクセス可能で明確なコピーコンストラクターを持つ必要があります。

- 並列領域内でプライベートであるか、またはディレクティブの句に記述されている変数は、 `reduction` `parallel` `firstprivate` parallel コンストラクトにバインドされるワークシェアリングディレクティブの句で指定することはできません。

#### <a name="2723-lastprivate"></a>2.7.2.3 lastprivate

句は、 `lastprivate` 句によって提供される機能のスーパーセットを提供し `private` ます。 句の構文は次のとおり `lastprivate` です。

```cpp
lastprivate(variable-list)
```

*変数リスト*で指定された変数には、句のセマンティクスがあり `private` ます。 `lastprivate`作業共有コンストラクトを識別するディレクティブに句が指定されている場合、 `lastprivate` 関連付けられているループの最後の反復処理の各変数の値、または構文の最後のセクションディレクティブが、変数の元のオブジェクトに代入されます。 またはの最後の反復で値が割り当てられていない変数、または `for` `parallel for` ディレクティブの構文の最後のセクションによって `sections` `parallel sections` 、コンストラクターの後に不確定な値があります。 未割り当てサブオブジェクトにも、コンストラクトの後に不定の値があります。

句の制限 `lastprivate` は次のとおりです。

- 適用に関するすべての制限 `private` 。

- として指定されたクラス型の変数は、 `lastprivate` アクセス可能で明確なコピー代入演算子を持っている必要があります。

- 並列領域内でプライベートであるか、またはディレクティブの句に記述されている変数は、 `reduction` `parallel` `lastprivate` parallel コンストラクトにバインドされるワークシェアリングディレクティブの句で指定することはできません。

#### <a name="2724-shared"></a>2.7.2.4 shared

この句は、チーム内のすべてのスレッドの中で *変数リスト* に表示される変数を共有します。 チーム内のすべてのスレッドは、変数の同じストレージ領域にアクセス `shared` します。

句の構文は次のとおり `shared` です。

```cpp
shared(variable-list)
```

#### <a name="2725-default"></a>2.7.2.5 default

`default`句を使用すると、ユーザーは変数のデータ共有属性に影響を与えることができます。 句の構文は次のとおり `default` です。

```cpp
default(shared | none)
```

を指定 `default(shared)` すると、 `shared` またはが修飾されている場合を除き、句に現在表示されている変数を明示的に一覧表示することと同じです `threadprivate` **`const`** 。 明示的な句が存在し `default` ない場合、既定の動作は、が指定されている場合と同じです `default(shared)` 。

を指定する場合は `default(none)` 、parallel コンストラクトの字句範囲内の変数への参照ごとに、次のいずれか1つ以上が true である必要があります。

- 変数は、参照を含む構造体のデータ共有属性句に明示的にリストされます。

- 変数は、parallel コンストラクト内で宣言されます。

- 変数は `threadprivate` です。

- 変数の型は、によって **`const`** 修飾されます。

- 変数は、ディレクティブまたはディレクティブの直後にあるループのループコントロール変数で、 `for` `for` `parallel for` 変数参照がループ内に表示されます。

囲まれた `firstprivate` ディレクティブの、、または句で変数を指定すると、それを `lastprivate` `reduction` 囲むコンテキスト内の変数への暗黙的な参照が発生します。 このような暗黙的な参照についても、上記の要件が適用されます。

`default`ディレクティブに指定できる句は1つだけ `parallel` です。

変数の既定のデータ共有属性は `private` 、 `firstprivate` `lastprivate` `reduction` `shared` 次の例に示すように、、、、、およびの各句を使用してオーバーライドできます。

```cpp
#pragma  omp  parallel  for  default(shared)  firstprivate(i)\
   private(x)  private(r)  lastprivate(i)
```

#### <a name="2726-reduction"></a>2.7.2.6 reduction

この句は、 *変数リスト*に表示されるスカラー変数を、operator *op*と共に減らします。 句の構文は次のとおり `reduction` です。

`reduction(`*op* `:`*変数リスト*`)`

通常、リダクションは、次のいずれかの形式のステートメントに対して指定されます。

- *x* `=` *x* *op* *expr*
- *x*ビン *op* `=` *expr*
- *x* `=` *expr* *op* *x*  (減算を除く)
- *x*`++`
- `++` *x*
- *x*`--`
- `--` *x*

各値の説明:

*x*<br/>
リストで指定されているリダクション変数の1つ。

*変数リスト*<br/>
スカラーリダクション変数のコンマ区切りのリスト。

*with*<br/>
*X*を参照しないスカラー型の式。

*ファンド*<br/>
オーバーロードされた演算子ではありませんが、、、、、、 `+` `*` `-` `&` `^` `|` `&&` 、または `||` のいずれかです。

*ビン op*<br/>
オーバーロードされた演算子ではありませんが、、、、、またはのいずれか `+` `*` `-` `&` `^` `|` です。

句の例を次に示し `reduction` ます。

```cpp
#pragma omp parallel for reduction(+: a, y) reduction(||: am)
for (i=0; i<n; i++) {
   a += b[i];
   y = sum(y, c[i]);
   am = am || b[i] == c[i];
}
```

この例に示すように、演算子は関数呼び出し内で非表示にすることができます。 句で指定された演算子がリダクション操作と一致することをユーザーに注意する必要があり `reduction` ます。

この例では演算子の右オペランドに `||` 副作用はありませんが、許可されていますが、注意して使用する必要があります。 このコンテキストでは、ループの順次実行中に発生しないことが保証されている副作用が並列実行中に発生する可能性があります。 この違いは、イテレーションの実行順序が不確定であることが原因で発生する可能性があります。

演算子は、減少のためにコンパイラによって使用されるプライベート変数の初期値を決定し、終了演算子を決定するために使用されます。 演算子を明示的に指定すると、リダクションステートメントをコンストラクトの構文の範囲外にすることができます。 ディレクティブには任意の数の `reduction` 句を指定できますが、変数はそのディレクティブに対して最大で1つの句に記述でき `reduction` ます。

*変数リスト*内の各変数のプライベートコピーが作成されます。これは、句が使用されたかのように、スレッドごとに1つずつ作成され `private` ます。 プライベートコピーは、演算子に従って初期化されます (次の表を参照)。

指定され `reduction` た演算子を使用して、元の値と各プライベートコピーの最終的な値を結合した結果を反映するために、元のオブジェクトが更新されます。 リダクション演算子はすべて連想 (減算を除く) であり、コンパイラは最終的な値の計算を自由に再関連付けできます。 (減算リダクションの部分的な結果は、最終的な値を形成するために追加されます)。

最初のスレッドが外側の句に達したときに、元のオブジェクトの値が不確定になり、リダクションの計算が完了するまでそのままになります。  通常、計算はコンストラクトの最後に完了します。ただし、を `reduction` 適用するコンストラクトで句が使用されている場合、 `nowait` すべてのスレッドが句を完了するようにバリア同期が実行されるまで、元のオブジェクトの値は不確定のままに `reduction` なります。

次の表に、有効な演算子と、その正規の初期化値の一覧を示します。 実際の初期化値は、リダクション変数のデータ型と一致します。

|演算子|初期化|
|--------------|--------------------|
|`+`|0|
|`*`|1|
|`-`|0|
|`&`|~0|
|`|`|0|
|`^`|0|
|`&&`|1|
|`||`|0|

句の制限 `reduction` は次のとおりです。

- 句内の変数の型は、 `reduction` ポインター型と参照型を使用できないことを除いて、リダクション演算子に対して有効である必要があります。

- 句で指定された変数を修飾することはでき `reduction` ません **`const`** 。

- 並列領域内でプライベートであるか、またはディレクティブの句に記述されている変数は、 `reduction` `parallel` `reduction` parallel コンストラクトにバインドされるワークシェアリングディレクティブの句で指定することはできません。

   ```cpp
   #pragma omp parallel private(y)
   { /* ERROR - private variable y cannot be specified
                in a reduction clause */
      #pragma omp for reduction(+: y)
      for (i=0; i<n; i++)
         y += b[i];
   }

   /* ERROR - variable x cannot be specified in both
              a shared and a reduction clause */
   #pragma omp parallel for shared(x) reduction(+: x)
   ```

#### <a name="2727-copyin"></a>2.7.2.7 copyin

句は、 `copyin` `threadprivate` 並列領域を実行するチーム内の各スレッドの変数に同じ値を割り当てるメカニズムを提供します。 句で指定された変数ごとに、 `copyin` チームのマスタースレッド内の変数の値が、並行領域の先頭のスレッドプライベートコピーに割り当てられているかのようにコピーされます。 句の構文は次のとおり `copyin` です。

```cpp

copyin(
variable-list
)
```

句の制限 `copyin` は次のとおりです。

- 句で指定された変数には、 `copyin` アクセス可能で明確なコピー代入演算子が必要です。

- 句で指定された変数は、変数である `copyin` 必要があり `threadprivate` ます。

#### <a name="2728-copyprivate"></a>2.7.2.8 copyprivate

句は、 `copyprivate` プライベート変数を使用して、チームのあるメンバーから他のメンバーに値をブロードキャストするメカニズムを提供します。 このような共有変数を指定する場合は、共有変数を値として使用するのが難しい場合があります (たとえば、各レベルで異なる変数を必要とする再帰の場合など)。 句は、 `copyprivate` ディレクティブでのみ使用でき `single` ます。

句の構文は次のとおり `copyprivate` です。

```cpp

copyprivate(
variable-list
)
```

`copyprivate`変数リスト内の変数に対する句の効果は、構成要素に関連付けられている構造化ブロックの実行後、 `single` およびチーム内のいずれかのスレッドがコンストラクトの最後にバリアを離れた前に発生します。 次に、チーム内の他のすべてのスレッドで、 *変数リスト*の各変数に対して、その変数が (代入によって) 定義されて、その構成要素の構造化ブロックを実行したスレッド内の対応する変数の値が定義されます。

句の制限 `copyprivate` は次のとおりです。

- 句で指定された変数は、 `copyprivate` `private` `firstprivate` 同じディレクティブの or 句には記述できません `single` 。

- 句を `single` 持つディレクティブ `copyprivate` が並列領域の動的な範囲内で検出された場合、句で指定されたすべての変数は、それを `copyprivate` 囲むコンテキスト内でプライベートである必要があります。

- 句で指定された変数には、 `copyprivate` アクセス可能な明確なコピー代入演算子が必要です。

## <a name="28-directive-binding"></a>2.8 ディレクティブバインド

ディレクティブの動的バインドは、次の規則に従う必要があります。

- `for`、、 `sections` `single` 、、の各ディレクティブは、 `master` `barrier` `parallel` `if` そのディレクティブに存在する可能性がある句の値に関係なく、動的に囲んでいる (存在する場合) にバインドされます。 並列領域が現在実行されていない場合は、マスタースレッドだけで構成されるチームによって、ディレクティブが実行されます。

- `ordered`ディレクティブは、動的に囲まれたにバインドされ `for` ます。

- ディレクティブは、 `atomic` `atomic` 現在のチームだけでなく、すべてのスレッドのディレクティブに対して排他アクセスを適用します。

- ディレクティブは、 `critical` `critical` 現在のチームだけでなく、すべてのスレッドのディレクティブに対して排他アクセスを適用します。

- ディレクティブは、動的に外側に最も近いもの以外のディレクティブにバインドすることはできません `parallel` 。

## <a name="29-directive-nesting"></a>2.9 ディレクティブの入れ子

ディレクティブの動的な入れ子は、次の規則に従う必要があります。

- `parallel` `parallel` 入れ子になった並列処理が有効になっていない限り、別の内部にあるディレクティブは、現在のスレッドのみで構成される新しいチームを論理的に確立します。

- `for``sections` `single` 同じにバインドされている、、およびディレクティブ `parallel` は、入れ子にすることはできません。

- `critical` 同じ名前のディレクティブを相互に入れ子にすることはできません。 この制限は、デッドロックを防ぐためには不十分であることに注意してください。

- `for``sections` `single` `critical` `ordered` `master` ディレクティブが領域と同じにバインドされている場合、、、およびの各領域の動的な範囲で、、およびの各ディレクティブを使用することはできません `parallel` 。

- `barrier` ディレクティブ `for` `ordered` `sections` `single` `master` `critical` が領域と同じにバインドされている場合、、、、、、およびの各領域の動的な範囲 `parallel` では、ディレクティブを使用できません。

- `master` ディレクティブ `for` `sections` `single` が `master` `parallel` ワークシェアリングディレクティブと同じにバインドされている場合、ディレクティブは、、、およびディレクティブの動的な範囲内では許可されません。

- `ordered` ディレクティブ `critical` が領域と同じにバインドされている場合は、領域の動的範囲でディレクティブを使用することはできません `parallel` 。

- 並列領域内で動的に実行された場合に許可されるディレクティブは、並列領域の外側で実行される場合にも許可されます。 ユーザー指定の並列領域の外側で動的に実行される場合、このディレクティブは、マスタースレッドだけで構成されるチームによって実行されます。
