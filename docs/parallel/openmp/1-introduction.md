---
description: 詳細については、次を参照してください。 1. はじめに
title: 1. はじめに
ms.date: 01/16/2019
ms.assetid: c42e72bc-0e31-4b1c-b670-cd82673c0c5a
ms.openlocfilehash: d9b7374668b8a5cfa4b6ab6771362dac8bdfe14c
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/11/2020
ms.locfileid: "97149722"
---
# <a name="1-introduction"></a>1.はじめに

このドキュメントでは、C および C++ プログラムで共有メモリの並列処理を指定するために使用できる、コンパイラディレクティブ、ライブラリ関数、および環境変数のコレクションを指定します。 このドキュメントで説明する機能は、総称して *OpenMP C/c + + アプリケーションプログラムインターフェイス (API)* と呼ばれています。 この仕様の目的は、さまざまなベンダーの共有メモリアーキテクチャ間でプログラムを移植できるようにする並列プログラミングのモデルを提供することです。 多くのベンダーのコンパイラは、OpenMP C/c + + API をサポートしています。 Openmp *Fortran アプリケーションプログラムインターフェイス* など、openmp の詳細については、次の web サイトを参照してください。

[https://www.openmp.org](https://www.openmp.org)

このドキュメントで定義されているディレクティブ、ライブラリ関数、および環境変数を使用すると、移植性を確保しながら並列プログラムを作成および管理できます。 ディレクティブは、1つのプログラムの複数のデータ (SPMD) コンストラクト、作業共有コンストラクト、および同期コンストラクトを使用して、C および C++ のシーケンシャルプログラミングモデルを拡張します。 また、データの共有と民営化もサポートしています。 OpenMP C および C++ API をサポートするコンパイラには、すべての OpenMP コンパイラディレクティブをアクティブ化して解釈できるようにするためのコマンドラインオプションがコンパイラに組み込まれています。

## <a name="11-scope"></a>1.1 スコープ

この仕様では、ユーザー向けの並列処理についてのみ説明します。コンパイラおよびランタイムシステムがプログラムを並列実行するために実行するアクションを明示的に定義します。 OpenMP C および C++ の実装では、依存関係、競合、デッドロック、競合状態、またはプログラムの実行に誤りが生じるその他の問題を確認する必要はありません。 OpenMP C および C++ API コンストラクトを使用するアプリケーションが正しく実行されることを確認する必要があります。 コンパイラによって生成された自動並列化と、このような並列処理を支援するディレクティブは、このドキュメントでは説明されていません。

## <a name="12-definition-of-terms"></a>1.2 用語の定義

次の用語は、このドキュメントで使用されます。

- barrier

  チーム内のすべてのスレッドが接続する必要がある同期ポイント。  各スレッドは、この時点でチーム内のすべてのスレッドが到着するまで待機します。 ディレクティブと実装によって作成された暗黙的なバリアによって明示的なバリアが識別されます。

- construct

  コンストラクトはステートメントです。 これはディレクティブで構成され、その後に構造化ブロックが続きます。 一部のディレクティブはコンストラクトの一部ではありません。 ([付録 C](c-openmp-c-and-cpp-grammar.md)の *openmp ディレクティブ* を参照してください)。

- ディレクティブ

  C または C++ の `#pragma` 後に `omp` 識別子、その他のテキスト、および改行が続きます。 ディレクティブは、プログラムの動作を指定します。

- 動的な範囲

  *構文の範囲* 内のすべてのステートメントと、構文の範囲内でステートメントを実行した結果として実行される関数内のすべてのステートメント。 動的エクステントは、 *リージョン* とも呼ばれます。

- 構文の範囲

  *構造化ブロック* 内で構文的に保持されているステートメント。

- マスタースレッド

  *並行領域* が入力されたときにチームを作成するスレッド。

- 並列領域

  OpenMP parallel コンストラクトにバインドされ、多くのスレッドによって実行されるステートメント。

- private

  プライベート変数は、参照を行うスレッドに固有のストレージのブロックに名前を変更します。 変数がプライベートであることを指定する方法はいくつかあります。並列領域内の定義、ディレクティブ、、、、 `threadprivate` `private` または `firstprivate` `lastprivate` `reduction` 句、また **`for`** **`for`** はディレクティブの直後のループでループコントロール変数として変数を使用 `for` `parallel for` する方法です。

- region

  動的な範囲。

- シリアル領域

  *並列領域* の動的範囲外の *マスタースレッド* によってのみ実行されるステートメント。

- serialize

  次のものを使用して並列コンストラクトを実行するには:

  - 1つのスレッド (並列コンストラクトのマスタースレッド) で構成されるスレッドのチーム

  - 構造化ブロック内のステートメントの順次実行順序 (ブロックが並列コンストラクトの一部ではない場合と同じ順序)、および

  - によって返される値には影響しません `omp_in_parallel()` (入れ子になった並列コンストラクトの効果とは異なります)。

- shared

  共有変数は、1つのストレージブロックに名前を付いています。 この変数にアクセスするチーム内のすべてのスレッドは、この単一のストレージブロックにもアクセスします。

- 構造化ブロック

  構造化ブロックは、1つのエントリと1つの終了を持つステートメント (単一または複合) です。 ステートメントにジャンプしたり、ステートメントから移動したりすると、そのステートメントは構造化ブロックになります。 (このルールに `longjmp` は、(3C) またはの使用 `throw` 。ただし、の呼び出し `exit` は許可されます。実行が常に開始時に開始 `{` し、常に終了時に終了する場合 `}` 、複合ステートメントは構造化ブロックです。 式ステートメント、選択ステートメント、反復ステートメント、または **`try`** ブロックは、構造化されたブロックであり、それをに囲んで取得した対応する複合ステートメントが `{` `}` 構造化ブロックです。 ジャンプステートメント、ラベル付きステートメント、または宣言ステートメントは構造化ブロックではありません。

- チーム

  1つ以上のスレッドがコンストラクトの実行に協調しています。

- スレッド (thread)

  制御のシリアルフロー、一連のプライベート変数、共有変数へのアクセスを持つ実行エンティティ。

- 可変

  名前空間名によって修飾され、オブジェクトに名前を持つ識別子。

## <a name="13-execution-model"></a>1.3 実行モデル

OpenMP は、並列実行のフォーク結合モデルを使用します。 このフォーク結合モデルはさまざまな問題を解決するのに役立ちますが、大規模な配列ベースのアプリケーションに合わせて調整されています。 OpenMP は、並列プログラム (多くの実行スレッドと完全な OpenMP サポートライブラリ) の両方として正常に実行されるプログラムをサポートすることを目的としています。 また、シーケンシャルプログラム (ディレクティブは無視され、単純な OpenMP スタブライブラリ) として正しく実行されるプログラムにも対応しています。 ただし、連続して実行されたときに正しく動作しないプログラムを開発することは可能であり、許可される可能性があります。 さらに、並列処理の次数が異なると、数値演算の関連付けの変更によって異なる数値が生成される可能性があります。 たとえば、直列加算リダクションでは、並列リダクションよりも加算の関連付けのパターンが異なる場合があります。 これらの異なる関連付けによって、浮動小数点加算の結果が変わる場合があります。

OpenMP C/c + + API で記述されたプログラムは、 *マスタースレッド* と呼ばれる単一の実行スレッドとして実行を開始します。 マスタースレッドは、最初の parallel コンストラクトが検出されるまでシリアル領域で実行されます。 OpenMP C/c + + API では、 `parallel` ディレクティブは並列コンストラクトを構成します。 並列コンストラクトが検出されると、マスタースレッドによってスレッドのチームが作成され、マスターがチームのマスターになります。 チーム内の各スレッドは、並列領域の動的な範囲内のステートメントを実行します。ただし、作業共有コンストラクトは除きます。 チーム内のすべてのスレッドは、同じ順序で作業共有の構成要素を検出する必要があり、1つまたは複数のスレッドが、関連付けられている構造化ブロック内のステートメントを実行します。 句を指定せずに作業共有コンストラクトの最後にあるバリアは、 `nowait` チーム内のすべてのスレッドで実行されます。

スレッドが共有オブジェクトを変更した場合、そのオブジェクトは独自の実行環境だけでなく、プログラム内の他のスレッドのスレッドにも影響します。 変更は、オブジェクトが volatile として宣言されている場合にのみ、次のシーケンスポイント (基本言語で定義されている) で、別のスレッドの観点から完了することが保証されます。 それ以外の場合、変更は、最初に変更されたスレッドの後に完了することが保証されます。 その他のスレッド (または同時に) は `flush` 、オブジェクトを指定するディレクティブ (暗黙的または明示的) を参照します。 `flush`他の OpenMP ディレクティブによって暗黙的に指定されたディレクティブが副作用の正しい順序を保証していない場合、プログラマは追加の明示的なディレクティブを指定する必要が `flush` あります。

並列構成が完了すると、チーム内のスレッドは暗黙的なバリアで同期され、マスタースレッドだけが実行を継続します。 1つのプログラムでは、任意の数の並列コンストラクトを指定できます。 その結果、プログラムは、実行中に何度もフォークおよび参加する可能性があります。

OpenMP C/c + + API を使用すると、プログラマは、並列コンストラクト内から呼び出された関数でディレクティブを使用できます。 並列コンストラクトの構文の範囲内には出現せず、動的な範囲内に存在する可能性があるディレクティブは、 *孤立* したディレクティブと呼ばれます。 孤立したディレクティブを使用すると、プログラマはプログラムの大部分を並行して実行できます。シーケンシャルプログラムに対する変更は最小限で済みます。 この機能を使用すると、プログラムコールツリーの最上位レベルで並列コンストラクトをコーディングし、ディレクティブを使用して呼び出された関数の実行を制御できます。

同じファイルに書き込む C および C++ 出力関数の非同期呼び出しでは、異なるスレッドによって書き込まれたデータが非決定的な順序で表示される出力が生じる可能性があります。 同様に、同じファイルから読み取る入力関数の非同期呼び出しは、非決定的な順序でデータを読み取ることができます。 I/o を非同期に使用して、各スレッドが異なるファイルにアクセスするようにすると、i/o 関数の直列実行と同じ結果が生成されます。

## <a name="14-compliance"></a>1.4 準拠

この仕様のすべての要素のセマンティクスを認識して保持する場合、OpenMP C/c + + API の実装は、章1、2、3、4、および付録 C に記載 *されて* いるようになります。付録 A、B、D、E、F は情報のためだけに使用され、仕様の一部ではありません。 API のサブセットのみを含む実装は、OpenMP に準拠していません。

OpenMP C および C++ API は、実装によってサポートされる基本言語の拡張機能です。 基本言語がこのドキュメントに記載されている言語構成要素または拡張機能をサポートしていない場合、OpenMP 実装でサポートする必要はありません。

標準 C および C++ ライブラリ関数と組み込み関数 (コンパイラが特定のナレッジを持つ関数) はすべてスレッドセーフである必要があります。 並列領域内の異なるスレッドによるスレッドセーフ関数の非同期使用は、未定義の動作を生成しません。 ただし、この動作は、シリアル領域と同じではない可能性があります。 (乱数生成関数は一例です)。

OpenMP C/c + + API は、特定の動作が実装定義であることを指定し *ます。* このような場合には、準拠する OpenMP 実装が必要です。 実装によって定義される動作の一覧については、「 [付録 E](e-implementation-defined-behaviors-in-openmp-c-cpp.md)」を参照してください。

## <a name="15-normative-references"></a>1.5 non-normative の参照

- ISO/IEC 9899:1999、 *情報技術-プログラミング言語-C*。この OpenMP API 仕様は、ISO/IEC 9899:1999 を C99 と呼んでいます。

- ISO/IEC 9899:1990、 *情報技術-プログラミング言語-C*。この OpenMP API 仕様では、ISO/IEC 9899:1990 が C90 として参照されています。

- ISO/IEC 14882:1998、 *情報技術-プログラミング言語-C++*。 この OpenMP API 仕様では、ISO/IEC 14882:1998 が C++ として参照されています。

この OpenMP API 仕様では C を参照しているので、実装でサポートされている基本言語に対して参照が行われます。

## <a name="16-organization"></a>1.6 階層

- [ランタイム ライブラリの関数](3-run-time-library-functions.md)
- [環境変数](4-environment-variables.md)
- [OpenMP C/C++ の実装で定義されている動作](e-implementation-defined-behaviors-in-openmp-c-cpp.md)
- [OpenMP C/c + + バージョン2.0 の新機能](f-new-features-and-clarifications-in-version-2-0.md)
