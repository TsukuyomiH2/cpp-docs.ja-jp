---
title: CRT ライブラリの機能
description: Microsoft C ランタイムライブラリが含まれているファイルの一覧と、それらに関連付けられているコンパイラオプションとプリプロセッサディレクティブ。
ms.date: 09/03/2020
ms.topic: conceptual
helpviewer_keywords:
- MSVCR71.dll
- libraries [C++], multithreaded
- library files, run-time
- LIBCMT.lib
- LIBCP.lib
- LIBCPMT.lib
- run-time libraries, C
- CRT, release versions
- MSVCP71.dll
- LIBC.lib
- libraries [C++]
- libraries [C++], run-time
- linking [C++], libraries
ms.assetid: a889fd39-807d-48f2-807f-81492612463f
ms.openlocfilehash: 0e0d34c1121f0bf4e2fdfabc521e0365084761eb
ms.sourcegitcommit: 9451db8480992017c46f9d2df23fb17b503bbe74
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/30/2020
ms.locfileid: "91589784"
---
# <a name="crt-library-features"></a>CRT ライブラリの機能

ここでは、C ランタイム ライブラリを構成するさまざまな .lib ファイル、および関連するコンパイラ オプションとプリプロセッサ ディレクティブについて説明します。

## <a name="c-run-time-libraries-crt"></a>C ランタイム ライブラリ (CRT)

C ランタイム ライブラリ (CRT) は、ISO C99 標準ライブラリが組み込まれている C++ 標準ライブラリの一部です。 この CRT を実装する Visual C++ ライブラリは、ネイティブ コードの開発と、ネイティブとマネージドの混在コードの開発をサポートします。 CRT のすべてのバージョンがマルチスレッド開発をサポートします。 ほとんどのライブラリが、ライブラリを直接コードにリンクする静的リンクと、コードで共通 DLL ファイルを使用できるようにする動的リンクの両方をサポートします。

Visual Studio 2015 より、CRT が新しいバイナリにリファクタリングされました。 ユニバーサル CRT (UCRT) には、標準の C99 CRT ライブラリからエクスポートされた関数とグローバルが含まれています。 UCRT は Windows コンポーネントであり、Windows 10 の一部として出荷されます。 UCRT 用のスタティック ライブラリ、DLL インポート ライブラリ、およびヘッダー ファイルが Windows 10 SDK に含まれています。 Visual C++ をインストールすると、Visual Studio セットアップによって、UCRT を使用するために必要な Windows 10 SDK のサブセットがインストールされます。 UCRT は、Visual Studio 2015 以降のバージョンでサポートされている Windows の任意のバージョンで使用できます。 Windows 10 以外のサポートされているバージョンの Windows では、vcredist を使用して再配布することができます。 詳細については、「[Visual C++ ファイルの再配布](../windows/redistributing-visual-cpp-files.md)」を参照してください。

次の表に、UCRT を実装するライブラリの一覧を示します。

| ライブラリ | 関連付けられている DLL | 特性 | オプション | プリプロセッサ ディレクティブ |
|--|--|--|--|--|
| *`libucrt.lib`* | None | UCRT をコードに静的にリンクします。 | **`/MT`** | `_MT` |
| *`libucrtd.lib`* | None | 静的リンク用の UCRT のデバッグ バージョン。 再頒布可能パッケージではありません。 | **`/MTd`** | `_DEBUG`, `_MT` |
| *`ucrt.lib`* | *`ucrtbase.dll`* | UCRT 用の DLL インポート ライブラリ。 | **`/MD`** | `_MT`, `_DLL` |
| *`ucrtd.lib`* | *`ucrtbased.dll`* | UCRT のデバッグ バージョン用の DLL インポート ライブラリ。 再頒布可能パッケージではありません。 | **`/MDd`** | `_DEBUG`, `_MT`, `_DLL` |

vcruntime ライブラリには、例外処理やデバッグ サポートなどの Visual C++ CRT 実装固有のコード、ランタイム チェックと型情報、実装の詳細、および特定の拡張ライブラリ関数が含まれています。 このライブラリは、使用されているコンパイラのバージョンによって異なります。

次の表に、vcruntime ライブラリを実装するライブラリの一覧を示します。

| ライブラリ | 関連付けられている DLL | 特性 | オプション | プリプロセッサ ディレクティブ |
|--|--|--|--|--|
| *`libvcruntime.lib`* | None | コードに静的にリンクされています。 | **`/MT`** | `_MT` |
| *`libvcruntimed.lib`* | None | 静的リンク用のデバッグ バージョン。 再頒布可能パッケージではありません。 | **`/MTd`** | `_MT`, `_DEBUG` |
| *`vcruntime.lib`* | *`vcruntime<version>.dll`* | vcruntime 用の DLL インポート ライブラリ。 | **`/MD`** | `_MT`, `_DLL` |
| *`vcruntimed.lib`* | *`vcruntime<version>d.dll`* | デバッグ vcruntime 用の DLL インポート ライブラリ。 再頒布可能パッケージではありません。 | **`/MDd`** | `_DEBUG`, `_MT`, `_DLL` |

> [!NOTE]
> UCRT リファクタリングが発生すると、同時実行ランタイム関数は *`concrt140.dll`* 、C++ 再頒布可能パッケージに追加されたに移動されました。 この DLL は、C++ の並列コンテナーおよびアルゴリズム (`concurrency::parallel_for` など) に必要となります。 さらに、C++ 標準ライブラリでは、同期プリミティブを支援するために、Windows XP でこの DLL を必要とします。Windows XP には条件変数がないためです。

CRT を初期化するコードは、CRT ライブラリが静的にリンクされているのか、動的にリンクされているのか、ネイティブ コードなのか、マネージド コードなのか、混合コードなのかによって、複数あるライブラリのいずれかに含まれています。 このコードは、CRT のスタートアップ、内部スレッド単位データ初期化、および強制終了を処理します。 使用されているコンパイラのバージョンによって異なります。 このライブラリは、動的にリンクされた UCRT が使用されている場合でも、常に静的にリンクされます。

次の表に、CRT の初期化と強制終了を実装するライブラリの一覧を示します。

| ライブラリ | 特性 | オプション | プリプロセッサ ディレクティブ |
|--|--|--|--|
| *`libcmt.lib`* | ネイティブ CRT スタートアップをコードに静的にリンクします。 | **`/MT`** | `_MT` |
| *`libcmtd.lib`* | ネイティブ CRT スタートアップのデバッグ バージョンを静的にリンクします。 再頒布可能パッケージではありません。 | **`/MTd`** | `_DEBUG`, `_MT` |
| *`msvcrt.lib`* | DLL UCRT および vcruntime で使用するためのネイティブ CRT スタートアップ用のスタティック ライブラリ。 | **`/MD`** | `_MT`, `_DLL` |
| *`msvcrtd.lib`* | DLL UCRT および vcruntime で使用するためのネイティブ CRT スタートアップのデバッグ バージョン用のスタティック ライブラリ。 再頒布可能パッケージではありません。 | **`/MDd`** | `_DEBUG`, `_MT`, `_DLL` |
| *`msvcmrt.lib`* | DLL UCRT および vcruntime で使用するためのネイティブとマネージドの混合 CRT スタートアップ用のスタティック ライブラリ。 | **`/clr`** |  |
| *`msvcmrtd.lib`* | DLL UCRT および vcruntime で使用するためのネイティブとマネージドの混合 CRT スタートアップのデバッグ バージョン用のスタティック ライブラリ。 再頒布可能パッケージではありません。 | **`/clr`** |  |
| *`msvcurt.lib`* | **非推奨** 純粋マネージド CRT 用のスタティック ライブラリ。 | **`/clr:pure`** |  |
| *`msvcurtd.lib`* | **非推奨** 純粋マネージド CRT のデバッグ バージョン用のスタティック ライブラリ。 再頒布可能パッケージではありません。 | **`/clr:pure`** |  |

C ランタイムライブラリを指定するコンパイラオプションを使用せずに、コマンドラインからプログラムをリンクする場合、リンカーは静的にリンクされた CRT ライブラリである、、およびを使用します *`libcmt.lib`* *`libvcruntime.lib`* *`libucrt.lib`* 。

静的にリンクされた CRT を使用すると、暗黙的に、C ランタイム ライブラリによって保存されるステータス情報は CRT のそのインスタンスに対してローカルなものになります。 たとえば、静的にリンクされた CRT を使用する場合、 [`strtok`](../c-runtime-library/reference/strtok-strtok-l-wcstok-wcstok-l-mbstok-mbstok-l.md) パーサーの位置 `strtok` は、 `strtok` 静的な crt の別のインスタンスにリンクされている同じプロセス (ただし、別の DLL または EXE) のコードで使用される状態とは関係がありません。 反対に、動的にリンクされた CRT では、CRT に動的にリンクされるプロセス内のすべてのコードに対して状態が共有されます。 この問題は、セキュリティが強化された新しいバージョンの関数では発生しません。たとえば、 `strtok_s` にはこの問題はありません。

静的な CRT とのリンクによってビルドされた DLL は独自の CRT 状態を持つので、この結果を明確に理解し、期待する場合を除き、DLL 内で CRT に静的にリンクすることは推奨されません。 たとえば、 [`_set_se_translator`](../c-runtime-library/reference/set-se-translator.md) 独自の静的 CRT にリンクされた dll を読み込む実行可能ファイルでを呼び出すと、dll 内のコードによって生成されたハードウェア例外はトランスレーターによって検出されませんが、メインの実行可能ファイルのコードによって生成されるハードウェア例外はキャッチされます。

コンパイラスイッチを使用している場合 **`/clr`** 、コードはスタティックライブラリ msvcmrt.lib にリンクされます。 このスタティック ライブラリは、マネージド コードとネイティブ CRT 間のプロキシを提供します。 静的にリンクされた CRT ( **`/MT`** または **`/MTd`** オプション) をと共に使用することはできません **`/clr`** 。 代わりに、動的にリンクされるライブラリ (または) を使用して **`/MD`** **`/MDd`** ください。 純粋マネージ CRT のライブラリは、Visual Studio 2015 で非推奨となり、Visual Studio 2017 ではサポートされていません。

で CRT を使用する方法の詳細につい **`/clr`** ては、「 [Mixed (ネイティブおよびマネージ) アセンブリ](../dotnet/mixed-native-and-managed-assemblies.md)」を参照してください。

アプリケーションのデバッグバージョンをビルドするには、 [`_DEBUG`](../c-runtime-library/debug.md) フラグを定義し、アプリケーションをこれらのライブラリのいずれかのデバッグバージョンにリンクする必要があります。 ライブラリ ファイルのデバッグ バージョンの使い方の詳細については、「 [CRT のデバッグ技術](/visualstudio/debugger/crt-debugging-techniques)」を参照してください。

この CRT のバージョンは、C99 標準に完全には準拠していません。 Visual Studio 2019 バージョン16.8 より前のバージョンで \<tgmath.h> は、ヘッダーはサポートされていません。 すべてのバージョンで、 `CX_LIMITED_RANGE` および `FP_CONTRACT` プラグママクロはサポートされていません。 標準 IO 関数内のパラメーター指定子の意味などの特定の要素で、既定で、従来の解釈が使用されます。 **`/Zc`** コンパイラ準拠オプションを使用して、リンカーオプションを指定して、ライブラリ準拠の一部の側面を制御できます。

## <a name="c-standard-library"></a>C++ 標準ライブラリ

| C++ 標準ライブラリ | 特性 | オプション | プリプロセッサ ディレクティブ |
|--|--|--|--|
| *`libcpmt.lib`* | マルチスレッド、静的リンク | **`/MT`** | `_MT` |
| *`msvcprt.lib`* | マルチスレッド、動的リンク (用のインポートライブラリ *`msvcp<version>.dll`* ) | **`/MD`** | `_MT`, `_DLL` |
| *`libcpmtd.lib`* | マルチスレッド、静的リンク | **`/MTd`** | `_DEBUG`, `_MT` |
| *`msvcprtd.lib`* | マルチスレッド、動的リンク (用のインポートライブラリ *`msvcp<version>d.dll`* ) | **`/MDd`** | `_DEBUG`, `_MT`, `_DLL` |

プロジェクトのリリースバージョンをビルドすると、 *`libcmt.lib`* *`msvcmrt.lib`* 選択し *`msvcrt.lib`* たコンパイラオプション (マルチスレッド、DLL、) に応じて、基本的な C ランタイムライブラリ (、、) のいずれかが既定でリンクされ **`/clr`** ます。 コードに [C++ 標準ライブラリのヘッダー ファイル](../standard-library/cpp-standard-library-header-files.md)の 1 つがインクルードされている場合は、コンパイル時に Visual C++ によって自動的に C++ 標準ライブラリがリンクされます。 次に例を示します。

```cpp
#include <ios>
```

バイナリの互換性のため、複数の DLL ファイルが 1 つのインポート ライブラリによって指定される場合があります。 バージョンの更新によって、*ドット ライブラリ*が導入される場合があります。これは、新しいライブラリ機能が導入される別の DLL です。 たとえば、 *`msvcp140_1.dll`* によってサポートされる ABI を損なうことなく、追加の標準ライブラリ機能をサポートするために Visual Studio 2017 バージョン15.6 が導入されました *`msvcp140.dll`* 。 *`msvcprt.lib`* Visual Studio 2017 バージョン15.6 のツールセットに含まれるインポートライブラリは両方の dll をサポートし、このバージョンの vcredist は両方の dll をインストールします。 出荷後は、ドット ライブラリに修正された ABI が含まれ、以後のドット ライブラリに対する依存関係はなくなります。

## <a name="what-problems-exist-if-an-application-uses-more-than-one-crt-version"></a>アプリケーションで複数の CRT バージョンを使用した場合に発生する問題

すべての実行可能イメージ (EXE または DLL) は、静的にリンクされた独自の CRT を持たせるか、動的に CRT にリンクさせることができます。 特定のイメージによって静的に含まれる、または動的に読み込まれる CRT のバージョンは、ビルド時に使用されたツールとライブラリのバージョンによって異なります。 1 つのプロセスが複数の EXE や DLL イメージを読み込み、そのそれぞれが独自の CRT を持っている場合があります。 これらの各 CRT は、異なる allocator を使用し、異なる内部構造体のレイアウトを備え、異なるストレージ配置を使用する可能性があります。 つまり、メモリの割り当て、CRT リソース、DLL の境界を越えて渡されるクラスによって、メモリ管理、内部の static の使用、レイアウトの解釈に問題が発生する場合があります。 たとえば、1 つの DLL に割り当てられているクラスが別の DLL に渡されて削除された場合、使用されるのはどの CRT の deallocator でしょうか。 発生するエラーは微妙なものから即座に致命的となるものまでさまざまです。そのため、そのようなリソースを直接転送することは、回避することを強くお勧めします。

代わりに、アプリケーション バイナリ インターフェイス (ABI) テクノロジを使用することで、この問題の多くを回避できます。安定しバージョン管理が可能であるように設計されるためです。 値によって情報を渡すか、ローカルで割り当てたメモリを呼び出し元に返すのではなく呼び出し元によって渡されたメモリを使用するように、DLL のエクスポート インターフェイスを設計します。 実行可能イメージ間で構造化データをコピーするには、マーシャリング技法を使用します。 リソースをローカルでカプセル化し、クライアントに公開したハンドルまたは関数を通してのみこれを操作できるようにします。

また、プロセス内のすべてのイメージで同じバージョンの CRT が動的に読み込まれる場合は、これらの問題を一部回避することもできます。 すべてのコンポーネントが同じ DLL バージョンの CRT を使用するようにするには、オプションを使用してビルド **`/MD`** し、同じコンパイラツールセットとプロパティ設定を使用します。

プログラムが DLL の境界を越えて特定の CRT リソースを渡す場合は注意してください。 ファイルハンドル、ロケール、環境変数などのリソースでは、同じバージョンの CRT を使用している場合でも、問題が発生する可能性があります。 発生する可能性のある問題とその対処法の詳細については、「[DLL の境界を越えて CRT オブジェクトを渡す場合に発生する可能性のあるエラー](../c-runtime-library/potential-errors-passing-crt-objects-across-dll-boundaries.md)」を参照してください。

## <a name="see-also"></a>関連項目

- [C ランタイムライブラリリファレンス](../c-runtime-library/c-run-time-library-reference.md)
