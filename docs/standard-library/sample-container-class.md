---
description: '詳細情報: サンプルコンテナークラス'
title: サンプル コンテナー クラス
ms.date: 11/04/2016
helpviewer_keywords:
- container classes [C++]
ms.assetid: 5b1451f2-c708-45da-bbf0-9e42fd687a1a
ms.openlocfilehash: 728cec44462a8e09aad7f87000520f0fa5a15b3a
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/11/2020
ms.locfileid: "97148877"
---
# <a name="sample-container-class"></a>サンプル コンテナー クラス

> [!NOTE]
> このトピックは、C++ 標準ライブラリで使用されるコンテナーの非機能例として、Microsoft C++ ドキュメントに記載されています。 詳細については、「[C++ 標準ライブラリ コンテナー](../standard-library/stl-containers.md)」を参照してください。

要素の可変長シーケンス (通常は型) を制御するオブジェクトを記述し `Ty` ます。 シーケンスは、実際のコンテナーに応じて、さまざまな方法で格納されます。

コンテナーのコンストラクターまたはメンバー関数がコンストラクター **Ty**(**const Ty&**) または関数 **Ty::operator=**(**const Ty&**) を呼び出す場合があります。 このような呼び出しで例外がスローされた場合、コンテナー オブジェクトは、その整合性を維持し、すべての例外をキャッチして再スローする必要があります。 コンテナー オブジェクトによっていずれか 1 つの例外がスローされた後に、コンテナー オブジェクトを安全にスワップ、消去、または破棄できます。 ただし、通常、それ以外の場合はコンテナー オブジェクトによって制御されるシーケンスの状態を予測できません。

その他の注意点:

- 式が例外をスローした場合、 `~Ty` コンテナーオブジェクトの結果の状態は未定義になります。

- コンテナーがアロケーターオブジェクト *al* を格納し、 *al* がの呼び出しの結果としてではなく例外をスローした場合、 `al.allocate` コンテナーオブジェクトの結果の状態は未定義になります。

- コンテナーが被制御シーケンスの順序付け方法を指定する関数オブジェクト *comp* を格納し、*comp* がいずれかの例外をスローする場合、コンテナー オブジェクトの結果の状態は未定義です。

C++ 標準ライブラリで定義されているコンテナー クラスは、次に説明するいくつかの追加要件を満たします。

コンテナークラステンプレート [リスト](../standard-library/list-class.md) は、上記の例外が存在する場合でも、決定的で便利な動作を提供します。 たとえば、1 つまたは複数の要素の挿入時に例外がスローされた場合、コンテナーは変更されず、再度例外がスローされます。

C++ 標準ライブラリで定義されている *すべて* のコンテナークラスについて、次のメンバー関数、、、またはの呼び出し中に例外がスローされた場合、 `insert` `push_back` `push_front` コンテナーは変更されず、例外が再スローされます。

C++ 標準ライブラリで定義されている *すべて* のコンテナークラスについて、、の各メンバー関数の呼び出し中に例外がスローされることはありません。 `pop_back` `pop_front`

メンバー関数 [erase](../standard-library/container-class-erase.md) は、コピー操作 (割り当てまたはコピーの構築) が例外をスローする場合にのみ例外をスローします。

さらに、メンバー関数によって返される反復子のコピー中に例外はスローされません。

メンバー関数 [swap](../standard-library/container-class-swap.md) は、C++ 標準ライブラリで定義されている *すべての* コンテナー クラスに対する追加の確実性を実現します。

- コンテナーがアロケーター オブジェクト al を格納し、`al` がコピーされるときに例外をスローする場合にのみ、メンバー関数が例外をスローします。

- スワップされる被制御シーケンスの要素を指定する参照、ポインター、および反復子は有効なままです。

C++ 標準ライブラリで定義されたコンテナー クラスのオブジェクトが、`Alloc` 型の格納されているオブジェクトによって制御するシーケンスの記憶域の割り当ておよび解放を行います (これは通常、テンプレート パラメーターです)。 このようなアロケーターオブジェクトは、クラスのオブジェクトと同じ外部インターフェイスを持っている必要があり `allocator<Ty>` ます。 特に、は、 `Alloc` と同じ型である必要があります。 `Alloc::rebind<value_type>::other`

C++ 標準ライブラリで定義されている *すべて* のコンテナークラスについて、このメンバー関数は、格納されている `Alloc get_allocator const;` アロケーターオブジェクトのコピーを返します。 コンテナーオブジェクトが割り当てられても、格納されているアロケーターオブジェクトはコピーされ *ない* ことに注意してください。 `allocator`コンストラクターにアロケーターパラメーターが含まれていない場合、すべてのコンストラクターは、に格納されている値をに初期化し `Alloc` ます。

C++ 標準に従って、C++ 標準ライブラリで定義されたコンテナー クラスは次を想定できます。

- クラス `Alloc` のすべてのオブジェクトの比較結果が同じになります。

- 型 `Alloc::const_pointer` はと同じ `const Ty *` です。

- 型 `Alloc::const_reference` はと同じ `const Ty&` です。

- 型 `Alloc::pointer` はと同じ `Ty *` です。

- 型 `Alloc::reference` はと同じ `Ty&` です。

ただし、この実装では、コンテナーはこのような単純な想定を行いません。 このため、コンテナーはより意欲的なアロケーター オブジェクトと共に適切に動作します。

- クラス `Alloc` のすべてのオブジェクトの比較結果が同じである必要はありません。 (記憶域の複数のプールを維持することができます。)

- 型は `Alloc::const_pointer` と同じである必要はありません `const Ty *` 。 (const ポインターには、クラスを指定できます。)

- 型は `Alloc::pointer` と同じである必要はありません `Ty *` 。 (ポインターには、クラスを指定できます。)

## <a name="requirements"></a>要件

**ヘッダー**: \<sample container>

## <a name="see-also"></a>関連項目

[\<sample container>](../standard-library/sample-container.md)
