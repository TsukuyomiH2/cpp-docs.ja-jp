---
title: Iterators
ms.date: 11/04/2016
helpviewer_keywords:
- iterator conventions
- C++ Standard Library, iterator conventions
ms.assetid: 2f746be7-b37d-4bfc-bf05-be4336ca982f
ms.openlocfilehash: c3bb2825ec6ad98f523fa4c3a616d0807eac50a8
ms.sourcegitcommit: 5ef9697b4cb1947bec9669be57bc920d2c4d82a6
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/06/2020
ms.locfileid: "87870153"
---
# <a name="iterators"></a>Iterators

反復子は、C++ 標準ライブラリ コンテナー内の要素を反復処理し、個々の要素へのアクセスを提供するオブジェクトです。 すべての C++ 標準ライブラリ コンテナーに反復子が用意されているため、アルゴリズムではその要素を格納するコンテナーの型を気にせずに標準的な方法で要素にアクセスできます。

反復子は、メンバーと、やなどのグローバル関数、およびやなどの演算子を使用して、 `begin()` `end()` `++` `--` 前方または後方に移動できます。 また、範囲 for ループまたは (一部の反復子型の) 添字演算子では、反復子を暗黙的に使用することもでき `[]` ます。

C++ 標準ライブラリでは、シーケンスまたは範囲の始まりが最初の要素になります。 シーケンスまたは範囲の終わりは、常に最後の要素の 1 つ後として定義されます。 グローバル関数とは、 `begin` `end` 指定されたコンテナーに反復子を返します。 コンテナー内のすべての要素に対する通常の明示的な反復子のループは、次のようになります。

```cpp
vector<int> vec{ 0,1,2,3,4 };
for (auto it = begin(vec); it != end(vec); it++)
{
    // Access element using dereference operator
    cout << *it << " ";
}
```

同じ処理を、range-for ループでより単純に実現できます。

```cpp
for (auto num : vec)
{
    // no dereference operator
    cout << num << " ";
}
```

反復子には、5 つのカテゴリがあります。 これらのカテゴリを、機能が低い方から順に示します。

- **出力**。 *出力反復子*は、 `X` 演算子を使用してシーケンスを前方に反復処理でき `++` ます。また、演算子を使用すると、1回だけ要素を書き込むことができ __`*`__ ます。

- **入力**。 *入力反復子*は、 `X` 演算子を使用してシーケンスを前方に反復処理でき `++` ます。また、演算子を使用すると、要素を任意の回数読み取ることができ `*` ます。 演算子と演算子を使用すると、入力反復子を比較でき `==` `!=` ます。 入力反復子のコピーをインクリメントした後は、他のコピーを安全に比較、逆参照、またはインクリメントすることはできません。

- **進む**。 *前方反復子*は、 `X` + + 演算子を使用してシーケンスを前方に反復処理できます。また、演算子を使用すると、任意の要素を読み取ったり、非定数要素を何回でも書き込むことができ `*` ます。 要素のメンバーにアクセスするには、演算子を使用し、演算子 `->` と演算子を使用して前方反復子を比較し `==` `!=` ます。 前方反復子のコピーを複数作成して、それぞれを個別に逆参照または増分できます。 任意のコンテナーへの参照を使用せずに初期化された前方反復子は、 *null 前方反復子*と呼ばれます。 NULL 前方反復子を比較すると、常に等しくなります。

- **双方向**。 *双方向反復子*は、 `X` 前方反復子の代わりに使用できます。 ただし、、、またはのように、双方向反復子をデクリメントすることもでき `--X` `X--` `(V = *X--)` ます。 要素のメンバーにアクセスし、前方反復子と同じ方法で双方向反復子を比較できます。

- **ランダムアクセス**。 *ランダムアクセス反復子*は、 `X` 双方向反復子の代わりに使用できます。 ランダムアクセス反復子を使用すると、添字演算子を使用して `[]` 要素にアクセスできます。 `+`、、およびの各 `-` `+=` `-=` 演算子を使用すると、指定した数の要素を前方または後方に移動したり、反復子間の距離を計算したりできます。 、、、、、およびを使用して、双方向反復子を比較でき `==` `!=` `<` `>` `<=` `>=` ます。

すべての反復子は、割り当てまたはコピーすることができます。 これらはライトウェイトオブジェクトと見なされ、多くの場合、参照ではなく値によって渡されて返されます。 前述のすべての操作は、有効な反復子に対して実行したときに例外をスローできないことに注意してください。

反復子のカテゴリの階層は、次の 3 つのシーケンスを表示することによって要約することができます。 シーケンスに対する書き込み専用アクセスの場合、次のいずれの反復子も使用できます。

> 出力反復子 \
> -> 前方反復子 \
> -> 双方向反復子 \
> -> ランダムアクセス反復子

右矢印は、"後続の反復子で置き換え可能" であることを示します。 出力反復子を必要とするすべてのアルゴリズムは前方反復子を使用してうまく動作しますが、その逆の方法ではうまく動作*しません*。

シーケンスに対する読み取り専用アクセスの場合、次のいずれの反復子も使用できます。

> 入力反復子 \
> -> 前方反復子 \
> -> 双方向反復子 \
> -> ランダムアクセス反復子

この場合、すべてのカテゴリのうちで最も弱いのは入力反復子です。

最後に、シーケンスに対する読み取り/書き込みアクセスの場合、次のいずれの反復子も使用できます。

> 前方反復子 \
> -> 双方向反復子 \
> -> ランダムアクセス反復子

オブジェクト ポインターは、常にランダム アクセス反復子としての機能を果たします。したがって、指定したシーケンスに対する適切な読み取り/書き込みアクセスをサポートしている場合は、反復子の任意のカテゴリとしての機能を果たします。

オブジェクト ポインター以外の反復子 `Iterator` では、特殊化 `iterator_traits<Iterator>` で必要なメンバーの型も定義する必要があります。 これらの要件は `Iterator` 、パブリック基底クラスの[反復子](../standard-library/iterator-struct.md)から派生することによって満たすことができます。

C++ 標準ライブラリのコンテナーとアルゴリズムで反復子がどのように使用されるかを確認するには、各反復子カテゴリの約束と制限を理解しておくことが重要です。

> [!NOTE]
> range-for ループを使用することにより、反復子の明示的な使用を避けることができます。 詳細については、「[範囲ベースの for ステートメント](../cpp/range-based-for-statement-cpp.md)」を参照してください。

Microsoft C++ では、コンテナーの境界を上書きしないように、チェックを行う反復子とデバッグ反復子が提供されるようになりました。 詳細については、「[チェックを行う反復子](../standard-library/checked-iterators.md)」および「[デバッグ反復子のサポート](../standard-library/debug-iterator-support.md)」をご覧ください。

## <a name="see-also"></a>関連項目

[C++ 標準ライブラリリファレンス](../standard-library/cpp-standard-library-reference.md)\
[C++ 標準ライブラリのスレッドセーフ](../standard-library/thread-safety-in-the-cpp-standard-library.md)
