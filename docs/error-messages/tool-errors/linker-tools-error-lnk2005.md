---
description: 詳細については、「リンカツール Error LNK2005」を参照してください。
title: リンカ ツール エラー LNK2005
ms.date: 11/04/2016
f1_keywords:
- LNK2005
helpviewer_keywords:
- LNK2005
ms.assetid: d9587adc-68be-425c-8a30-15dbc86717a4
ms.openlocfilehash: c6de300bc731104f51056911515d0cc7a95e05f8
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/11/2020
ms.locfileid: "97338504"
---
# <a name="linker-tools-error-lnk2005"></a>リンカ ツール エラー LNK2005

> *シンボル* は既にオブジェクトで定義されています

シンボル *シンボル* が複数回定義されました。

このエラーの後に致命的なエラー [LNK1169](../../error-messages/tool-errors/linker-tools-error-lnk1169.md)が発生します。

### <a name="possible-causes-and-solutions"></a>考えられる原因と解決策

通常、このエラーは、 *1 つの定義ルール* が壊れていることを意味します。これにより、特定のオブジェクトファイル内の使用されているすべてのテンプレート、関数、型、またはオブジェクトに対して定義が1つだけ許可されます

このエラーの一般的な原因をいくつか次に示します。

- このエラーは、ヘッダーファイルで変数が定義されている場合に発生する可能性があります。 たとえば、プロジェクト内の複数のソースファイルにこのヘッダーファイルを含めると、次のようなエラーが発生します。

    ```h
    // LNK2005_global.h
    int global_int;  // LNK2005
    ```

   考えられる解決策:

  - ヘッダーファイルで変数を宣言します。次に **`extern`** `extern int global_int;` 、それを定義し、必要に応じて1つのソースファイル () で初期化 `int global_int = 17;` します。 これで、この変数はグローバルになりました。これは、たとえば、ヘッダーファイルをインクルードすることによって、任意のソースファイルで宣言することによって使用でき **`extern`** ます。 グローバルにする必要がある変数に対しては、このソリューションをお勧めしますが、優れたソフトウェアエンジニアリングによってグローバル変数が最小限に抑えられます。

  - [Static](../../cpp/storage-classes-cpp.md#static)変数を宣言 `static int static_int = 17;` します。 これにより、定義のスコープが現在のオブジェクトファイルに限定され、複数のオブジェクトファイルに変数の独自のコピーが含まれるようになります。 グローバル変数と混同する可能性があるため、ヘッダーファイルに静的変数を定義することはお勧めしません。 静的変数の定義を、それらを使用するソースファイルに移動することをお勧めします。

  - 変数 [selectany](../../cpp/selectany.md): を宣言し `__declspec(selectany) int global_int = 17;` ます。 これにより、リンカーは、すべての外部参照で使用する1つの定義を選択し、残りを破棄するように指示します。 このソリューションは、インポートライブラリを組み合わせるときに便利な場合があります。 それ以外の場合は、リンカーエラーを回避する方法として推奨されません。

- このエラーは、ヘッダーファイルでではない関数が定義されている場合に発生する可能性が **`inline`** あります。 複数のソースファイルにこのヘッダーファイルを含めると、実行可能ファイルで関数の複数の定義が取得されます。

    ```h
    // LNK2005_func.h
    int sample_function(int k) { return 42 * (k % 167); }  // LNK2005
    ```

   考えられる解決策:

  - キーワードを **`inline`** 関数に追加します。

    ```h
    // LNK2005_func_inline.h
    inline int sample_function(int k) { return 42 * (k % 167); }
    ```

  - ヘッダーファイルから関数本体を削除し、宣言だけを残して、関数を1つのソースファイルにのみ実装します。

    ```h
    // LNK2005_func_decl.h
    int sample_function(int);
    ```

    ```cpp
    // LNK2005_func_impl.cpp
    int sample_function(int k) { return 42 * (k % 167); }
    ```

- このエラーは、ヘッダーファイル内のクラス宣言の外部でメンバー関数を定義した場合にも発生する可能性があります。

    ```h
    // LNK2005_member_outside.h
    class Sample {
    public:
        int sample_function(int);
    };
    int Sample::sample_function(int k) { return 42 * (k % 167); }  // LNK2005
    ```

   この問題を解決するには、メンバー関数の定義をクラス内で移動します。 クラス宣言内で定義されているメンバー関数は、暗黙的にインライン化されます。

    ```h
    // LNK2005_member_inline.h
    class Sample {
    public:
        int sample_function(int k) { return 42 * (k % 167); }
    };
    ```

- このエラーは、標準ライブラリまたは CRT の複数のバージョンをリンクした場合に発生する可能性があります。 たとえば、リテールとデバッグの両方の CRT ライブラリ、またはライブラリの静的バージョンと動的バージョンの両方、または2つの異なるバージョンの標準ライブラリを実行可能ファイルにリンクしようとすると、このエラーが何回も報告されることがあります。 この問題を解決するには、リンクコマンドから各ライブラリのコピーを1つだけ削除します。 製品版とデバッグ用のライブラリ、または異なるバージョンのライブラリを同じ実行可能ファイルに混在させることはお勧めしません。

   既定以外のライブラリを使用するようにリンカーに指示するには、コマンドラインで、使用するライブラリを指定し、 [/NODEFAULTLIB](../../build/reference/nodefaultlib-ignore-libraries.md) オプションを使用して既定のライブラリを無効にします。 IDE で、使用するライブラリを指定するためにプロジェクトに参照を追加し、プロジェクトの [ **プロパティページ** ] ダイアログを開きます。また、[ **リンカー**] の [ **入力** ] プロパティページで、[すべての既定の **ライブラリを無視** する] または [ **特定の既定ライブラリ** を無視する] プロパティを既定のライブラリを無効にするように設定します。

- このエラーは、 [/clr](../../build/reference/clr-common-language-runtime-compilation.md) オプションを使用するときに、静的ライブラリと動的ライブラリを組み合わせて使用した場合に発生する可能性があります。 たとえば、静的 CRT 内のリンクを実行可能ファイルで使用するために DLL をビルドすると、このエラーが発生する可能性があります。 この問題を解決するには、実行可能ファイルで使用するためにビルドするすべてのライブラリに対して、スタティックライブラリのみを使用するか、動的ライブラリを使用します。

- このエラーは、シンボルがパッケージ化された関数 ( [/gy](../../build/reference/gy-enable-function-level-linking.md)を使用してコンパイルすることによって作成される) で、複数のファイルに含まれていたが、コンパイル間で変更された場合に発生する可能性があります。 この問題を解決するには、パッケージ化された関数を含むすべてのファイルを再コンパイルします。

- このエラーは、異なるライブラリの2つのメンバーオブジェクトでシンボルが異なる方法で定義されていて、両方のメンバーオブジェクトが使用されている場合に発生する可能性があります。 ライブラリが静的にリンクされているときにこの問題を解決する方法の1つは、1つのライブラリのメンバーオブジェクトを使用し、そのライブラリを最初にリンカーコマンドラインに含めることです。 両方のシンボルを使用するには、それらを区別する方法を作成する必要があります。 たとえば、ソースからライブラリをビルドできる場合は、各ライブラリを一意の名前空間にラップできます。 または、一意の名前を使用して元のライブラリへの参照をラップする新しいラッパーライブラリを作成し、新しいライブラリを元のライブラリにリンクしてから、実行可能ファイルを元のライブラリではなく新しいライブラリにリンクすることもできます。

- このエラーは、 `extern const` 変数が2回定義されており、それぞれの定義に異なる値がある場合に発生する可能性があります。 この問題を解決するには、定数を1回だけ定義するか、名前空間または **`enum class`** 定義を使用して定数を区別します。

- このエラーは、Guid を定義する他の .lib ファイル (たとえば、oledb および adsiid) と共に uuid を使用した場合に発生する可能性があります。 次に例を示します。

    ```Output
    oledb.lib(oledb_i.obj) : error LNK2005: _IID_ITransactionObject
    already defined in uuid.lib(go7.obj)
    ```

   この問題を解決するには、リンカーコマンドラインオプションに [/force: MULTIPLE](../../build/reference/force-force-file-output.md) を追加し、最初に参照されたライブラリが uuid .lib であることを確認します。
