---
title: リンカ ツール エラー LNK2005
ms.date: 11/04/2016
f1_keywords:
- LNK2005
helpviewer_keywords:
- LNK2005
ms.assetid: d9587adc-68be-425c-8a30-15dbc86717a4
ms.openlocfilehash: 6090478c3761c477250b6706a350e261b51f2a05
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81353235"
---
# <a name="linker-tools-error-lnk2005"></a>リンカ ツール エラー LNK2005

> オブジェクトで既に定義されている*シンボル*

シンボル*シンボル*が複数回定義されました。

このエラーの後に致命的なエラー [LNK1169](../../error-messages/tool-errors/linker-tools-error-lnk1169.md)が続きます。

### <a name="possible-causes-and-solutions"></a>考えられる原因と解決策

一般に、このエラーは、特定のオブジェクトファイルで使用されるテンプレート、関数、タイプ、またはオブジェクトに対して1つの定義のみを許可し、外部から参照できるオブジェクトまたは関数の実行可能ファイル全体で1つの定義のみを許可する*1つの定義*ルールを破ることを意味します。

このエラーの一般的な原因を次に示します。

- このエラーは、ヘッダー ファイルが変数を定義している場合に発生する可能性があります。 たとえば、プロジェクト内の複数のソース ファイルにこのヘッダー ファイルを含める場合、エラーが発生します。

    ```h
    // LNK2005_global.h
    int global_int;  // LNK2005
    ```

   考えられる解決策:

  - ヘッダー ファイル`extern`で変数を宣言します`extern int global_int;`: を定義し、必要に応じて 1 つのソース ファイル`int global_int = 17;`のみで初期化します。 この変数は、ヘッダー ファイルなどを含めることによって、任意のソース ファイル`extern`を宣言して使用できるグローバル変数になりました。 グローバルにする必要がある変数に対してこのソリューションを推奨しますが、優れたソフトウェアエンジニアリング手法ではグローバル変数を最小限に抑えます。

  - [変数](../../cpp/storage-classes-cpp.md#static)static を`static int static_int = 17;`宣言します。 これにより、定義のスコープが現在のオブジェクト ファイルに制限され、複数のオブジェクト ファイルが変数の独自のコピーを持つことができます。 グローバル変数との混乱が生じかねるため、ヘッダーファイルに静的変数を定義しないことをお勧めします。 静的変数定義を使用するソース ファイルに移動することを好みます。

  - 変数[selectany](../../cpp/selectany.md)を`__declspec(selectany) int global_int = 17;`宣言します。 これにより、リンカーはすべての外部参照で使用する定義を 1 つ選択し、残りの定義を破棄するように指示します。 このソリューションは、インポート ライブラリを組み合わせるときに役立つ場合があります。 それ以外の場合は、リンカーエラーを回避する方法としてお勧めしません。

- このエラーは、ヘッダー ファイルが定義`inline`されていない関数を定義している場合に発生する可能性があります。 このヘッダー ファイルを複数のソース ファイルに含める場合は、実行可能ファイル内の関数の複数の定義を取得します。

    ```h
    // LNK2005_func.h
    int sample_function(int k) { return 42 * (k % 167); }  // LNK2005
    ```

   考えられる解決策:

  - 関数に`inline`キーワードを追加します。

    ```h
    // LNK2005_func_inline.h
    inline int sample_function(int k) { return 42 * (k % 167); }
    ```

  - ヘッダー ファイルから関数本体を削除し、宣言のみを残して、1 つだけのソース ファイルで関数を実装します。

    ```h
    // LNK2005_func_decl.h
    int sample_function(int);
    ```

    ```cpp
    // LNK2005_func_impl.cpp
    int sample_function(int k) { return 42 * (k % 167); }
    ```

- このエラーは、ヘッダー ファイルでクラス宣言の外側にメンバー関数を定義した場合にも発生します。

    ```h
    // LNK2005_member_outside.h
    class Sample {
    public:
        int sample_function(int);
    };
    int Sample::sample_function(int k) { return 42 * (k % 167); }  // LNK2005
    ```

   この問題を解決するには、クラス内のメンバー関数定義を移動します。 クラス宣言内で定義されたメンバー関数は、暗黙的にインライン化されます。

    ```h
    // LNK2005_member_inline.h
    class Sample {
    public:
        int sample_function(int k) { return 42 * (k % 167); }
    };
    ```

- このエラーは、複数のバージョンの標準ライブラリまたは CRT をリンクした場合に発生する可能性があります。 たとえば、リテールライブラリとデバッグCRTライブラリの両方、またはスタティックバージョンとダイナミックバージョンの両方、または標準ライブラリの2つの異なるバージョンを実行可能ファイルにリンクしようとすると、このエラーが何度も報告されることがあります。 この問題を解決するには、link コマンドから各ライブラリのコピーを 1 つだけ削除します。 同じ実行可能ファイル内で、リテール ライブラリとデバッグ ライブラリ、またはライブラリの異なるバージョンを混在させないことをお勧めします。

   リンカーにデフォルト以外のライブラリーを使用するように指示するには、コマンド行で使用するライブラリーを指定し[、/NODEFAULTLIB](../../build/reference/nodefaultlib-ignore-libraries.md)オプションを使用してデフォルト・ライブラリーを使用不可にします。 IDE で、使用するライブラリを指定するプロジェクトへの参照を追加し、プロジェクトの **[プロパティ ページ]** ダイアログを開き、[**リンカー**] の **[入力**] プロパティ ページで [**既定のライブラリをすべて無視**する] または **[特定の既定のライブラリを無視**する] プロパティを設定して、既定のライブラリを無効にします。

- このエラーは[、/clr](../../build/reference/clr-common-language-runtime-compilation.md)オプションを使用するときに静的ライブラリと動的ライブラリを混在する場合に発生することがあります。 たとえば、このエラーは、静的 CRT にリンクする実行可能ファイルで使用する DLL をビルドした場合に発生します。 この問題を解決するには、実行可能ファイル全体と、実行可能ファイルで使用するビルドのライブラリに対して、静的ライブラリのみを使用するか、動的ライブラリのみを使用します。

- このエラーは、シンボルがパッケージ化された関数[(/Gy](../../build/reference/gy-enable-function-level-linking.md)でコンパイルして作成された) で、複数のファイルに含まれていたが、コンパイル間で変更された場合に発生する可能性があります。 この問題を解決するには、パッケージ化された関数を含むすべてのファイルを再コンパイルします。

- このエラーは、異なるライブラリ内の 2 つのメンバー オブジェクトでシンボルが異なる定義を行い、両方のメンバー オブジェクトが使用されている場合に発生します。 ライブラリが静的にリンクされている場合にこの問題を解決する 1 つの方法は、1 つのライブラリのメンバー オブジェクトのみを使用し、そのライブラリを最初にリンカー コマンド ラインに含める方法です。 両方のシンボルを使用するには、それらを区別する方法を作成する必要があります。 たとえば、ソースからライブラリをビルドできる場合は、各ライブラリを一意の名前空間にラップできます。 または、一意の名前を使用して元のライブラリへの参照をラップする新しいラッパー ライブラリを作成し、新しいライブラリを元のライブラリにリンクしてから、元のライブラリではなく新しいライブラリに実行可能ファイルをリンクします。

- このエラーは、変数が`extern const`2 回定義され、各定義に異なる値が設定されている場合に発生します。 この問題を解決するには、定数を 1 回だけ定義するか、`enum class`名前空間または定義を使用して定数を区別します。

- このエラーは、GUID を定義する他の .lib ファイル (oledb.lib や adsiid.lib など) と組み合わせて uuid.lib を使用している場合に発生する可能性があります。 次に例を示します。

    ```Output
    oledb.lib(oledb_i.obj) : error LNK2005: _IID_ITransactionObject
    already defined in uuid.lib(go7.obj)
    ```

   この問題を解決するには、リンカーのコマンド ライン オプションに[/FORCE:MULTIPLE](../../build/reference/force-force-file-output.md)を追加し、uuid.lib が最初に参照されるライブラリであることを確認します。
