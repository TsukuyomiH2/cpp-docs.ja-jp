---
description: 詳細については、「コンパイラエラー C2558」を参照してください。
title: コンパイラ エラー C2558
ms.date: 11/04/2016
f1_keywords:
- C2558
helpviewer_keywords:
- C2558
ms.assetid: 822b701e-dcae-423a-b21f-47f36aff9c90
ms.openlocfilehash: 12f75294f02b6586a90515f381b37c8c346f4567
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/11/2020
ms.locfileid: "97338720"
---
# <a name="compiler-error-c2558"></a>コンパイラ エラー C2558

'identifier' : プライベート メンバー、プロテクト メンバーの初期化にはコンストラクターが必要です。

コピー コンストラクターは、あるオブジェクトを同じ型の別のオブジェクトの値で初期化します。 (オブジェクトのコピーを作成します)。コンストラクターを定義しない場合、コンパイラは既定のコピーコンストラクターを生成します。

### <a name="to-fix-this-error"></a>このエラーを修復するには

1. この問題は、コピーコンストラクターがであるクラスをコピーしようとしたときに発生する可能性があり **`private`** ます。 ほとんどの場合、コピーコンストラクターを持つクラスはコピーしないでください **`private`** 。 一般的なプログラミング手法では、 **`private`** クラスを直接使用しないようにコピーコンストラクターを宣言します。 このクラスは、単独では役に立たない、つまり正常に機能させるには別のクラスを必要とする場合があります。

   コピーコンストラクターを持つクラスを使用しても安全であると判断した場合は **`private`** 、コンストラクターを持つクラスから新しいクラスを派生させ、 **`private`** **`public`** **`protected`** 新しいクラスでまたはコピーコンストラクターを使用できるようにします。 この派生クラスを元のクラスがあった位置で使用するとエラーを解決できます。

1. この問題は、コピー コンストラクターが明示的であるクラスをコピーしようとしたときに発生する場合があります。 コピーコンストラクターをとして宣言 **`explicit`** すると、関数との間でクラスのオブジェクトを渡したり返したりすることが回避されます。 明示的なコンストラクターの詳細については、「 [ユーザー定義型変換](../../cpp/user-defined-type-conversions-cpp.md)」を参照してください。

1. この問題は、 **`const`** 参照パラメーターを受け取らないコピーコンストラクターを使用して、によって宣言されたクラスインスタンスをコピーしようとしたときに発生する可能性があり **`const`** ます。 **`const`** 非 const 型参照の代わりに型参照を使用して、コピーコンストラクターを宣言します。
