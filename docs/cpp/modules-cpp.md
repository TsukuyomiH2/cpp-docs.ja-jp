---
title: C++ のモジュールの概要
ms.date: 12/13/2019
helpviewer_keywords:
- modules [C++]
- modules [C++], overview
description: C++20 のモジュールは、ヘッダー ファイルに代わる最新のモジュールです。
ms.openlocfilehash: cd45be1dee888c8caeb65b7ff002ac8fee1ecbe1
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81370760"
---
# <a name="overview-of-modules-in-c"></a>C++ のモジュールの概要

C++20 では、C++ ライブラリとプログラムのコンポーネント化のための最新ソリューションである*モジュール*を導入しています。 モジュールは、インポートする[翻訳単位](https://wikipedia.org/wiki/Translation_unit_(programming))とは独立してコンパイルされるソース コード ファイルのセットです。 モジュールは、ヘッダー ファイルの使用に関連する問題の多くを排除または大幅に削減し、コンパイル時間を短縮する可能性もあります。 モジュール内で宣言されたマクロ、プリプロセッサ ディレクティブ、およびエクスポートされていない名前は表示されないため、モジュールをインポートする変換単位のコンパイルには影響しません。 マクロの再定義を気にすることなく、モジュールを任意の順序でインポートできます。 インポートする翻訳単位の宣言は、インポートされたモジュールのオーバーロード解決または名前検索に参加しません。 モジュールを 1 回コンパイルすると、エクスポートされたすべての型、関数、およびテンプレートを記述したバイナリ ファイルに結果が格納されます。 このファイルはヘッダー ファイルよりも処理が高速で、モジュールがプロジェクトにインポートされる場所ごとにコンパイラで再利用できます。

モジュールは、ヘッダー ファイルと並べて使用できます。 C++ ソース ファイルは、モジュールをインポートしたり、ヘッダー ファイル#includeしたりできます。 場合によっては、ヘッダー ファイルをプリプロセッサによってテキストで#includedするのではなく、モジュールとしてインポートできます。 新しいプロジェクトでは、ヘッダー ファイルではなくモジュールをできるだけ使用することをお勧めします。 開発中の大規模な既存プロジェクトの場合は、レガシーヘッダーをモジュールに変換して、コンパイル時間を大幅に短縮できるかどうかを確認することをお勧めします。

## <a name="enable-modules-in-the-microsoft-c-compiler"></a>Microsoft C++ コンパイラでモジュールを有効にする

Visual Studio 2019 バージョン 16.2 では、モジュールは Microsoft C++ コンパイラで完全には実装されていません。 モジュール機能を使用して、単一パーティションのモジュールを作成したり、Microsoft が提供する標準ライブラリ モジュールをインポートしたりできます。 モジュールのサポートを有効にするには[、/実験的:モジュール](../build/reference/experimental-module.md)と[/std:c++ latest](../build/reference/std-specify-language-standard-version.md)を使用してコンパイルします。 Visual Studio プロジェクトで、**ソリューション エクスプローラー**でプロジェクト ノードを右クリックし、[**プロパティ ]** をクリックします。 [**構成]** ドロップダウンを **[すべての構成]** に設定し、[**構成プロパティ** > **C/C++** > **言語** > **有効 C++ モジュール (試験的)]** を選択します。

モジュールとそれを使用するコードは、同じコンパイラ オプションでコンパイルする必要があります。

## <a name="consume-the-c-standard-library-as-modules"></a>C++ 標準ライブラリをモジュールとして使用する

C++ 20 標準では指定されていませんが、Microsoft では C++ 標準ライブラリの実装をモジュールとしてインポートできます。 C++ 標準ライブラリをヘッダー ファイルを通じて#includingするのではなく、モジュールとしてインポートすると、プロジェクトのサイズに応じてコンパイル時間を短縮できる可能性があります。 ライブラリは、次のモジュールにコンポーネント化されます。

- std.regex は、ヘッダー\<正規表現の>の内容を提供します。
- std.filesystem は、ヘッダー\<ファイルシステムのコンテンツを提供>
- std.memory はヘッダー\<メモリの内容を提供>
- \<std.threading は、ヘッダーのアトミック>、condition_variable>、\<将来の>、\<ミューテックス>、shared_mutex>、\<\<およびスレッドの内容を\<提供>
- std.core は C++ 標準ライブラリの他のすべてを提供します。

これらのモジュールを使用するには、ソース コード ファイルの先頭にインポート宣言を追加するだけです。 次に例を示します。

```cpp
import std.core;
import std.regex;
```

Microsoft 標準ライブラリ モジュールを使用するには[、/EHsc](../build/reference/eh-exception-handling-model.md)および[/MD](../build/reference/md-mt-ld-use-run-time-library.md)オプションを使用してプログラムをコンパイルします。

## <a name="basic-example"></a>基本的な例

次の例は、ソース ファイルの**Foo.ixx**という単純なモジュール定義を示しています。 Visual Studio のモジュール インターフェイス ファイルには **.ixx**拡張子が必要です。 この例では、インターフェイス ファイルには、関数定義と宣言が含まれています。 ただし、定義は、(後の例で示すように) 1 つ以上の別々のファイルに配置することもできます。 **エクスポート モジュール Foo**ステートメントは、このファイルが という`Foo`モジュールのプライマリ インターフェイスであることを示します。 **エクスポート**修飾子 on`f()`は、別のプログラムまたはモジュール`Foo`によってインポートされるときに、この関数が表示されることを示します。 モジュールが名前空間`Bar`を参照していることに注意してください。

```cpp
export module Foo;

#define ANSWER 42

namespace Bar
{
   int f_internal() {
        return ANSWER;
      }

   export int f() {
      return f_internal();
   }
}
```

**MyProgram.cpp**ファイルは **、インポート**宣言を使用して、 によって`Foo`エクスポートされる名前にアクセスします。 名前`Bar`はここに表示されますが、すべてのメンバーが表示されるわけではありません。 また、マクロ`ANSWER`は表示されません。

```cpp

import Foo;
import std.core;

using namespace std;

int main()
{
   cout << "The result of f() is " << Bar::f() << endl; // 42
   // int i = Bar::f_internal(); // C2039
   // int j = ANSWER; //C2065
}

```

インポート宣言は、グローバル スコープでのみ使用できます。

## <a name="implementing-modules"></a>モジュールの実装

名前をエクスポートし、すべての関数と型の実装を含む単一のインターフェイス ファイル (.ixx) を使用してモジュールを作成できます。 また、.h ファイルと .cpp ファイルの使用方法と同様に、実装を 1 つ以上の個別の実装ファイルに配置することもできます。 **export**キーワードは、インターフェイス ファイルでのみ使用されます。 実装ファイルは別のモジュールを**インポート**できますが、名前を**エクスポート**することはできません。 実装ファイルには、任意の拡張子を付けて名前を付けてもよい。 インターフェイス ファイルと、それを裏付ける実装ファイルのセットは *、モジュールユニット*と呼ばれる特殊な種類の翻訳単位として扱われます。 実装ファイルで宣言された名前は、同じモジュールユニット内の他のすべてのファイルに自動的に表示されます。

より大きなモジュールの場合は、モジュールを*パーティション*と呼ばれる複数のモジュール単位に分割できます。 各パーティションは、1 つ以上の実装ファイルによってバックアップされたインターフェイス ファイルで構成されます。 (Visual Studio 2019 バージョン 16.2 では、パーティションはまだ完全には実装されていません。

## <a name="modules-namespaces-and-argument-dependent-lookup"></a>モジュール、名前空間、および引数に依存するルックアップ

モジュール内の名前空間の規則は、他のコードと同じです。 名前空間内の宣言がエクスポートされる場合、外側の名前空間 (エクスポートされていないメンバーを除く) も暗黙的にエクスポートされます。 名前空間が明示的にエクスポートされた場合、その名前空間定義内のすべての宣言がエクスポートされます。

インポートする変換単位でオーバーロード解決に対して引数依存ルックアップを実行する場合、コンパイラは、同じ変換単位 (モジュール インターフェイスを含む) で宣言されている関数を、関数の引数の型が定義されている関数と見なします。

### <a name="module-partitions"></a>モジュール パーティション

> [!NOTE]
> このセクションは、完全性を目的として提供されています。 パーティションはまだ Microsoft C++ コンパイラに実装されていません。

モジュールは、それぞれ 1 つのインターフェイス ファイルと 0 個以上の実装ファイルで構成される*パーティション*にコンポーネント化できます。 モジュール パーティションはモジュールに似ていますが、モジュール全体のすべての宣言の所有権を共有する点が異なっています。 パーティション・インターフェース・ファイルによってエクスポートされるすべての名前は、プライマリ・インターフェース・ファイルによってインポートおよび再エクスポートされます。 パーティションの名前は、モジュール名の後にコロンを付ける必要があります。 いずれかのパーティションの宣言は、モジュール全体で参照できます。 1 つの定義規則 (ODR) エラーを回避するために、特別な予防措置は必要ありません。 あるパーティションで名前 (関数、クラスなど) を宣言し、別のパーティションで定義できます。 パーティション実装ファイルは、次のように始まります。

```cpp
module Foo:part1
```

パーティションインターフェイスファイルは次のように始まります。

```cpp
export module Foo:part1
```

別のパーティションの宣言にアクセスするには、パーティションはそれをインポートする必要がありますが、使用できるのはモジュール名ではなくパーティション名だけです。

```cpp
module Foo:part2;
import :part1;
```

プライマリ インターフェイス ユニットは、次のように、モジュールのすべてのインターフェイス パーティション ファイルをインポートおよび再エクスポートする必要があります。

```cpp
export import :part1
export import :part2
...
```

プライマリ インターフェイス ユニットはパーティション実装ファイルをインポートできますが、これらのファイルは名前をエクスポートできないため、エクスポートできません。 これにより、モジュールは実装の詳細をモジュール内部に保持できます。

## <a name="modules-and-header-files"></a>モジュールとヘッダー ファイル

モジュール宣言の前にディレクティブを配置することで、モジュール ソース`#include`ファイルにヘッダー ファイルを含めることができます。 これらのファイルは *、グローバル モジュール フラグメント*に含まれると見なされます。 モジュールは、明示的に含まれるヘッダー内の*グローバル モジュール フラグメント*内の名前のみを表示できます。 グローバル モジュール フラグメントには、実際に使用されているシンボルのみが含まれます。

```cpp
// MyModuleA.cpp

#include "customlib.h"
#include "anotherlib.h"

import std.core;
import MyModuleB;

//... rest of file
```

従来のヘッダー ファイルを使用して、インポートするモジュールを制御できます。

```cpp
// MyProgram.h
import std.core;
#ifdef DEBUG_LOGGING
import std.filesystem;
#endif
```

### <a name="imported-header-files"></a>インポートされたヘッダー ファイル

> [!NOTE]
> このセクションは情報提供のみを行います。 レガシ インポートは、まだ Microsoft C++ コンパイラに実装されていません。

一部のヘッダーは、**インポート**キーワードを使用して持ち込むのが許可される自己完結型です。 インポートされたヘッダーとインポートされたモジュールの主な違いは、インポート ステートメントの直後に、ヘッダー内のプリプロセッサ定義がインポートプログラムで表示される点です。 (そのヘッダーに含まれるファイルのプリプロセッサ定義は表示*されません*。

```cpp
import <vector>
import "myheader.h"
```

## <a name="see-also"></a>関連項目

[モジュール、インポート、エクスポート](import-export-module.md)
