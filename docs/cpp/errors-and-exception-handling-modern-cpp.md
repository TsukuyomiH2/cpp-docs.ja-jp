---
title: 例外とエラー処理に関する最新の C++ のベストプラクティス
description: 最新の C++ では、エラーコードに対する例外的なプログラミングスタイルがサポートされています。
ms.date: 08/24/2020
ms.topic: conceptual
ms.assetid: a6c111d0-24f9-4bbb-997d-3db4569761b7
ms.openlocfilehash: b402c93ea5af3cc7dab418b6dea58446ae300c67
ms.sourcegitcommit: efc8c32205c9d610f40597556273a64306dec15d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/26/2020
ms.locfileid: "88898369"
---
# <a name="modern-c-best-practices-for-exceptions-and-error-handling"></a>例外とエラー処理に関する最新の C++ のベストプラクティス

最新の C++ のほとんどのシナリオでは、論理エラーとランタイム エラーの両方を報告および処理する方法として、例外を使用することが推奨されます。 特に、スタックに、エラーを検出した関数と、エラーを処理するコンテキストを持つ関数との間に複数の関数呼び出しが含まれている可能性がある場合に当てはまります。 例外は、エラーを検出して情報を呼び出し履歴に渡すコードに関する、正しく定義された正式な方法を提供します。

## <a name="use-exceptions-for-exceptional-code"></a>例外的なコードに例外を使用する

多くの場合、プログラムエラーは2つのカテゴリに分類されます。たとえば、"範囲外のインデックス" エラーなど、プログラミングの誤りに起因する論理エラーです。 さらに、"ネットワークサービスを利用できません" というエラーなど、プログラマの制御を超える実行時エラーが発生します。 C スタイル プログラミングと COM では、特定の関数のエラー コードまたはステータス コードを表す値を返すか、エラーが報告されたかどうかを確認するすべての関数呼び出しの後に呼び出し元がオプションで取得する可能性があるグローバル変数を設定することで、エラー レポートが管理されます。 たとえば、COM プログラミングでは、HRESULT 戻り値を使用して、エラーを呼び出し元に通知します。 また、Win32 API には、 `GetLastError` 呼び出し履歴によって報告された最後のエラーを取得する関数があります。 どちらの場合も、呼び出し元がコードを認識し、適切に応答することにかかっています。 呼び出し元がエラーコードを明示的に処理しない場合、プログラムは警告なしにクラッシュする可能性があります。 または、不適切なデータを使用して引き続き実行され、正しくない結果が生成される可能性があります。

最新の C++ では、次の理由で例外が推奨されます。

- 例外は、エラー状態の認識と処理を呼び出し元コードに強制します。 ハンドルされない例外は、プログラムの実行を停止します。

- 例外は、エラーを処理できる呼び出し履歴内のポイントにジャンプします。 中間関数は、例外を伝達することができます。 他のレイヤーとの調整は必要ありません。

- 例外スタックアンワインド機構は、明確に定義された規則に従って、例外がスローされた後にスコープ内のすべてのオブジェクトを破棄します。

- 例外によって、エラーを検出したコードとエラーを処理するコードを明確な区別することができるようになります。

簡略化された次の例は、C++ で例外をスローしてキャッチするのに必要な構文を示しています。

```cpp
#include <stdexcept>
#include <limits>
#include <iostream>

using namespace std;

void MyFunc(int c)
{
    if (c > numeric_limits< char> ::max())
        throw invalid_argument("MyFunc argument too large.");
    //...
}

int main()
{
    try
    {
        MyFunc(256); //cause an exception to throw
    }

    catch (invalid_argument& e)
    {
        cerr << e.what() << endl;
        return -1;
    }
    //...
    return 0;
}
```

C++ での例外は、C# や Java などの言語に似ています。 ブロックでは **`try`** 、例外が*スロー*された場合、 *caught*型が **`catch`** 例外の型と一致する最初の関連付けられたブロックによってキャッチされます。 言い換えると、実行は **`throw`** ステートメントからステートメントにジャンプし **`catch`** ます。 使用可能な catch ブロックが見つからない場合、`std::terminate` が呼び出されてプログラムが終了します。 C++ では、どの種類もスローされる可能性があります。ただし、`std::exception` から直接または間接的に派生した型をスローすることをお勧めします。 前の例では、ヘッダーファイルの標準ライブラリに例外の種類とし [`invalid_argument`](../standard-library/invalid-argument-class.md) てが定義されてい [`<stdexcept>`](../standard-library/stdexcept.md) ます。 C++ では、 **`finally`** 例外がスローされた場合にすべてのリソースが解放されるように、ブロックを提供または要求する必要はありません。 スマート ポインターを使用する Resource Acquisition Is Initialization (RAII) の表現形式には、リソース クリーンアップのための必須機能が用意されています。 詳細については、「 [方法: 例外の安全性を](how-to-design-for-exception-safety.md)確保する」を参照してください。 C++ のスタックアンワインド機構の詳細については、「 [例外とスタックアンワインド](exceptions-and-stack-unwinding-in-cpp.md)」を参照してください。

## <a name="basic-guidelines"></a>基本的なガイドライン

堅牢なエラー処理は、どのプログラミング言語でも簡単ではありません。 例外には、適切なエラー処理をサポートする機能がいくつか用意されていますが、すべての処理を自動的に行うことはできません。 例外機構の利点を理解するため、コードをデザインするときに例外を念頭に置いてください。

- 発生することのないエラーをチェックするには、アサートを使用します。 発生する可能性があるエラー (たとえば、パブリック関数のパラメーターにおける入力検証のエラーなど) をチェックするには、例外を使用します。 詳細については、「 [例外とアサーション](#exceptions_versus_assertions) 」セクションを参照してください。

- エラーを処理するコードが、1つ以上の介在する関数呼び出しによってエラーを検出したコードから分離されている場合は、例外を使用します。 エラーを処理するコードが、エラーを検出したコードに密に結合されている場合、パフォーマンスクリティカルなループではなくエラーコードを使用するかどうかを検討します。

- 例外をスローまたは伝達する可能性のある関数ごとに、strong 保証、basic 保証、nothrow (noexcept) 保証の 3 つの例外保証のいずれかを指定します。 詳細については、「 [方法: 例外の安全性を](how-to-design-for-exception-safety.md)確保する」を参照してください。

- 値渡しで例外をスローし、参照渡しでそれらの例外をキャッチします。 処理できない例外をキャッチしないでください。

- C++11 で非推奨とされた例外指定を使用しないでください。 詳細については、「[例外の `noexcept` 仕様と](#exception_specifications_and_noexcept)セクション」を参照してください。

- 標準ライブラリの例外の種類は、適用するときに使用します。 [ `exception` クラス](../standard-library/exception-class.md)の階層からカスタムの例外の種類を派生させます。

- 例外がデストラクターまたはメモリ解放関数からエスケープしないようにしてください。

## <a name="exceptions-and-performance"></a>例外とパフォーマンス

例外がスローされない場合は、例外メカニズムのパフォーマンスコストが最小限に抑えられます。 例外がスローされた場合、スタックの走査およびアンワインドによるパフォーマンスの低下は、関数呼び出しとほぼ同程度です。 ブロックの入力後に呼び出し履歴を追跡するには、追加のデータ構造が必要です **`try`** 。例外がスローされた場合は、スタックをアンワインドするために追加の手順が必要になります。 ただし、ほとんどのシナリオでは、パフォーマンスとメモリフットプリントのコストは重要ではありません。 パフォーマンスに対する例外の悪影響は、メモリが制約されたシステムでのみ重要になる可能性があります。 または、パフォーマンスが重要なループでは、エラーが定期的に発生する可能性があり、それを処理するコードとそれを報告するコードの間に密結合があります。 いずれの場合も、プロファイリングや測定を行わずに例外の実際の影響を把握することは不可能です。 影響が大きくなるまれな場合でも、優れたデザインの例外ポリシーにより実現する正確さの向上、管理の容易さ、他の利点と比較することができます。

## <a name="exceptions-versus-assertions"></a><a name="exceptions_versus_assertions"></a> 例外とアサーション

例外とアサーションは、プログラムのランタイム エラーを検出する 2 つの別個の機構です。 ステートメントを使用して `assert` 、開発中に、すべてのコードが正しい場合に true にならない条件をテストします。 例外を使用してこのようなエラーを処理することはありません。これは、コード内のコードを修正する必要があることを示しているためです。 プログラムが実行時に回復する必要がある条件を表すものではありません。 は、 `assert` デバッガーでプログラムの状態を調べることができるように、ステートメントで実行を停止します。 例外は、最初の適切な catch ハンドラーから実行を継続します。 コードが正しい場合でも実行時に発生する可能性があるエラー条件 ("ファイルが見つかりません" や "メモリ不足" など) をチェックするには、例外を使用します。 復旧によってメッセージがログに出力され、プログラムが終了しただけであっても、例外はこれらの条件を処理できます。 必ず、例外を使用してパブリックの関数への引数をチェックしてください。 関数にエラーがない場合でも、ユーザーが渡す引数を完全に制御できないことがあります。

## <a name="c-exceptions-versus-windows-seh-exceptions"></a>C++ 例外と Windows SEH 例外

C プログラムと C++ プログラムのどちらでも、Windows オペレーティング システムの構造化例外処理 (SEH) 機構を使用できます。 SEH の概念は、C++ 例外の概念と似ていますが、SEH では、およびではなく、、の各構造体を使用する点が異なり **`__try`** **`__except`** **`__finally`** **`try`** **`catch`** ます。 Microsoft C++ コンパイラ (MSVC) では、C++ 例外が SEH に対して実装されています。 ただし、C++ コードを記述するときは、C++ 例外構文を使用してください。

SEH の詳細については、「 [構造化例外処理 (C/c + +)](structured-exception-handling-c-cpp.md)」を参照してください。

## <a name="exception-specifications-and-noexcept"></a><a name="exception_specifications_and_noexcept"></a> 例外の指定と `noexcept`

例外指定は、関数がスローする可能性がある例外を指定する方法として C++ に導入されました。 ただし、実際には例外指定に問題があることがわかったため、C++11 ドラフト標準では非推奨とされます。 例外の指定は使用しないことをお勧めし **`throw`** `throw()` ます。これは、関数が例外をエスケープしないことを示します。 非推奨の形式の例外指定を使用する必要がある場合は `throw( type-name )` 、MSVC のサポートが制限されます。 詳細については、「 [例外の指定 (throw)](exception-specifications-throw-cpp.md)」を参照してください。 指定子は、の **`noexcept`** 代わりに、c++ 11 で導入されました `throw()` 。

## <a name="see-also"></a>関連項目

[方法: 例外的なコードと非例外的なコードの間のインターフェイス](../cpp/how-to-interface-between-exceptional-and-non-exceptional-code.md)<br/>
[C++ 言語リファレンス](../cpp/cpp-language-reference.md)<br/>
[C++ 標準ライブラリ](../standard-library/cpp-standard-library-reference.md)
