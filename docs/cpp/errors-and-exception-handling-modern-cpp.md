---
title: 例外とエラー処理に関する最新の C++ のベストプラクティス
ms.date: 11/19/2019
ms.topic: conceptual
ms.assetid: a6c111d0-24f9-4bbb-997d-3db4569761b7
ms.openlocfilehash: 6995867813bfb65848f179cb56b358de68fa63f2
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/27/2020
ms.locfileid: "87227531"
---
# <a name="modern-c-best-practices-for-exceptions-and-error-handling"></a>例外とエラー処理に関する最新の C++ のベストプラクティス

最新の C++ のほとんどのシナリオでは、論理エラーとランタイム エラーの両方を報告および処理する方法として、例外を使用することが推奨されます。 これは特に、エラーを検出した関数からその処理方法を認識するためのコンテキストを持つ関数までの間に、複数の関数がスタックに含まれる可能性がある場合に当てはまります。 例外は、エラーを検出して情報を呼び出し履歴に渡すコードに関する、正しく定義された正式な方法を提供します。

プログラム エラーは通常 2 つのカテゴリに分類されます。1 つは、プログラミングの間違いにより生じる論理エラー ("範囲外のインデックス" エラーなど) で、もう 1 つはプログラマの種類に分ける通常は: 誤り、たとえば、「有効範囲外のインデックス」エラーのプログラムによる論理エラー、およびプログラマが制御できないランタイム エラー ("ネットワーク サービスが利用不可" エラーなど) です。 C スタイル プログラミングと COM では、特定の関数のエラー コードまたはステータス コードを表す値を返すか、エラーが報告されたかどうかを確認するすべての関数呼び出しの後に呼び出し元がオプションで取得する可能性があるグローバル変数を設定することで、エラー レポートが管理されます。 たとえば、COM プログラミングは HRESULT 戻り値を使用してエラーを呼び出し元に通知します。また、Win32 API には、呼び出し履歴により報告された最後のエラーを取得する GetLastError 関数があります。 どちらの場合も、呼び出し元がコードを認識し、適切に応答することにかかっています。 呼び出し元が明示的にエラー コードを処理しない場合、プログラムが警告なしにクラッシュしたり、不適切なデータで実行を続けて間違った結果が生成される可能性があります。

最新の C++ では、次の理由で例外が推奨されます。

- 例外は、エラー状態の認識と処理を呼び出し元コードに強制します。 ハンドルされない例外は、プログラムの実行を停止します。

- 例外は、エラーを処理できる呼び出し履歴内のポイントにジャンプします。 中間関数は、例外を伝達することができます。 他のレイヤーに合わせる必要はありません。

- 例外のスタック アンワインド機構は、例外のスロー後に明確に定義された規則に従ってスコープ内のすべてのオブジェクトを破棄します。

- 例外によって、エラーを検出したコードとエラーを処理するコードを明確な区別することができるようになります。

簡略化された次の例は、C++ で例外をスローしてキャッチするのに必要な構文を示しています。

```cpp

#include <stdexcept>
#include <limits>
#include <iostream>

using namespace std;

void MyFunc(int c)
{
    if (c > numeric_limits< char> ::max())
        throw invalid_argument("MyFunc argument too large.");
    //...
}

int main()
{
    try
    {
        MyFunc(256); //cause an exception to throw
    }

    catch (invalid_argument& e)
    {
        cerr << e.what() << endl;
        return -1;
    }
    //...
    return 0;
}
```

C++ の例外は、C# や Java などの言語と似ています。 ブロックでは **`try`** 、例外が*スロー*された場合、 *caught*型が **`catch`** 例外の型と一致する最初の関連付けられたブロックによってキャッチされます。 言い換えると、実行は **`throw`** ステートメントからステートメントにジャンプし **`catch`** ます。 使用可能な catch ブロックが見つからない場合、`std::terminate` が呼び出されてプログラムが終了します。 C++ では、どの種類もスローされる可能性があります。ただし、`std::exception` から直接または間接的に派生した型をスローすることをお勧めします。 前の例では、ヘッダーファイルの標準ライブラリで、例外の種類として[invalid_argument](../standard-library/invalid-argument-class.md)が定義されてい [\<stdexcept>](../standard-library/stdexcept.md) ます。 C++ では、例外がスローされた場合にすべてのリソースが解放されるようにするために、 **finally**ブロックが提供されているわけではありません。 スマート ポインターを使用する Resource Acquisition Is Initialization (RAII) の表現形式には、リソース クリーンアップのための必須機能が用意されています。 詳細については、「[方法: 例外の安全性を](how-to-design-for-exception-safety.md)確保する」を参照してください。 C++ のスタックアンワインド機構の詳細については、「[例外とスタックアンワインド](exceptions-and-stack-unwinding-in-cpp.md)」を参照してください。

## <a name="basic-guidelines"></a>基本的なガイドライン

堅牢なエラー処理は、どのプログラミング言語でも簡単ではありません。 例外には、適切なエラー処理をサポートする機能がいくつか用意されていますが、すべての処理を自動的に行うことはできません。 例外機構の利点を理解するため、コードをデザインするときに例外を念頭に置いてください。

- 発生することのないエラーをチェックするには、アサートを使用します。 発生する可能性があるエラー (たとえば、パブリック関数のパラメーターにおける入力検証のエラーなど) をチェックするには、例外を使用します。 詳細については、「**例外とアサーション**」を参照してください。

- 例外は、エラーを処理するコードが、1 つ以上の介在する関数呼び出しによりエラーを検出したコードから切り離されている可能性がある場合に使用します。 エラーを処理するコードが、エラーを検出したコードに密に結合されている場合は、パフォーマンスが重要なループで代わりにエラー コードを使用するかどうかを検討します。

- 例外をスローまたは伝達する可能性のある関数ごとに、strong 保証、basic 保証、nothrow (noexcept) 保証の 3 つの例外保証のいずれかを指定します。 詳細については、「[方法: 例外の安全性を](how-to-design-for-exception-safety.md)確保する」を参照してください。

- 値渡しで例外をスローし、参照渡しでそれらの例外をキャッチします。 処理できない例外をキャッチしないでください。

- C++11 で非推奨とされた例外指定を使用しないでください。 詳細については、「**例外の指定」および「noexcept**」を参照してください。

- 標準ライブラリの例外の種類は、適用するときに使用します。 [例外クラス](../standard-library/exception-class.md)階層からカスタム例外の種類を派生させます。

- 例外がデストラクターまたはメモリ解放関数からエスケープしないようにしてください。

## <a name="exceptions-and-performance"></a>例外とパフォーマンス

例外がスローされない場合、例外機構によるパフォーマンスの低下はごくわずかです。 例外がスローされた場合、スタックの走査およびアンワインドによるパフォーマンスの低下は、関数呼び出しとほぼ同程度です。 ブロックの入力後に呼び出し履歴を追跡するには、追加のデータ構造が必要です **`try`** 。例外がスローされた場合は、スタックをアンワインドするために追加の手順が必要になります。 ただし、ほとんどの場合、パフォーマンスの低下とメモリ使用量の増加はそれほど大きくありません。 パフォーマンスに対する例外の悪影響は、メモリ制約が非常に大きいシステムでのみ大きくなる可能性があります。エラーが定期的に発生する可能性が高く、エラーを処理するコードがエラーを報告したコードに密に結合されている、パフォーマンスが重要なループでも大きくなる可能性があります。 いずれの場合も、プロファイリングや測定を行わずに例外の実際の影響を把握することは不可能です。 影響が大きくなるまれな場合でも、優れたデザインの例外ポリシーにより実現する正確さの向上、管理の容易さ、他の利点と比較することができます。

## <a name="exceptions-vs-assertions"></a>例外とアサーション

例外とアサーションは、プログラムのランタイム エラーを検出する 2 つの別個の機構です。 開発時にアサートを使用して、すべてのコードが正しい場合は true になることがない条件をテストします。 エラーはコード内に修正が必要な箇所があることを示しており、プログラムが実行時から回復する必要がある条件を表しているわけではないため、例外を使用してそのようなエラーを処理するポイントはありません。 デバッガーでプログラムの状態を検査できるように、アサートはステートメントで実行を停止します。例外は、該当する最初のキャッチ ハンドラーから実行を続行します。 コードが正しい場合でも実行時に発生する可能性があるエラー条件 ("ファイルが見つかりません" や "メモリ不足" など) をチェックするには、例外を使用します。 回復によりログにメッセージが出力され、プログラムが終了するだけの場合でも、これらの条件から回復することができます。 必ず、例外を使用してパブリックの関数への引数をチェックしてください。 関数にエラーがない場合でも、ユーザーが渡す引数を完全に制御できないことがあります。

## <a name="c-exceptions-versus-windows-seh-exceptions"></a>C++ 例外と Windows SEH 例外

C プログラムと C++ プログラムのどちらでも、Windows オペレーティング システムの構造化例外処理 (SEH) 機構を使用できます。 SEH の概念は、C++ 例外の概念と似ていますが、SEH では、およびではなく **__try**、 **`__except`** 、およびの各構造体を使用する点が異なり **`__finally`** **`try`** **`catch`** ます。 Microsoft C++ コンパイラ (MSVC) では、C++ 例外が SEH に対して実装されています。 ただし、C++ コードを記述するときは、C++ 例外構文を使用してください。

SEH の詳細については、「[構造化例外処理 (C/c + +)](structured-exception-handling-c-cpp.md)」を参照してください。

## <a name="exception-specifications-and-noexcept"></a>例外指定と noexcept

例外指定は、関数がスローする可能性がある例外を指定する方法として C++ に導入されました。 ただし、実際には例外指定に問題があることがわかったため、C++11 ドラフト標準では非推奨とされます。 例外の指定は使用しないことをお勧めし `throw()` ます。これは、関数がエスケープする例外を許可しないことを示します。 型の例外指定を使用する必要がある場合は `throw(` *type* `)` 、標準の MSVC 逸脱を特定の方法で使用することに注意してください。 詳細については、「[例外の指定 (throw)](exception-specifications-throw-cpp.md)」を参照してください。 指定子は、の **`noexcept`** 代わりに、c++ 11 で導入されました `throw()` 。

## <a name="see-also"></a>関連項目

[方法: 例外的なコードと非例外的なコードの間のインターフェイス](../cpp/how-to-interface-between-exceptional-and-non-exceptional-code.md)<br/>
[C++ 言語リファレンス](../cpp/cpp-language-reference.md)<br/>
[C++ 標準ライブラリ](../standard-library/cpp-standard-library-reference.md)
