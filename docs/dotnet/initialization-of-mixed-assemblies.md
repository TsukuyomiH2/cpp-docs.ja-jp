---
title: 混在アセンブリの初期化
ms.date: 03/09/2018
helpviewer_keywords:
- mixed assemblies [C++], loader lock
- loader lock [C++]
- initializing mixed assemblies
- deadlocks [C++]
- .cctor [C++]
- custom locales [C++]
- mixed assemblies [C++], initilizing
ms.assetid: bfab7d9e-f323-4404-bcb8-712b15f831eb
ms.openlocfilehash: 35dd47bd87c278d60fc616dca854bf843acc7c57
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/15/2019
ms.locfileid: "79544514"
---
# <a name="initialization-of-mixed-assemblies"></a>混在アセンブリの初期化

`DllMain`中にコードを実行する場合、Windows 開発者は常にローダーロックに注意する必要があります。 ただし、/clr 混在モードのアセンブリをC++扱う場合は、いくつかの追加の問題を考慮する必要があります。

[DllMain](/windows/win32/Dlls/dllmain)内のコードは、.Net 共通言語ランタイム (CLR) にアクセスできません。 つまり、`DllMain` は、直接または間接的にマネージ関数を呼び出す必要がありません。`DllMain`では、マネージコードを宣言または実装する必要はありません。また、`DllMain`内では、ガベージコレクションも自動ライブラリ読み込みも行われません。

## <a name="causes-of-loader-lock"></a>ローダー ロックの原因

.NET プラットフォームの導入により、実行モジュール (EXE または DLL) を読み込むための2つの異なるメカニズムがあります。1つは Windows 用で、もう1つはアンマネージモジュールで使用されます。もう1つは、.NET アセンブリを読み込む CLR 用です。 混在モード DLL 読み込み時の問題は、Microsoft Windows OS ローダーを中心に発生します。

.NET のコンストラクトだけを含むアセンブリをプロセスに読み込んだ場合、CLR ローダーは、必要なすべての読み込みタスクおよび初期化タスクを自分で実行できます。 しかし、混在アセンブリの場合は、ネイティブ コードやデータが含まれている可能性があるため、Windows ローダーも使用する必要があります。

Windows ローダーは、初期化される前に、その DLL 内のコードまたはデータにアクセスできないことを保証します。また、コードが部分的に初期化されている間に、コードが冗長に DLL を読み込むことはできません。 これを行うために、Windows ローダーは、モジュールの初期化中に安全でないアクセスを防止する、プロセスグローバルのクリティカルセクション (多くの場合 "ローダーロック" と呼ばれます) を使用します。 結果として、読み込みプロセスでは、典型的な多くのデッドロックのシナリオが発生しやすくなります。 混在アセンブリの場合、次の 2 つのシナリオで、デッドロックの危険性が高くなります。

- まず、ローダーロックが保持されているときにユーザーが Microsoft 中間言語 (MSIL) にコンパイルされた関数を実行しようとすると (`DllMain` または静的初期化子など)、デッドロックが発生する可能性があります。 MSIL 関数が、読み込まれていないアセンブリ内の型を参照している場合を考えてみます。 CLR は、そのアセンブリを自動的に読み込もうとします。これにより、Windows ローダーはローダー ロックをブロックすることが必要になる場合があります。 呼び出しシーケンスの前にコードによってローダーロックが既に保持されているため、デッドロックが発生します。 ただし、ローダーロックの下で MSIL を実行すると、デッドロックが発生することは保証されないため、このシナリオの診断や修正が困難になります。 参照される型の DLL にネイティブコンストラクトが含まれておらず、そのすべての依存関係にネイティブコンストラクトが含まれていない場合など、状況によっては、参照された型の .NET アセンブリを読み込むために Windows ローダーは必要ありません。 さらに、必要なアセンブリやその混在するネイティブまたは .NET の依存関係は、既に他のコードによって読み込まれている可能性があります。 その結果、デッドロックの発生を予測することが難しくなります。また、デッドロック状態が、対象となるコンピューターの構成によって異なる場合もあります。

- 2つ目は、.NET Framework のバージョン1.0 および1.1 で Dll を読み込むときに、CLR はローダーロックが保持されていないと想定し、ローダーロックの下では無効ないくつかのアクションを実行しました。 ローダーロックが保持されていないことを前提として、純粋な .NET Dll に対しては有効な前提としています。ただし、混在する Dll はネイティブの初期化ルーチンを実行するため、ネイティブの Windows ローダーが必要であり、そのためにローダーロックが必要になります。 したがって、開発者が DLL の初期化中に MSIL 関数を実行しない場合でも、.NET Framework Version 1.0 および 1.1 では、デッドロックが確定的でない場合にデッドロックが発生する可能性がわずかに残っていました。

混在モード DLL の読み込みプロセスで、このような確定的でない場合の問題はなくなりました。 次のような変更が行われました。

- CLR が、混在モード DLL の読み込み時に誤った想定を行わなくなりました。

- アンマネージド初期化とマネージド初期化が、2 つの独立した段階で実行されます。 アンマネージ初期化は最初に (DllMain を使用して) 行われ、その後、を通じてマネージ初期化が行われます。NET でサポートされている `.cctor` コンストラクト。 後者は、 **/Zl** または **/NODEFAULTLIB** を使用している場合を除いて、ユーザーが意識する必要はありません。 詳細については、「[/NODEFAULTLIB (Ignore Libraries)](../build/reference/nodefaultlib-ignore-libraries.md) 」と「 [/Zl (Omit Default Library Name)](../build/reference/zl-omit-default-library-name.md) 」を参照してください。

ローダー ロックは依然として発生することがありますが、再現性があり、検出されるようになりました。 `DllMain` に MSIL 命令が含まれている場合、コンパイラは警告[コンパイラの警告 (レベル 1) C4747](../error-messages/compiler-warnings/compiler-warning-level-1-c4747.md)を生成します。 さらに、ローダー ロックの状況下で MSIL が実行されようとしている場合、CRT または CLR は検出とレポートを試みます。 CRT による検出の結果、実行時の診断として C ランタイム エラー R6033 が発生します。

このドキュメントの残りの部分では、MSIL がローダー ロックの状況で実行できる他のシナリオ、各シナリオでの問題に対する解決策、デバッグ技術について説明します。

## <a name="scenarios-and-workarounds"></a>シナリオと回避策

ローダー ロックが発生している場合でも、ユーザー コードが MSIL を実行できる状況がいくつかあります。 開発者は、そのような状況のそれぞれについて、ユーザー コードの実装が MSIL 命令を実行しないようにする必要があります。 以下では、最も一般的な事例で問題を解決する方法を考えつつ、すべての可能性について説明します。

### <a name="dllmain"></a>DllMain

`DllMain` 関数は、DLL 用のユーザー定義のエントリポイントです。 ユーザーがそれ以外の関数を指定しない限り、プロセスやスレッドを DLL にアタッチするか、プロセスやスレッドを DLL からデタッチするたびに、 `DllMain` が呼び出されます。 この呼び出しは、ローダー ロックが保持されているときに行われる可能性もあるため、ユーザー指定の `DllMain` 関数は MSIL にコンパイルしないでください。 さらに、コール ツリー内で `DllMain` をルートにしている関数も、MSIL にコンパイルできません。 この問題を解決するには、 `DllMain` が定義されているコード ブロックを、#pragma `unmanaged`で修飾する必要があります。 `DllMain` によって呼び出されるすべての関数にも、同じ処理を行う必要があります。

このような関数で、他の呼び出しコンテキスト用に MSIL 実装を必要とする関数を呼び出す必要がある場合には、同じ関数の .NET バージョンとネイティブ バージョンを重複して作成する方法を使用できます。

また、 `DllMain` が不要な場合またはローダー ロックの状況でこれを実行する必要がない場合は、ユーザー指定の `DllMain` の実装を削除できます。そうすることで、問題が発生しなくなります。

DllMain で直接 MSIL を実行しようとすると、 [Compiler Warning (level 1) C4747](../error-messages/compiler-warnings/compiler-warning-level-1-c4747.md) が発生します。 ただし、コンパイラは、DllMain が別のモジュール内の関数を呼び出し、その関数が MSIL を実行するような事例は検出できません。

このシナリオの詳細については、「[診断に対する障害](#impediments-to-diagnosis)」を参照してください。

### <a name="initializing-static-objects"></a>静的オブジェクトの初期化

静的オブジェクトを初期化すると、動的初期化子が必要な場合にデッドロックが発生することがあります。 コンパイル時に既知の値に静的変数が割り当てられている場合など、単純なケースでは、動的な初期化は必要ないため、デッドロックのリスクはありません。 ただし、関数呼び出し、コンストラクター呼び出し、またはコンパイル時に評価できない式によって初期化される静的変数は、モジュールの初期化中にコードを実行する必要があります。

動的な初期化を必要とする静的初期化子の例 (関数呼び出し、オブジェクト構築、およびポインター初期化) を次のコードに示します。 (これらの例は静的ではありませんが、グローバルスコープで定義されていると見なされますが、これは同じ効果があります)。

```cpp
// dynamic initializer function generated
int a = init();
CObject o(arg1, arg2);
CObject* op = new CObject(arg1, arg2);
```

このデッドロックの危険性は、該当モジュールが **/clr** を指定してコンパイルされているかどうかと MSIL が実行されるかどうかによって決まります。 具体的には、静的変数を **/clr** を指定せずにコンパイルする場合 (または静的変数が #pragma `unmanaged` ブロックに存在する場合) に、その変数の初期化に必要な動的初期化子によって MSIL 命令が実行されると、デッドロックが発生することがあります。 これは、 **/clr**を使用せずにコンパイルされたモジュールの場合、DllMain によって静的変数の初期化が実行されるためです。 これに対し、 **/clr**でコンパイルされた静的変数は、アンマネージ初期化段階が完了し、ローダーロックが解除された後に、`.cctor`によって初期化されます。

静的変数の動的な初期化が原因で発生するデッドロックに対する解決策は多数あります (問題解決にかかる時間が短い順に記載しています)。

- 静的変数を含むソース ファイルは、 **/clr**を指定してコンパイルします。

- 静的変数によって呼び出されるすべての関数は、#pragma `unmanaged` ディレクティブを使用してネイティブ コードにコンパイルします。

- 静的変数が依存するコードを手動で複製して、.NET バージョンとネイティブ バージョンを作成し、それぞれに異なる名前を指定します。 その後、開発者は、ネイティブな静的初期化子からネイティブ バージョンを呼び出し、それ以外の場所から .NET バージョンを呼び出します。

### <a name="user-supplied-functions-affecting-startup"></a>起動に影響を与える、ユーザーが指定した関数

起動時の初期化でライブラリが依存する、ユーザー指定の関数がいくつかあります。 たとえば、`new` 演算子や `delete` 演算子などC++ 、でグローバルに演算子をオーバーロードすると、 C++標準ライブラリの初期化と破棄など、すべての場所でユーザー指定のバージョンが使用されます。 その結果、標準C++ライブラリとユーザー指定の静的初期化子は、これらの演算子のユーザー指定バージョンを呼び出します。

ユーザー指定バージョンが MSIL にコンパイルされると、これらの初期化子は、ローダー ロックが保持されているときに MSIL 命令を実行しようとします。 ユーザーが指定した `malloc` は、同じ結果になります。 この問題を解決するには、これらのオーバーロードまたはユーザー指定定義を、#pragma `unmanaged` ディレクティブを使用してネイティブ コードとして実装する必要があります。

このシナリオの詳細については、「[診断に対する障害](#impediments-to-diagnosis)」を参照してください。

### <a name="custom-locales"></a>カスタム ロケール

ユーザーがカスタムグローバルロケールを提供する場合、このロケールは、静的に初期化されたストリームを含む、今後のすべての i/o ストリームを初期化するために使用されます。 このグローバルなロケール オブジェクトを MSIL にコンパイルすると、MSIL にコンパイルされたロケール オブジェクト メンバー関数が、ローダー ロックが保持されているときに呼び出されることがあります。

この問題を解決するためのオプションが 3 つあります。

グローバル入出力ストリームの定義をすべて含むソース ファイルを、 **/clr** オプションを使用してコンパイルします。 これにより、ローダーロックの下で静的初期化子が実行されるのを防ぐことができます。

カスタム ロケールの関数定義は、#pragma `unmanaged` ディレクティブを使用することによって、ネイティブ コードにコンパイルできます。

ローダー ロックが解除されるまで、カスタム ロケールをグローバル ロケールとして設定しないようにします。 その後、初期化中に作成された入出力ストリームをカスタム ロケールで明示的に構成します。

## <a name="impediments-to-diagnosis"></a>診断に対する障害

場合によっては、デッドロックの原因を検出することが困難です。 以下では、そのようなシナリオとそれらの問題の解決策について説明します。

### <a name="implementation-in-headers"></a>ヘッダーでの実装

特殊なケースで、ヘッダー ファイル内に関数を実装すると、診断が困難になる場合があります。 インライン関数とテンプレート コードの両方で、その関数をヘッダー ファイルに指定する必要があります。  C++ 言語では、単一定義規則を指定します。単一定義規則を指定すると、同じ名前で実装されているすべての関数が、強制的に同じ意味にされます。 その結果、C++ リンカーでは、特定の関数を重複して実装しているオブジェクト ファイルをマージする際に特別に注意する必要がなくなります。

Visual Studio 2005 より前では、リンカーは単にこれらの意味的に等しい定義の中から最大のものを選択し、事前宣言に対応しています。また、さまざまなソースファイルに対して異なる最適化オプションが使用されているシナリオもあります。 ネイティブ/.NET Dll が混在している場合に問題が発生します。

/Clr が有効になっているファイルとC++無効に **/clr**なっているファイルの両方に同じヘッダーが含まれている場合、または #include が `#pragma unmanaged` ブロック内にラップされている場合は、ヘッダーに実装を提供する MSIL とネイティブの両方のバージョンの関数を使用できます。 MSIL の実装とネイティブの実装は、ローダー ロックの状態での初期化については異なる意味を持ちます。これは、事実上、単一定義規則に違反しています。 その結果、リンカーが最大の実装を選択すると、他の場所で #pragma unmanaged ディレクティブを使用して明示的にネイティブ コードにコンパイルした場合でも、関数の MSIL バージョンが選択されます。 テンプレートまたはインライン関数の MSIL バージョンがローダーロックの下で呼び出されないようにするには、ローダーロックの下で呼び出されるすべての関数のすべての定義を、`#pragma unmanaged` ディレクティブを使用して変更する必要があります。 ヘッダーファイルがサードパーティからのものである場合、この変更を行う最も簡単な方法は、問題のあるヘッダーファイルの #include ディレクティブの周囲に `#pragma unmanaged` ディレクティブをプッシュしてポップすることです。 (例については[、「マネージ、アンマネージ](../preprocessor/managed-unmanaged.md)」を参照してください)。ただし、この方法は、.NET Api を直接呼び出す必要がある他のコードが含まれているヘッダーに対しては機能しません。

ローダー ロックを扱うユーザーの負担を減らすため、マネージドとネイティブの両方の実装が存在する場合、リンカーはネイティブの実装を選択するようになっています。 この既定では、上記の問題は回避されます。 ただし、このリリースではコンパイラに未解決の問題が 2 つ残っているため、この規則には、次の 2 つの例外があります。

- インライン関数の呼び出しは、グローバルな静的関数ポインターを介して行われます。 このシナリオは、仮想関数がグローバル関数ポインターを介して呼び出されるため、注目してください。 たとえば、次のように入力します。

```cpp
#include "definesmyObject.h"
#include "definesclassC.h"

typedef void (*function_pointer_t)();

function_pointer_t myObject_p = &myObject;

#pragma unmanaged
void DuringLoaderlock(C & c)
{
    // Either of these calls could resolve to a managed implementation,
    // at link-time, even if a native implementation also exists.
    c.VirtualMember();
    myObject_p();
}
```

### <a name="diagnosing-in-debug-mode"></a>デバッグ モードでの診断

ローダー ロックに関する問題の診断はすべて、デバッグ ビルドで行う必要があります。 リリース ビルドは診断を生成しない場合があります。また、リリース モードで実行される最適化によって、ローダー ロックのシナリオで MSIL の一部が隠されることがあります。

## <a name="how-to-debug-loader-lock-issues"></a>ローダーロックに関する問題をデバッグする方法

MSIL 関数が呼び出されたときに、CLR が生成する診断は、CLR の実行を中断します。 その結果、デバッグ対象をインプロセスC++で実行するときに、ビジュアル混合モードのデバッガーも中断されます。 ただし、プロセスにアタッチするときに、混合デバッガーを使用してデバッグ対象のマネージコールバックを取得することはできません。

ローダー ロック中に呼び出された特定の MSIL 関数を識別するには、開発者が次の手順を実行する必要があります。

1. mscoree.dll と mscorwks.dll のシンボルを使用できるようにします。

   シンボルを使用できるようにするには、次の2つの方法があります。 1 つ目の方法として、mscoree.dll と mscorwks.dll の PDB をシンボル検索パスに追加します。 シンボルを追加するには、[シンボル検索パスのオプション] ダイアログを開きます。 ( **[ツール]** メニューの **[オプション]** をクリックします。 **[オプション]** ダイアログボックスの左ペインで、 **[デバッグ]** ノードを開き、 **[シンボル]** を選択します。Mscoree.dll および mscorwks.dll PDB ファイルへのパスを検索リストに追加します。 これらの PDB は、%VSINSTALLDIR%\SDK\v2.0\symbols にインストールされます。 **[OK]** を選択します。

   2 つ目の方法として、mscoree.dll と mscorwks.dll の PDB を Microsoft Symbol Server からダウンロードします。 Symbol Server を構成するには、シンボル検索パスのオプションのダイアログ ボックスを開きます。 ( **[ツール]** メニューの **[オプション]** をクリックします。 **[オプション]** ダイアログボックスの左ペインで、 **[デバッグ]** ノードを開き、 **[シンボル]** を選択します。この検索パスを検索リストに追加します: `https://msdl.microsoft.com/download/symbols`。 シンボルのキャッシュ ディレクトリをシンボル サーバーのキャッシュのテキスト ボックスに追加します。 **[OK]** を選択します。

1. デバッガーのモードをネイティブのみに設定します。

   ソリューションのスタートアッププロジェクトの**プロパティ**グリッドを開きます。 **[構成プロパティ]**  >  **[デバッグ]** を選択します。 デバッガーの**種類**を**ネイティブのみ**に設定します。

1. デバッガーを起動します (F5 キー)。

1. **/Clr**診断が生成されたら、 **[再試行]** を選択し、 **[中断]** を選択します。

1. [呼び出し履歴] ウィンドウを開きます。 (メニューバーで、[**デバッグ** > **Windows** > **呼び出し履歴**)] を選択します。問題の `DllMain` または静的初期化子は、緑色の矢印で示されます。 問題のある関数が示されない場合は、以下の手順を実行して検索する必要があります。

1. **[イミディエイト]** ウィンドウを開きます (メニューバーで [**デバッグ** > **Windows** > **イミディエイト**] を選択します)。

1. **[イミディエイト]** ウィンドウに `.load sos.dll` を入力して、SOS デバッグサービスを読み込みます。

1. **[イミディエイト]** ウィンドウに `!dumpstack` を入力して、内部 **/clr**スタックの完全な一覧を取得します。

1. _CorDllMain (`DllMain` が問題を引き起こしている場合) または _VTableBootstrapThunkInitHelperStub または GetTargetForVTableEntry (静的初期化子によって問題が発生した場合) のいずれかの最初のインスタンス (スタックの一番下にあるもの) を探します。 この呼び出しのすぐ下にあるスタック エントリが、ローダー ロック中に実行しようとした、MSIL 実装の関数の呼び出しです。

1. 前の手順で特定したソースファイルと行番号にアクセスし、「シナリオ」セクションで説明されているシナリオと解決策を使用して問題を修正します。

## <a name="example"></a>例

### <a name="description"></a>説明

次の例は、コードを `DllMain` からグローバルオブジェクトのコンストラクターに移動することによって、ローダーロックを回避する方法を示しています。

このサンプルでは、最初は `DllMain`であったマネージオブジェクトを含むコンストラクターを持つグローバルマネージオブジェクトがあります。 このサンプルの2番目の部分では、アセンブリを参照し、マネージオブジェクトのインスタンスを作成して、初期化を実行するモジュールコンストラクターを呼び出します。

### <a name="code"></a>コード

```cpp
// initializing_mixed_assemblies.cpp
// compile with: /clr /LD
#pragma once
#include <stdio.h>
#include <windows.h>
struct __declspec(dllexport) A {
   A() {
      System::Console::WriteLine("Module ctor initializing based on global instance of class.\n");
   }

   void Test() {
      printf_s("Test called so linker does not throw away unused object.\n");
   }
};

#pragma unmanaged
// Global instance of object
A obj;

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) {
   // Remove all managed code from here and put it in constructor of A.
   return true;
}
```

この例では、混在アセンブリの初期化に関する問題を示します。

```cpp
// initializing_mixed_assemblies_2.cpp
// compile with: /clr initializing_mixed_assemblies.lib
#include <windows.h>
using namespace System;
#include <stdio.h>
#using "initializing_mixed_assemblies.dll"
struct __declspec(dllimport) A {
   void Test();
};

int main() {
   A obj;
   obj.Test();
}
```

このコードを実行すると、次の出力が生成されます。

```Output
Module ctor initializing based on global instance of class.

Test called so linker does not throw away unused object.
```

## <a name="see-also"></a>参照

[混在 (ネイティブおよびマネージド) アセンブリ](../dotnet/mixed-native-and-managed-assemblies.md)
