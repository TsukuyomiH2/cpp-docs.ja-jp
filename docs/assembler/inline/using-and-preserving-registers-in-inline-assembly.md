---
title: インライン アセンブリでのレジスタの使用および保持
ms.date: 08/30/2018
helpviewer_keywords:
- __asm keyword [C++], register values
- inline assembly, registers
- registers, inline assembly
- preserving registers
ms.assetid: dbcd7360-6f3e-4b22-9ee2-9f65ca6f2543
ms.openlocfilehash: 97db09ac7652c00e9599a6938f4114de080906c0
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81318026"
---
# <a name="using-and-preserving-registers-in-inline-assembly"></a>インライン アセンブリでのレジスタの使用および保持

**マイクロソフト固有**

一般に、`__asm`ブロックの開始時にレジスタに指定された値があるとは考えるべきではありません。 レジスタ値は、個別`__asm`のブロック間で保持される保証はありません。 インライン コードのブロックを終了して別のコードを開始した場合、2 番目のブロックのレジスタに依存して、最初のブロックからの値を保持することはできません。 ブロック`__asm`は、通常の制御フローから生じるレジスタ値を継承します。

呼び出し`__fastcall`規約を使用する場合、コンパイラはスタックではなくレジスタに関数の引数を渡します。 これは、関数がどのレジスタに`__asm`どのパラメータを示す方法がないため、ブロックを持つ関数で問題を引き起こす可能性があります。 関数が EAX でパラメーターを受け取り、EAX に他のものをすぐに格納すると、元のパラメーターは失われます。 また、ECX レジスタは、 で`__fastcall`宣言された関数に保持する必要があります。

このようなレジスタの競合を回避するには、ブロックを含`__fastcall`む関数の規則を`__asm`使用しないでください。 /Gr コンパイラ`__fastcall`オプションを使用して規則をグローバルに指定する場合は、`__asm`または`__stdcall``__cdecl`を指定してブロックを含むすべての関数を宣言します。 (この`__cdecl`属性は、コンパイラに対して、その関数に対して C 呼び出し規約を使用するように指示します。/Gr を使用してコンパイルしない場合は、`__fastcall`属性を使用して関数を宣言しないでください。

C/C++ 関数でアセンブリ言語`__asm`を記述する場合、EAX、EBX、ECX、EDX、ESI、または EDI レジスタを保持する必要はありません。 例えば、POWER2 での場合です。C の例では、[インライン アセンブリを使用して関数を記述](../../assembler/inline/writing-functions-with-inline-assembly.md)する`power2`関数は、EAX レジスタの値を保持しません。 ただし、これらのレジスタを使用すると、ブロック間`__asm`で値を格納するためにレジスタ アロケーターを使用できないため、コードの品質に影響します。 さらに、インライン アセンブリ コードで EBX、ESI、EDI を使用すると、コンパイラは、関数のプロローグとエピローグでそれらのレジスタを保存および復元するように強制します。

ブロックのスコープに使用する他のレジスタ (DS、SS、SP、BP、フラグ レジスタなど) を保持する`__asm`必要があります。 ESP レジスタと EBP レジスタを変更する理由がない限り(たとえば、スイッチ スタックに)、ESP レジスタと EBP レジスタを保持する必要があります。 インライン[アセンブリの最適化も](../../assembler/inline/optimizing-inline-assembly.md)参照してください。

SSE タイプによっては、8 バイトのスタックアライメントが必要なため、コンパイラは動的なスタックアライメントコードを生成する必要があります。 配置後にローカル変数と関数パラメーターの両方にアクセスできるように、コンパイラは 2 つのフレーム ポインターを保持します。  コンパイラは、フレーム ポインターの省略 (FPO) を実行する場合、EBP と ESP を使用します。  コンパイラが FPO を実行しない場合は、EBX と EBP が使用されます。 コードが正しく実行されるように、関数がフレームポインタを変更する可能性があるため、動的なスタック配置が必要な場合は、ASMコードで EBX を変更しないでください。 8 バイトの整列型を関数から移動するか、または EBX を使用しないようにします。

> [!NOTE]
> STD 命令または CLD 命令を使用してインライン・アセンブリー・コードが方向フラグを変更する場合は、フラグを元の値に戻す必要があります。

**エンド マイクロソフト 固有**

## <a name="see-also"></a>関連項目

[インライン アセンブラー](../../assembler/inline/inline-assembler.md)<br/>
