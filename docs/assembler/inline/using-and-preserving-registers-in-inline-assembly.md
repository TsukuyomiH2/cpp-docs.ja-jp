---
description: 詳細については、「インラインアセンブリでのレジスタの使用と保持」を参照してください。
title: インライン アセンブリでのレジスタの使用および保持
ms.date: 08/30/2018
helpviewer_keywords:
- __asm keyword [C++], register values
- inline assembly, registers
- registers, inline assembly
- preserving registers
ms.assetid: dbcd7360-6f3e-4b22-9ee2-9f65ca6f2543
ms.openlocfilehash: 36758a313044190c9ee2f2a9b094325821d87635
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/11/2020
ms.locfileid: "97122006"
---
# <a name="using-and-preserving-registers-in-inline-assembly"></a>インライン アセンブリでのレジスタの使用および保持

**Microsoft 固有の仕様**

一般に、ブロックの開始時にレジスタに値が割り当てられると想定しないでください **`__asm`** 。 レジスタの値は、個別のブロック間で保持されるとは限りません **`__asm`** 。 インラインコードのブロックを終了し、別のブロックを開始する場合、2番目のブロックのレジスタに依存して、最初のブロックの値を保持することはできません。 ブロックは、 **`__asm`** 通常の制御フローから任意のレジスタ値の結果を継承します。

呼び出し規約を使用する場合 **`__fastcall`** 、コンパイラはスタックではなくレジスタに関数の引数を渡します。 これにより **`__asm`** 、どのパラメーターが登録されているかを関数が判別できないため、ブロックのある関数で問題が発生する可能性があります。 関数が EAX でパラメーターを受け取って、EAX に他の何かを直ちに格納した場合、元のパラメーターは失われます。 また、で宣言されたすべての関数で ECX レジスタを保持する必要があり **`__fastcall`** ます。

このようなレジスタの競合を回避するには、 **`__fastcall`** ブロックを含む関数に規則を使用しないで **`__asm`** ください。 **`__fastcall`**/Gr コンパイラオプションを使用してグローバル規則を指定する場合は、ブロックを含むすべての関数を **`__asm`** またはで宣言し **`__cdecl`** **`__stdcall`** ます。 (属性は、 **`__cdecl`** その関数に対して C 呼び出し規約を使用するようにコンパイラに指示します)。/Gr を使用してコンパイルしない場合は、属性を使用して関数を宣言しないで **`__fastcall`** ください。

を使用して **`__asm`** C/c + + 関数でアセンブリ言語を記述する場合、EAX、EBX、ECX、EDX、ESI、または EDI レジスタを保持する必要はありません。 たとえば、POWER2 です。C の例 [インラインアセンブリを使用して関数を記述](../../assembler/inline/writing-functions-with-inline-assembly.md)する場合、関数は、 `power2` EAX レジスタの値を保持しません。 ただし、レジスタアロケーターでは、これらのレジスタを使用してブロック間で値を格納することはできないため、これらのレジスタを使用するとコードの品質に影響し **`__asm`** ます。 また、インラインアセンブラーコードで EBX、ESI、または EDI を使用することにより、コンパイラは、プロローグおよびエピローグ関数のレジスタを保存して復元するように強制します。

使用する他のレジスタ (DS、SS、SP、BP、flags レジスタなど) は、ブロックのスコープに対して保持する必要があり **`__asm`** ます。 ESP および EBP レジスタを変更する理由がない場合 (スタックを切り替える場合など) は、そのままにしておいてください。 「 [インラインアセンブリの最適化](../../assembler/inline/optimizing-inline-assembly.md)」も参照してください。

一部の SSE 型では、8バイトのスタックアラインメントが必要で、コンパイラは動的なスタックアラインメントコードを出力します。 配置後にローカル変数と関数パラメーターの両方にアクセスできるようにするために、コンパイラは2つのフレームポインターを保持します。  コンパイラがフレームポインターの省略 (FPO) を実行すると、EBP と ESP が使用されます。  コンパイラが FPO を実行しない場合は、EBX と EBP が使用されます。 コードが正しく実行されるようにするには、asm コードで EBX を変更しないでください。これは、関数がフレームポインターを変更する際に動的なスタックアラインメントを必要とする場合です。 8バイトのアラインメントされた型を関数の外に移動するか、EBX を使用しないようにします。

> [!NOTE]
> インラインアセンブリコードが STD または CLD 命令を使用して方向フラグを変更する場合は、フラグを元の値に戻す必要があります。

**Microsoft 固有の仕様はここまで**

## <a name="see-also"></a>関連項目

[インラインアセンブラー](../../assembler/inline/inline-assembler.md)<br/>
