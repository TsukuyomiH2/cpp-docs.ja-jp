---
title: インライン アセンブリでのレジスタの使用および保持
ms.date: 08/30/2018
helpviewer_keywords:
- __asm keyword [C++], register values
- inline assembly, registers
- registers, inline assembly
- preserving registers
ms.assetid: dbcd7360-6f3e-4b22-9ee2-9f65ca6f2543
ms.openlocfilehash: 51147a217ec56c525fc01e1b36a9381b9356ba4d
ms.sourcegitcommit: 857fa6b530224fa6c18675138043aba9aa0619fb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/24/2020
ms.locfileid: "80169156"
---
# <a name="using-and-preserving-registers-in-inline-assembly"></a>インライン アセンブリでのレジスタの使用および保持

**Microsoft 固有の仕様**

一般に、`__asm` ブロックの開始時にレジスタに特定の値が含まれていると想定しないでください。 レジスタの値は、個別の `__asm` ブロック間で保持されるとは限りません。 インラインコードのブロックを終了し、別のブロックを開始する場合、2番目のブロックのレジスタに依存して、最初のブロックの値を保持することはできません。 `__asm` ブロックは、通常の制御フローから任意のレジスタ値の結果を継承します。

`__fastcall` の呼び出し規約を使用する場合、コンパイラはスタックではなくレジスタに関数の引数を渡します。 これにより、`__asm` ブロックを持つ関数で問題が発生する可能性があります。これは、どのパラメーターが登録されているかを関数が特定する方法がないためです。 関数が EAX でパラメーターを受け取って、EAX に他の何かを直ちに格納した場合、元のパラメーターは失われます。 また、`__fastcall`で宣言されたすべての関数で ECX レジスタを保持する必要があります。

このようなレジスタの競合を回避するには、`__asm` ブロックを含む関数には `__fastcall` 規則を使用しないでください。 /Gr コンパイラオプションを使用してグローバルに `__fastcall` 規約を指定する場合は、`__cdecl` または `__stdcall`を使用して、`__asm` ブロックを含むすべての関数を宣言します。 (`__cdecl` 属性は、その関数に対して C 呼び出し規約を使用するようにコンパイラに指示します。)/Gr を使用してコンパイルしない場合は、`__fastcall` 属性を使用して関数を宣言しないでください。

`__asm` を使用して C/C++ functions でアセンブリ言語を記述する場合、EAX、EBX、ECX、EDX、ESI、または EDI レジスタを保持する必要はありません。 たとえば、POWER2 です。C の例[インラインアセンブリを使用して関数を記述](../../assembler/inline/writing-functions-with-inline-assembly.md)する場合、`power2` 関数は、EAX レジスタの値を保持しません。 ただし、レジスタアロケーターでは、これらのレジスタを使用して `__asm` ブロック間で値を格納することはできないため、これらのレジスタを使用するとコードの品質に影響します。 また、インラインアセンブラーコードで EBX、ESI、または EDI を使用することにより、コンパイラは、プロローグおよびエピローグ関数のレジスタを保存して復元するように強制します。

`__asm` ブロックのスコープについては、使用する他のレジスタ (DS、SS、SP、BP、flags レジスタなど) を保持する必要があります。 ESP および EBP レジスタを変更する理由がない場合 (スタックを切り替える場合など) は、そのままにしておいてください。 「[インラインアセンブリの最適化](../../assembler/inline/optimizing-inline-assembly.md)」も参照してください。

一部の SSE 型では、8バイトのスタックアラインメントが必要で、コンパイラは動的なスタックアラインメントコードを出力します。 配置後にローカル変数と関数パラメーターの両方にアクセスできるようにするために、コンパイラは2つのフレームポインターを保持します。  コンパイラがフレームポインターの省略 (FPO) を実行すると、EBP と ESP が使用されます。  コンパイラが FPO を実行しない場合は、EBX と EBP が使用されます。 コードが正しく実行されるようにするには、asm コードで EBX を変更しないでください。これは、関数がフレームポインターを変更する際に動的なスタックアラインメントを必要とする場合です。 8バイトのアラインメントされた型を関数の外に移動するか、EBX を使用しないようにします。

> [!NOTE]
>  インラインアセンブリコードが STD または CLD 命令を使用して方向フラグを変更する場合は、フラグを元の値に戻す必要があります。

**Microsoft 固有の仕様はここまで**

## <a name="see-also"></a>参照

[インライン アセンブラー](../../assembler/inline/inline-assembler.md)<br/>
