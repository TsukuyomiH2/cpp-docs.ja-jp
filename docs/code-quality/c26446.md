---
title: C26446
ms.date: 03/22/2018
ms.topic: reference
f1_keywords:
- C26446
helpviewer_keywords:
- C26446
ms.openlocfilehash: a822378a9782a1a6f0633a34762d0a54992d509d
ms.sourcegitcommit: 7bea0420d0e476287641edeb33a9d5689a98cb98
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/17/2020
ms.locfileid: "79465668"
---
# <a name="c26446-use_gsl_at"></a>C26446 USE_GSL_AT

Unchecked 添字演算子の代わりに `gsl::at()` を使用することをお勧めします。

C++コアガイドライン: [bounds. 4: 標準ライブラリの関数と、範囲チェックされていない型を使用しない](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#probounds-bounds-safety-profile)でください。

C++コアガイドラインの境界プロファイルは、生のポインターと unchecked 操作の使用を回避することで、メモリの安全でない操作を排除しようとします。 バッファーへの一貫した範囲チェック付きアクセスを実行する方法の1つは、ガイドラインサポートライブラリの `gsl::at()` ユーティリティを使用することです。 また、STL コンテナーで使用可能な `at()` の標準実装に依存することもお勧めします。

このルールは、オペレーター\[] () への呼び出しによって、未チェックのアクセスが実行される可能性がある場所を見つけるのに役立ちます。 ほとんどの場合、このような呼び出しは `gsl::at()`に簡単に置き換えることができます。

- 添字演算子で非定数インデックスが使用されている場合は、既知のサイズの配列へのアクセスにフラグが設定されます。 定数インデックスは、 [C26483 STATIC_INDEX_OUT_OF_RANGE](c26483.md)によって処理されます。
- オーバーロードされた演算子 [] の呼び出しについて警告するロジックは、より複雑です。
  - インデックスが整数でない場合、呼び出しは無視されます。 また、このような演算子のパラメーターは参照によって渡されるため、標準マップでのインデックス作成も処理されます。
  - **Noexcept**、 **throw ()** 、または **__declspec (nothrow)** を使用して、演算子が非スローとしてマークされている場合、呼び出しにフラグが設定されます。 添字演算子が例外をスローしない場合は、範囲チェックを実行しないか、これらのチェックがあいまいであることを前提としています。
  - 演算子が非スローとしてマークされていない場合、その演算子は、従来の `at()` メンバー関数も定義している STL コンテナーからのものであるとしてフラグが設定されている可能性があります (このような関数は、単純な名前の一致によって検出されます)。
  - ルールでは、標準 `at()` 関数の呼び出しに対して警告が行われません。 これらの関数は安全であり、`gsl::at()` に置き換えると、あまり多くの値が得られません。
- `std::basic_string_view<>` へのインデックス作成は安全ではないため、警告が発行されます。 標準の文字列ビューは `gsl::basic_string_span<>`に置き換えることができます。この場合、常に境界チェックが行われます。
- 実装では、ユーザーコードがループまたは分岐内のどこかにある可能性がある範囲チェックを考慮しません。 ここでの精度は、パフォーマンスのために取引されます。 一般に、明示的な範囲チェックは、より信頼性の高い反復子またはより簡潔な拡張ループに置き換えることができます。
