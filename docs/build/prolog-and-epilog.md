---
title: x64 でのプロローグとエピローグ
ms.date: 12/17/2018
ms.assetid: 0453ed1a-3ff1-4bee-9cc2-d6d3d6384984
ms.openlocfilehash: d0b7444af6e434a09f6af5f5b1c144b46c79ad56
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81328429"
---
# <a name="x64-prolog-and-epilog"></a>x64 でのプロローグとエピローグ

スタック領域の割り当て、他の関数の呼び出し、不揮発性レジスタの保存、または例外処理を使用するすべての関数には、対応する関数テーブルエントリに関連付けられたアンワインド データにアドレス制限が記述されているプロローグが必要です。 詳細については、「 [x64 例外処理](../build/exception-handling-x64.md)」を参照してください。 プロローグは、必要に応じて、引数レジスタをホーム アドレスに保存し、スタックに不揮発性レジスタをプッシュし、スタックの固定部分をローカルおよび一時に割り当て、必要に応じてフレーム ポインタを確立します。 関連するアンワインド データは、プロローグのアクションを記述し、プロローグ コードの効果を元に戻すために必要な情報を提供する必要があります。

スタック内の固定割り当てが複数のページ (つまり 4096 バイトを超える) の場合、スタック割り当てが複数の仮想メモリ ページにまたがって行われる可能性があるため、割り当てを行う前に割り当てを確認する必要があります。 プロローグから呼び出し可能で、引数レジスタを破棄しない特殊なルーチンがこの目的のために提供されます。

不揮発性レジスタを保存する場合は、固定スタック割り当ての前に、それらをスタックに移動することをお勧めします。 不揮発性レジスタが保存される前に固定スタック割り当てが実行される場合、ほとんどの場合、保管されたレジスタ領域に対処するために 32 ビットの変位が必要です。 (報告によると、レジスタのプッシュは移動と同じくらい速く、プッシュ間の暗黙の依存関係にもかかわらず、予見可能な将来のためにそう残る必要があります。不揮発性レジスタは、任意の順序で保存することができます。 ただし、プロローグで不揮発性レジスタを最初に使用するのは、それを保存する必要があります。

## <a name="prolog-code"></a>プロローグ コード

一般的なプロローグのコードは次のようになります。

```MASM
    mov    [RSP + 8], RCX
    push   R15
    push   R14
    push   R13
    sub    RSP, fixed-allocation-size
    lea    R13, 128[RSP]
    ...
```

このプロローグは、引数レジスタ RCX をホームロケーションに格納し、不揮発性レジスタ R13-R15 を保存し、スタック フレームの固定部分を割り当て、固定割り当て領域に 128 バイトを指すフレーム ポインタを確立します。 オフセットを使用すると、固定割り振り領域の多くを 1 バイトオフセットでアドレス指定できます。

固定割り当てサイズがメモリの 1 ページ以上の場合は、RSP を変更する前にヘルパー関数を呼び出す必要があります。 このヘルパーは`__chkstk`、割り当て可能なスタック範囲をプローブし、スタックが適切に拡張されていることを確認します。 その場合、前のプロローグの例は、代わりに次のようになります。

```MASM
    mov    [RSP + 8], RCX
    push   R15
    push   R14
    push   R13
    mov    RAX,  fixed-allocation-size
    call   __chkstk
    sub    RSP, RAX
    lea    R13, 128[RSP]
    ...
```

ヘルパー`__chkstk`は R10、R11、および条件コード以外のレジスタを変更しません。 特に、RAX は変更されずに戻され、すべての不揮発性レジスタと引数渡しレジスタは変更されません。

## <a name="epilog-code"></a>エピローグ コード

エピローグ コードは、関数の各出口に存在します。 通常はプロローグが 1 つだけ存在するのに対し、エピローグは多く存在する可能性があります。 エピローグ コードは、スタックを固定割り当てサイズ (必要な場合) にトリムし、固定スタック割り当てを解除し、保存された値をスタックからポップして不揮発性レジスタを復元し、返します。

エピローグ コードは、例外や割り込みを確実にアンワインドするためのアンワインド コードの厳密な規則に従う必要があります。 これらのルールは、各エピローグを記述するために追加のデータが必要ないため、必要なアンワインド データの量を減らします。 代わりに、アンワインド コードは、エピローグを識別するためにコード ストリームを前方にスキャンすることによって、エピローグが実行されていることを判断できます。

関数でフレーム ポインタが使用されない場合、エピローグはまずスタックの固定部分の割り当てを解除し、不揮発性レジスタがポップされ、呼び出し元の関数に制御が返されます。 たとえば、次のように入力します。

```MASM
    add      RSP, fixed-allocation-size
    pop      R13
    pop      R14
    pop      R15
    ret
```

関数でフレーム ポインタを使用する場合、エピローグを実行する前に、スタックを固定割り当てにトリミングする必要があります。 このアクションは、技術的にはエピローグの一部ではありません。 たとえば、次のエピローグを使用して、以前に使用したプロローグを元に戻すことができます。

```MASM
    lea      RSP, -128[R13]
    ; epilogue proper starts here
    add      RSP, fixed-allocation-size
    pop      R13
    pop      R14
    pop      R15
    ret
```

実際には、フレームポインタを使用する場合、2つのステップでRSPを調整する正当な理由がないため、代わりに次のエピローグが使用されます。

```MASM
    lea      RSP, fixed-allocation-size - 128[R13]
    pop      R13
    pop      R14
    pop      R15
    ret
```

これらのフォームは、エピローグの唯一の法的なものです。 `add RSP,constant`これは、`lea RSP,constant[FPReg]`または 、 のいずれかから構成され、その後に 0 個以上の 8`return`バイトの`jmp`レジスタ ポップと a または a が続く必要があります。 (エピローグでは、`jmp`ステートメントのサブセットのみが許可されます。 サブセットは ModRM mod`jmp`フィールド値が 00 である ModRM メモリー参照を持つステートメントのクラスに限定されます。 ModRM `jmp` mod フィールド値 01 または 10 を使用したエピローグ内でのステートメントの使用は禁止されています。 許容される ModRM リファレンスの詳細については、AMD x86-64 アーキテクチャプログラマーマニュアル第3巻:一般的な目的とシステムの指示の表A-15を参照してください。他のコードは表示されません。 特に、戻り値の読み込みなど、エピローグ内でスケジュールを設定することはできません。

フレーム ポインターを使用しない場合、エピローグはスタックの`add RSP,constant`固定部分の割り当てを解除するために使用する必要があります。 代わりに使用`lea RSP,constant[RSP]`しない場合があります。 この制限は、アンワインド コードがエピローグを検索するときに認識するパターンが少なくなるように存在します。

これらの規則に従うと、アンワインド コードは、エピローグが現在実行されていることを確認し、呼び出し元の関数のコンテキストを再作成できるように、エピローグの残りの部分の実行をシミュレートできます。

## <a name="see-also"></a>関連項目

[x64 ソフトウェア規約](x64-software-conventions.md)
