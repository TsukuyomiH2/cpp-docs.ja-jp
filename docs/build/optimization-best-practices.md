---
title: 最適化の推奨事項
ms.date: 05/06/2019
helpviewer_keywords:
- C++, optimization
- optimization, best practices
ms.assetid: f3433148-7255-4ca6-8a4f-7c31aac88508
ms.openlocfilehash: 541114b4cbf7d3d063e48b50ab265b4c95c6237c
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81328449"
---
# <a name="optimization-best-practices"></a>最適化の推奨事項

このドキュメントでは、Visual Studio で C++ プログラムを最適化するためのベスト プラクティスについて説明します。

## <a name="compiler-and-linker-options"></a>コンパイラとリンカーのオプション

### <a name="profile-guided-optimization"></a>ガイド付き最適化のプロファイル

ガイド*付き最適化*(PGO) のプロファイルをサポートしています。 この最適化では、アプリケーションの計測バージョンのトレーニング実行からのプロファイルデータを使用して、アプリケーションの後の最適化を推進します。 PGO を使用すると時間がかかる場合があるため、すべての状況に適しているとは言えません。しかし、製品の最終リリース ビルドには PGO を使用することをお勧めします。 詳細については、「[ガイド付き最適化のプロファイル](profile-guided-optimizations.md)」を参照してください。

さらに、*プログラム全体の最適化*(リンク時コード生成とも認識) および **/O1 および /O2**の最適化が改善されました。 **/O2** 通常、これらのオプションのいずれかを指定してコンパイルしたアプリケーションの処理速度は、以前のコンパイラでコンパイルした同じアプリケーションよりも速くなります。

詳細については、「 [/GL (プログラム全体の最適化)」](reference/gl-whole-program-optimization.md)および[/O1,/O2 (サイズの最小化、速度の最大化)](reference/o1-o2-minimize-size-maximize-speed.md)を参照してください。

### <a name="which-level-of-optimization-to-use"></a>使用する最適化のレベル

可能な限り、最終リリース ビルドは、PGO を使用してコンパイルする必要があります。 インストルメント化されたビルドを実行するにはインフラストラクチャが不十分であることや、シナリオにアクセスできないことが原因で、PGO を使用してビルドできない場合は、プログラム全体の最適化を使用してビルドすることをお勧めします。

**/Gy**スイッチも非常に便利です。 このスイッチを使用すると、関数ごとに個別の COMDAT が生成されます。その結果、参照されていない COMDAT を取り除いたり COMDAT を圧縮したりでき、リンカーの柔軟性が向上します。 **/Gy**を使用する唯一の欠点は、デバッグ時に問題が発生する可能性がある点です。 重要な影響を受けるわけではないので、通常は、このスイッチを使用することをお勧めします。 詳細については、「[/Gy (関数レベルのリンクの有効化)](reference/gy-enable-function-level-linking.md)」を参照してください。

64 ビット環境でのリンクの場合は **、/OPT:REF、ICF**リンカー オプションを使用し、32 ビット環境では **/OPT:REF**を使用することをお勧めします。 詳細については、 [/OPT (最適化)](reference/opt-optimizations.md)を参照してください。

また、デバッグ シンボルを生成することを強くお勧めします。これは、最適化されたリリース ビルドの場合も同様です。 生成されたコードには影響を与えないため、必要に応じてアプリケーションのデバッグが非常に簡単になります。

### <a name="floating-point-switches"></a>浮動小数点スイッチ

**/Op**コンパイラ オプションが削除され、浮動小数点の最適化を扱う次の 4 つのコンパイラ オプションが追加されました。

|||
|-|-|
|**/fp:正確**|既定で推奨されているオプションです。ほとんどの場合は、これを使用します。|
|**/fp:高速**|パフォーマンスが最も重要視される場合 (ゲームなど) に推奨されます。 このオプションを使用すると、パフォーマンスが最も高速になります。|
|**/fp:厳格**|浮動小数点の例外に関して厳密な対応が必要な場合や、IEEE に沿った動作が必要な場合に推奨されます。 このオプションを使用すると、パフォーマンスが最も低速になります。|
|**/fp:を除く[-]**|**/fp:strict**または **/fp:precise**と組み合わせて使用できますが **、/fp:fast**と組み合わせて使用することはできません。|

詳細については、「[/fp (浮動小数点の動作の指定)](reference/fp-specify-floating-point-behavior.md)」を参照してください。

## <a name="optimization-declspecs"></a>最適化のデクラスペス

このセクションでは、パフォーマンスを改善するためにプログラム内で使用できる、`__declspec(restrict)` および `__declspec(noalias)` という 2 つの declspec について説明します。

`restrict` declspec は、`__declspec(restrict) void *malloc(size_t size);` など、ポインターを返す関数宣言のみに適用できます。

`restrict` declspec は、エイリアスを使用しないポインターを返す関数で使用されます。 このキーワードは、現在のプログラムで既に使用されているポインター値を返さないため、解放済みのメモリを使用するなどの無効な操作を行う場合を除いて、C ランタイム ライブラリの `malloc` の実装に使用できます。

`restrict` declspec は、コンパイラが最適化を実行するための詳細情報をコンパイラに伝えます。 コンパイラにとって最も困難なことの 1 つは、どのポインターが他のポインターのエイリアスとなっているかを判断することですが、その際、この詳細情報はコンパイラにとって非常に役立ちます。

この情報はコンパイラでは前提とされ、コンパイラが検証することはありません。 プログラムでこの `restrict` declspec を不適切に使用すると、プログラムが不正な動作をするおそれがあります。

詳細については、「[制限](../cpp/restrict.md)」を参照してください。

また、`noalias` declspec も関数だけに適用され、その関数が準純粋関数であることを示します。 準純粋関数は、ローカル、引数、引数の第 1 レベルの間接参照だけを参照または変更する関数です。 この declspec はコンパイラでは前提とされます。準純粋関数がグローバル、またはポインター引数の第 2 レベルの間接指定を参照する場合、コンパイラが生成するコードはアプリケーションを中断させる可能性があります。

詳細については、「[noalias](../cpp/noalias.md)」を参照してください。

## <a name="optimization-pragmas"></a>最適化プラグマ

コードを最適化する際に有用なプラグマもいくつかあります。 最初に説明するのは次のとおりです`#pragma optimize`。

```cpp
#pragma optimize("{opt-list}", on | off)
```

このプラグマを使用すると、関数ごとに特定の最適化レベルを設定できます。 このプラグマは、特定の関数を最適化してコンパイルするとアプリケーションがクラッシュするという特殊な状況に適しています。 このプラグマを使用すると、1 つの関数の最適化を無効にできます。

```cpp
#pragma optimize("", off)
int myFunc() {...}
#pragma optimize("", on)
```

詳細については、「[最適化](../preprocessor/optimize.md)」を参照してください。

コンパイラで実行する最適化のうち、最も重要な最適化の 1 つにインライン展開があります。ここでは、インライン展開の動作を変更できるプラグマをいくつか紹介します。

`#pragma inline_recursion` は、アプリケーションで再帰呼び出しをインライン展開できるようにするかどうかを指定する場合に役立ちます。 既定では、インライン展開は無効になっています。 関数が小さく、再帰の数が少ない場合は、このプラグマを有効にできます。 詳細については[、「inline_recursion」](../preprocessor/inline-recursion.md)を参照してください。

インライン展開の深さを制限する場合に役立つ別のプラグマとして、`#pragma inline_depth` があります。 これは通常、プログラムや関数のサイズを制限する場合に役立ちます。 詳細については、「 [inline_depth](../preprocessor/inline-depth.md)」を参照してください。

## <a name="__restrict-and-__assume"></a>__restrictと\__assume

Visual Studio には、パフォーマンスを向上するキーワードがいくつかあります: [__restrict](../cpp/extension-restrict.md)と[__assume](../intrinsics/assume.md)。

まず、`__restrict` と `__declspec(restrict)` が異なるものであることに注意する必要があります。 この 2 つのキーワードは多少関連がありますが、意味が異なります。 `__restrict` は、`const` や `volatile` のような型修飾子ですが、ポインター型に対してのみ使用できます。

で変更されたポインター`__restrict`は、 __restrict*ポインター*と呼ばれます。 __restrict ポインターは、_restrict ポインターを介してのみアクセスできる\_ポインターです。 つまり、_restrict ポインタが指すデータにアクセスするために別のポインターを\_使用することはできません。

`__restrict`は、Microsoft C++ オプティマイザの強力なツールですが、細心の注意を払って使用できます。 誤って使用すると、オプティマイザーで最適化を実行した結果としてアプリケーションが破壊されることがあります。

この`__restrict`キーワードは、以前のバージョンの **/Oa**スイッチを置き換えます。

を`__assume`使用すると、開発者は、変数の値について仮定するようにコンパイラに指示できます。

たとえば、`__assume(a < 5);` とすると、そのコード行では `a` 変数の値が 5 未満であることがオプティマイザーに伝えられます。 これも、コンパイラにとっての前提になります。 プログラム内のこの時点で `a` が実際には 6 である場合、コンパイラでプログラムを最適化すると、意図したとおりに動作しない可能性があります。 `__assume` は、switch ステートメントや条件式の前で使用するのが最も効果的です。

`__assume` には、いくつかの制約があります。 まず、このキーワードは `__restrict` と同様に推奨されているだけなので、コンパイラに無視される可能性があります。 また、`__assume` は、現在、変数を定数と比較する場合にのみ機能します。 たとえば、(a < b) など、記号的な不等式は伝搬しません。

## <a name="intrinsic-support"></a>組み込みのサポート

組み込みとは、呼び出しに関する情報がコンパイラに組み込まれている関数呼び出しです。コンパイラはライブラリ内の関数を呼び出すのではなく、その関数のコードを出力します。 ヘッダー ファイル\<intrin.h>には、サポートされている各ハードウェア プラットフォームで使用可能なすべての組み込みが含まれています。

組み込みにより、プログラマは、アセンブリを使用しなくても深い部分までコーディングできます。 組み込みを使用することには、いくつかの利点があります。

- 使用しているコードの移植性が高まります。 組み込みのいくつかは、複数の CPU アーキテクチャで使用できます。

- コードは依然として C/C++ で記述されているため、簡単に理解できます。

- コードはコンパイラの最適化による恩恵を受けることができます。 コンパイラが進歩すると、組み込みのコード生成も進歩します。

詳細については、「[コンパイラ組み込み](../intrinsics/compiler-intrinsics.md)」を参照してください。

## <a name="exceptions"></a>例外

例外を使用すると、それによってパフォーマンスに影響があります。 コンパイラによる特定の最適化を防ぐ try ブロックを使用する場合に、いくつかの制限が導入されました。 x86 プラットフォームで try ブロックを使用すると、コードの実行時に追加のステータス情報を生成する必要があるために、パフォーマンスがさらに低下します。 64 ビット プラットフォームでは、try ブロックによってパフォーマンスが大きく低下することはありませんが、例外がスローされると、ハンドラーの検出とスタックのアンワインドの処理に負荷がかかります。

したがって、try ブロックと catch ブロックは、本当に必要である場合を除いて使用しないことをお勧めします。 例外を使用する必要がある場合は、できるだけ同期例外を使用してください。 詳細については、「 [Structured Exception Handling (C/C++)](../cpp/structured-exception-handling-c-cpp.md)」を参照してください。

最後に、例外をスローするのは、例外の場合だけにしてください。 通常の制御フローに例外を使用すると、パフォーマンスが低下します。

## <a name="see-also"></a>関連項目

- [コードの最適化](optimizing-your-code.md)
