---
title: x64 でのスタックの使用
ms.date: 12/17/2018
ms.assetid: 383f0072-0438-489f-8829-cca89582408c
ms.openlocfilehash: b598c33fbdd56630ca3e5ef0da551f38a73baa26
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81335529"
---
# <a name="x64-stack-usage"></a>x64 でのスタックの使用

RSP の現在のアドレスを超えるメモリはすべて揮発性と見なされます: OS またはデバッガーは、ユーザー デバッグ セッション中にこのメモリを上書きする可能性があります、 または割り込みハンドラー。 したがって、スタック フレームに対して値の読み取りまたは書き込みを行う前に、RSP を常に設定する必要があります。

ここでは、ローカル変数と**割**り振り組み用のスタック領域の割り当てについて説明します。

## <a name="stack-allocation"></a>スタック割り当て

関数のプロローグは、ローカル変数、保存されたレジスタ、スタック パラメータ、およびレジスタ パラメータに対してスタック領域を割り当てる役割を担います。

パラメーター領域は常にスタックの一番下に (使用されている`alloca`場合でも) ため、関数呼び出し中は常にリターン アドレスに隣接します。 このファイルには少なくとも 4 つのエントリが含まれますが、呼び出される可能性のある関数で必要なすべてのパラメータを保持するのに常に十分な領域があります。 パラメーター自体がスタックに入れられていない場合でも、レジスタ・パラメーターにスペースが常に割り当てられます。呼び出し先は、すべてのパラメーターにスペースが割り当てられていることが保証されます。 レジスタ引数にはホームアドレスが必要であり、呼び出された関数が引数リスト(va_list)または個々の引数のアドレスを取得する必要がある場合に、連続した領域を使用できるようにします。 この領域は、サンクの実行中やデバッグ オプションとしてレジスタ引数を保存する便利な場所でもあります (たとえば、デバッグ中に、プロローグ コードのホーム アドレスに格納されている引数を見つけやすくします)。 呼び出された関数のパラメーターが 4 つ未満の場合でも、これらの 4 つのスタック位置は、呼び出された関数によって実質的に所有され、パラメーター レジスタ値を保存する以外の目的で呼び出された関数によって使用できます。  したがって、呼び出し元は、関数呼び出しを通して、スタックのこの領域の情報を保存できません。

関数内で空間が動的に割`alloca`り当てられる場合、スタックの固定部分のベースをマークするフレーム ポインタとして不揮発性レジスタを使用する必要があり、そのレジスタを保存してプロローグで初期化する必要があります。 使用すると`alloca`、同じ呼び出し元から同じ呼び出し先への呼び出しが、レジスター・パラメーターに異なるホーム・アドレスを持つ場合があることに注意してください。

スタックは、プロローグ内 (たとえば、リターン アドレスがプッシュされた後) を除いて常に 16 バイトの位置合わせが維持され、特定のクラスのフレーム関数の[関数型](#function-types)で示されている場合を除きます。

次に示すスタック レイアウトの例では、関数 A が非リーフ関数 B を呼び出します。 この呼び出しは戻りアドレスをプッシュし、B のプロローグはローカル変数、不揮発性レジスタ、および関数を呼び出すために必要な領域を割り当てます。 B が`alloca`を使用する場合、スペースはローカル変数/不揮発性レジスター保管域とパラメーター・スタック域の間に割り振られます。

![AMD 変換例](../build/media/vcamd_conv_ex_5.png "AMD 変換例")

関数 B が別の関数を呼び出すと、リターン アドレスは RCX のホーム アドレスのすぐ下にプッシュされます。

## <a name="dynamic-parameter-stack-area-construction"></a>動的パラメータ スタック エリアの構築

フレーム ポインタを使用する場合は、パラメータ スタック領域を動的に作成するオプションが存在します。 これは現在、x64 コンパイラでは実行されません。

## <a name="function-types"></a>関数の種類

基本的に、2 つのタイプの関数があります。 スタックフレームを必要とする関数を*フレーム関数*と呼んでいます。 スタック フレームを必要としない関数は、*リーフ関数*と呼ばれます。

フレーム関数は、スタック領域の割り当て、他の関数の呼び出し、不揮発性レジスタの保存、または例外処理を使用する関数です。 また、関数テーブルエントリも必要です。 フレーム関数にはプロローグとエピローグが必要です。 フレーム関数は、スタック領域を動的に割り当てることができ、フレーム ポインタを使用できます。 フレーム関数は、この呼び出し標準の完全な機能を自由に使用できます。

フレーム関数が別の関数を呼び出さない場合は、スタックを位置合わせする必要はありません (セクション[スタック割り当て](#stack-allocation)で参照)。

リーフ関数は、関数テーブルエントリを必要としない関数です。 RSP を含む不揮発性レジスタに変更を加える必要はありません。 実行中にスタックを整列しないままにしておくことは許可されています。

## <a name="malloc-alignment"></a>マロックアライメント

[malloc](../c-runtime-library/reference/malloc.md)は、基本的な配置を持ち、割り当てられたメモリの量に収まる可能性のあるオブジェクトを格納するために適切に配置されたメモリを返すことを保証されています。 *基本的な配置*とは、配置仕様を指定せずに実装でサポートされている最大の配置以下の配置です。 (Visual C++ の基本的なアラインメントは、`double` つまり 8 バイトに対して必要なアラインメントです。 64 ビット プラットフォームを対象とするコードでは、16 バイトです。たとえば、4 バイトの割り当ては、4 バイトまたは小さい任意のオブジェクトをサポートする境界に位置合わせされます。

Visual C++ では、*拡張配置*を持*つ型を*使用できます。 たとえば、SSE 型[__m128](../cpp/m128.md)と`__m256`、 および where が`__declspec(align( n ))` `n` 8 より大きい場所を使用して宣言された型は、配置が拡張されています。 オブジェクトで拡張アラインメントが必要な場合、そのオブジェクトに適した境界上でのメモリのアラインメントは、`malloc` によって保証されません。 過剰に整列された型にメモリを割り当てるには[、_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md)および関連する関数を使用します。

## <a name="alloca"></a>alloca

[_alloca](../c-runtime-library/reference/alloca.md)は、16 バイトの位置合わせが必要であり、さらにフレーム ポインターを使用する必要があります。

割り当てられるスタックは、後に呼び出される関数のパラメータ用のスペースを含める必要[があります](#stack-allocation)。

## <a name="see-also"></a>関連項目

[x64 ソフトウェア規約](../build/x64-software-conventions.md)<br/>
[配置](../cpp/align-cpp.md)<br/>
[__declspec](../cpp/declspec.md)
