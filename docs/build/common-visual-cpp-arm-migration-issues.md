---
title: Visual C++ の ARM への移行に関する一般的な問題
ms.date: 05/06/2019
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
ms.openlocfilehash: 2c29b4ffa5344b309622314970ce52c47a0ebd05
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81328797"
---
# <a name="common-visual-c-arm-migration-issues"></a>Visual C++ の ARM への移行に関する一般的な問題

Microsoft C++ コンパイラ (MSVC) を使用する場合、同じ C++ ソース コードが、ARM アーキテクチャ上で異なる結果を生成する可能性があります x86 または x64 アーキテクチャで行う場合。

## <a name="sources-of-migration-issues"></a>移行の問題の原因

x86 または x64 アーキテクチャから ARM アーキテクチャにコードを移行するときに発生する可能性のある多くの問題は、未定義、実装定義、または未指定の動作を呼び出す可能性のあるソース コード構造に関連しています。

*未定義の動作*は、C++ 標準が定義していない動作であり、たとえば浮動小数点値を符号なし整数に変換したり、値を負の数だけシフトしたり、その上位の型のビット数を超える位置に値をシフトしたりするなど、妥当な結果を持たない操作によって引き起こされます。

*実装定義の動作*は、C++ 標準でコンパイラ ベンダが定義および文書化する必要がある動作です。 プログラムは、移植性がない場合でも、実装定義の動作に安全に依存できます。 実装定義の動作の例としては、組み込みデータ型のサイズと、それらの配置要件が挙げられます。 実装で定義された動作の影響を受ける可能性のある操作の例として、変数引数リストへのアクセスがあります。

*不特定の動作*は、C++ 標準が意図的に非決定論的な動作を残す動作です。 この動作は非決定的と見なされますが、特定の未指定の動作の呼び出しは、コンパイラの実装によって決定されます。 ただし、コンパイラ ベンダが比較可能な呼び出し間で結果を事前に決定したり、一貫性のある動作を保証したりする必要はなく、ドキュメントの要件もありません。 不特定の動作の例として、関数呼び出しの引数を含むサブ式が評価される順序があります。

その他の移行の問題は、ARM と x86 または x64 アーキテクチャのハードウェアの違いによって、C++ 標準との相互作用が異なる場合があります。 たとえば、x86 および x64 アーキテクチャの強力なメモリ`volatile`モデルは、修飾変数に、過去に特定の種類のスレッド間通信を容易にするために使用された追加のプロパティを提供します。 しかし、ARM アーキテクチャの弱いメモリ モデルでは、この使用はサポートされておらず、C++ 標準ではこの使用が必要です。

> [!IMPORTANT]
> x86 および x64 でスレッド間通信の制限された形式を実装するために使用できるいくつかのプロパティを得るが`volatile`、これらの追加のプロパティは、一般的にスレッド間通信を実装するのに十分ではありません。 C++ 標準では、適切な同期プリミティブを使用してこのような通信を実装することをお勧めします。

プラットフォームによってこのような動作が異なる場合があるため、特定のプラットフォームの動作に依存する場合、プラットフォーム間でソフトウェアを移植するのは困難でバグが発生しやすい場合があります。 このような動作の多くは観察でき、安定しているように見えますが、これらに依存することは少なくとも移植性が低く、未定義または不特定の動作の場合にもエラーになります。 このドキュメントで説明されている動作も、今後のコンパイラや CPU 実装で変更される可能性があります。

## <a name="example-migration-issues"></a>移行の問題の例

このドキュメントの残りの部分では、これらの C++ 言語要素のさまざまな動作が、プラットフォームごとに異なる結果を生成する方法について説明します。

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>浮動小数点から符号なし整数への変換

ARM アーキテクチャでは、浮動小数点値から 32 ビット整数への変換は、浮動小数点値が整数が表すことができる範囲を超えている場合に、整数が表すことができる最も近い値に飽和します。 x86 および x64 アーキテクチャでは、整数が符号なしの場合は変換がラップされ、整数が符号化されている場合は -2147483648 に設定されます。 これらのアーキテクチャのいずれも、浮動小数点値から小さい整数型への変換を直接サポートしていません。その代わり、変換は 32 ビットに実行され、結果は小さいサイズに切り捨てられます。

ARM アーキテクチャでは、サチュレーションと切り捨ての組み合わせにより、符号なし型への変換は、32 ビット整数を飽和させる場合に、小さな符号なし型を正しく飽和しますが、小さい型よりも大きい値では小さいが、32 ビット整数全体を飽和させるには小さすぎる値の場合は、切り捨てられた結果が生成されます。 変換は 32 ビット符号付き整数でも正しく飽和しますが、飽和の符号付き整数の切り捨ては、正の飽和値の場合は -1、負の飽和値では 0 になります。 小さい符号付き整数への変換は、予測不能な、切り捨てられた結果を生成します。

x86 および x64 アーキテクチャでは、符号なし整数変換のラップアラウンド動作とオーバーフロー時の符号付き整数変換の明示的な評価の組み合わせによって、切り捨てと共に、大部分のシフトが大きすぎると、ほとんどのシフトの結果が予測不能になります。

これらのプラットフォームは、NaN (Not-a-Number) から整数型への変換を処理する方法も異なります。 ARM では、NaN は 0x00000000 に変換されます。x86 および x64 では、0x80000000 に変換されます。

浮動小数点変換は、値が変換される整数型の範囲内であることがわかっている場合にのみ使用できます。

### <a name="shift-operator---behavior"></a>シフト演算子\<\<( >>) の動作

ARM アーキテクチャでは、パターンが繰り返し始まる前に、値を左または右に 255 ビットまでシフトできます。 x86 および x64 アーキテクチャでは、パターンのソースが 64 ビット変数でない限り、パターンは 32 の倍数ごとに繰り返されます。その場合、パターンは x64 の 64 の倍数ごとに繰り返され、x86 では 256 の倍数ごとに繰り返されます。 例えば、値が 32 桁で左にシフトされた値が 32 の 32 ビット変数の場合、ARM では結果が 0、x86 では結果は 1、x64 では結果も 1 になります。 ただし、値のソースが 64 ビット変数の場合、3 つのプラットフォームすべてでの結果は 4294967296 であり、x64 で 64 桁、ARM と x86 で 256 桁をシフトするまで値が 「ラップラップ」しません。

ソース・タイプのビット数を超えるシフト操作の結果は未定義であるため、コンパイラーは、すべての状況で一貫した動作を持つ必要はありません。 例えば、コンパイル時にシフトのオペランドが両方とも分かっている場合、コンパイラーは、シフトの結果を事前計算する内部ルーチンを使用してプログラムを最適化し、その結果をシフト演算の代わりに置き換えます。 シフト量が大きすぎる場合、または負の値を指定すると、内部ルーチンの結果が、CPU で実行されるのと同じシフト式の結果と異なる可能性があります。

### <a name="variable-arguments-varargs-behavior"></a>変数引数 (varargs) の動作

ARM アーキテクチャでは、スタックに渡される変数引数リストのパラメーターは、アライメントの対象となります。 たとえば、64 ビットのパラメータは 64 ビット境界に位置合わせされます。 x86 および x64 では、スタックに渡される引数は、整列および厳密なパックの対象となりません。 この違いにより、可変引数リストの予期`printf`されるレイアウトが正確に一致しない場合、可変的な関数が ARM でパディングを意図したメモリアドレスを読み取るといった可変関数が発生する可能性があります。 次の例を考えてみましょう。

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will "parse" the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

この場合、バグは、正しい書式指定が使用され、引数のアライメントが考慮されるようにすることで修正できます。 このコードは正しいものです。

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>引数の評価順序

ARM、x86、および x64 プロセッサは非常に異なるため、コンパイラの実装に対して異なる要件を提示でき、最適化の機会も異なります。 このため、呼び出し規約や最適化設定などの他の要素と共に、コンパイラは異なるアーキテクチャで関数の引数を異なる順序で評価したり、他の要素が変更されたときに関数の引数を評価する場合があります。 これにより、特定の評価順序に依存するアプリの動作が予期せず変更される可能性があります。

この種のエラーは、関数の引数に、同じ呼び出しで関数に対する他の引数に影響を与える副作用がある場合に発生する可能性があります。 通常、このような依存関係は避けやすいですが、識別が困難な依存関係や演算子のオーバーロードによって隠される場合があります。 次のコード例を考えてみます。

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

これは明確に定義されているように見えますが`->`、`*`演算子がオーバーロードされている場合、このコードは次のようなコードに変換されます。

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

また、 と`operator->(memory_handle)``operator*(p)`の間に依存関係がある場合、元のコードは依存関係が存在しないように見えても、特定の評価順序に依存する可能性があります。

### <a name="volatile-keyword-default-behavior"></a>volatile キーワードのデフォルト動作

MSVC コンパイラは、コンパイラ スイッチを使用`volatile`して指定できるストレージ修飾子の 2 つの異なる解釈をサポートします。 [/volatile:ms](reference/volatile-volatile-keyword-interpretation.md)スイッチは、これらのアーキテクチャの強力なメモリ モデルのために、x86 および x64 の従来のケースと同様に、厳密な順序を保証する Microsoft 拡張揮発性セマンティクスを選択します。 [/volatile:iso](reference/volatile-volatile-keyword-interpretation.md)スイッチは、厳密な順序を保証しない厳密な C++ 標準揮発性セマンティクスを選択します。

ARM のプロセッサは、メモリ モデルが弱く順序付けされていないため、デフォルトは **/volatile:iso**です。 **/volatile:ms** ただし、拡張セマンティクスを使用するために ARM プログラムをコンパイルする場合でも便利な場合もあります。 たとえば、プログラムを移植して ISO C++ のセマンティクスを使用するにはコストがかかりすぎる場合や、ドライバ ソフトウェアが正しく機能するために従来のセマンティクスに従わなければならない場合があります。 このような場合は **、/volatile:ms**スイッチを使用できます。ただし、ARM ターゲットで従来の揮発性セマンティクスを再現するには、コンパイラは`volatile`変数の読み取りまたは書き込みのたびにメモリ バリアを挿入して、厳密な順序付けを適用する必要があり、パフォーマンスに悪影響を与える可能性があります。

x86 および x64 アーキテクチャでは、MSVC を使用してこれらのアーキテクチャ用に既に作成されているソフトウェアの多くがそれらのアーキテクチャに依存しているため、デフォルトは **/volatile:ms**です。 x86 および x64 プログラムをコンパイルする場合 **、/volatile:iso**スイッチを指定すると、従来の揮発性セマンティクスに不要な依存を避け、移植性を高めることができます。

## <a name="see-also"></a>関連項目

[ARM プロセッサ用の Visual C ++ の構成する](configuring-programs-for-arm-processors-visual-cpp.md)
