---
title: x64 での呼び出し規則
description: 既定の x64 ABI 呼び出し規則の詳細。
ms.date: 12/17/2018
ms.assetid: 41ca3554-b2e3-4868-9a84-f1b46e6e21d9
ms.openlocfilehash: caf22172ea5e9c20280bce8e508d72fd30c00c5b
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81335126"
---
# <a name="x64-calling-convention"></a>x64 での呼び出し規則

このセクションでは、x64 コードで 1 つの関数 (呼び出し元) から別の関数 (呼び出し先) への呼び出しを行う際に使用する標準プロセスと規則について説明します。

## <a name="calling-convention-defaults"></a>呼び出し規則の既定値

x64 アプリケーション バイナリ インターフェイス (ABI) では、既定で 4 レジスタ、高速呼び出しの呼び出し規則が使用されます。 呼び出し履歴には、呼び出し先がそのレジスタを保存するためのシャドウ ストアとして領域が割り当てられます。 関数呼び出しに対する引数とそれらの引数用に使用されるレジスタとの間には、厳密に 1 対 1 の対応があります。 8 バイトに収まらない、または 1、2、4、または 8 バイトではない引数は、参照渡しする必要があります。 1 つの引数が複数のレジスタにまたがって分散されることはありません。 x87 レジスタ スタックは使用されず、呼び出し先によって使用される場合がありますが、関数呼び出し間で volatile と見なされる必要があります。 すべての浮動小数点演算は、16 個の XMM レジスタを使用して実行されます。 整数の引数はレジスタ RCX、RDX、R8、および R9 で渡されます。 浮動小数点の引数は、XMM0L、XMM1L、XMM2L、および XMM3L で渡されます。 16 バイトの引数は参照渡しされます。 パラメーター渡しの詳細については、「[パラメーター渡し](#parameter-passing)」をご覧ください。 これらのレジスタに加えて、RAX、R10、R11、XMM4、および XMM5 が volatile と見なされます。 他のすべてのレジスタは非 volatile です。 レジスタの使用方法については、「[レジスタの使用](../build/x64-software-conventions.md#register-usage)」と「[呼び出し元または呼び出し先保存済みレジスタ](#callercallee-saved-registers)」に詳しく記載されています。

プロトタイプ関数の場合、すべての引数が想定される呼び出し先の型に変換されてから渡されます。 呼び出し元は、パラメーター用の領域を呼び出し先に割り当てる役割を担います。また、呼び出し先で 4 個のパラメーターが取得されない場合でも、4 個のレジスタ パラメーターを格納するのに十分な領域を常に割り当てる必要があります。 この規則により、プロトタイプ宣言されていない C 言語関数と vararg C/C++ 関数のサポートが簡略化されます。 vararg 関数またはプロトタイプ宣言されていない関数では、すべての浮動小数点値が、対応する汎用レジスタに複製される必要があります。 最初の 4 つを超えるすべてのパラメーターは、呼び出しの前に、シャドウ ストアの後にスタック上に格納する必要があります。 vararg 関数の詳細については、「[vararg](#varargs)」をご覧ください。 プロトタイプ宣言されていない関数の詳細については、「[プロトタイプ宣言されていない関数](#unprototyped-functions)」をご覧ください。

## <a name="alignment"></a>アラインメント

ほとんどの構造体は、その自然なアラインメントに合わせてアラインされます。 主な例外は、スタック ポインターと `malloc` または `alloca` メモリです。これらは、パフォーマンスを向上させるために、16 バイトにアラインされます。 16 バイトを超えるアラインメントは手動で実行する必要がありますが、16 バイトが XMM 操作の一般的なアラインメント サイズであるため、ほとんどのコードはこの値で動作するはずです。 構造体レイアウトとアラインメントの詳細については、「[型とストレージ](../build/x64-software-conventions.md#types-and-storage)」をご覧ください。 スタック レイアウトの詳細については、「[x64 でのスタックの使用](../build/stack-usage.md)」をご覧ください。

## <a name="unwindability"></a>アンワインド可能性

リーフ関数は、非 volatile レジスタを変更しない関数です。 非リーフ関数では、たとえば関数を呼び出したり、ローカル変数に追加のスタック領域を割り当てたりすることで、非 volatile の RSP が変更される場合があります。 例外が処理されたときに非 volatile レジスタを回復するには、任意の命令で関数を適切にアンワインドする方法を記述した静的データを使用して、非リーフ関数に注釈を付ける必要があります。 このデータは *pdata*、またはプロシージャ データとして格納されます。これによって次に、例外処理データである *xdata* が参照されます。 xdata にはアンワインドに関する情報が含まれており、追加の pdata または例外ハンドラー関数を指すことができます。 プロローグとエピローグは、xdata で適切に記述できるように、厳しく制限されています。 スタック ポインターは、リーフ関数内を除き、エピローグまたはプロローグに含まれないコードの任意の領域で 16 バイトにアラインする必要があります。 リーフ関数は、戻り値をシミュレートするだけでアンワインドできます。そのため、pdata と xdata は必要ありません。 関数プロローグとエピローグの適切な構造の詳細については、「[x64 でのプロローグとエピローグ](../build/prolog-and-epilog.md)」をご覧ください。 例外処理と、pdata および xdata の例外処理とアンワインドの詳細については、「[x64 での例外処理](../build/exception-handling-x64.md)」をご覧ください。

## <a name="parameter-passing"></a>パラメーター渡し

最初の 4 つの整数の引数は、レジスタで渡されます。 整数値は、左から右の順序で、それぞれ RCX、RDX、R8、および R9 で渡されます。 5 番目以降の引数は、スタックで渡されます。 すべての引数がレジスタで右揃えになるため、呼び出し先ではレジスタの上位ビットを無視し、必要なレジスタの部分にのみアクセスできます。

最初の 4 つのパラメーターに含まれる浮動小数点の引数と倍精度の引数は、位置に応じて XMM0 - XMM3 で渡されます。 通常これらの位置に使用される整数レジスタ RCX、RDX、R8、および R9 は、vararg 引数の場合を除き、無視されます。 詳細については、「[vararg](#varargs)」をご覧ください。 同様に、対応する引数が整数型またはポインター型の場合 XMM0 - XMM3 レジスタは無視されます。

[__m128](../cpp/m128.md) 型、配列、および文字列がイミディエイト値によって渡されることはありません。 代わりに、呼び出し元によって割り当てられたメモリへのポインターが渡されます。 サイズが 8、16、32、または 64 ビットの構造体と共用体、および __m64 型は、同じサイズの整数であるかのように渡されます。 他のサイズの構造体または共用体は、呼び出し元によって割り当てられたメモリへのポインターとして渡されます。 ポインターとして渡されるこれらの集約型 (\__m128 を含む) については、呼び出し元によって割り当てられた一時メモリが 16 バイトでアラインされている必要があります。

スタック領域を割り当てず、他の関数を呼び出さない組み込み関数では、追加のレジスタ引数を渡すために他の volatile レジスタが使用されることがあります。 この最適化は、コンパイラと組み込み関数の実装との間の緊密なバインドによって可能になります。

呼び出し先は、必要に応じてレジスタ パラメーターをシャドウ スペースにダンプする役割を担います。

次の表は、パラメーターを渡す方法をまとめたものです。

|パラメーターのタイプ|渡す方法|
|--------------------|----------------|
|浮動小数点数|最初の 4 つのパラメーター - XMM0 から XMM3。 その他はスタックで渡されます。|
|整数型|最初の 4 つのパラメーター - RCX、RDX、R8、R9。 その他はスタックで渡されます。|
|集計型 (8、16、32、または 64 ビット) と __m64|最初の 4 つのパラメーター - RCX、RDX、R8、R9。 その他はスタックで渡されます。|
|集約型 (その他)|ポインターで渡されます。 最初の 4 つのパラメーターはポインターで RCX、RDX、R8、および R9 で渡されます|
|__m128|ポインターで渡されます。 最初の 4 つのパラメーターはポインターで RCX、RDX、R8、および R9 で渡されます|

### <a name="example-of-argument-passing-1---all-integers"></a>引数渡しの例 1 - すべて整数

```cpp
func1(int a, int b, int c, int d, int e);
// a in RCX, b in RDX, c in R8, d in R9, e pushed on stack
```

### <a name="example-of-argument-passing-2---all-floats"></a>引数渡しの例 2 - すべて浮動小数点数

```cpp
func2(float a, double b, float c, double d, float e);
// a in XMM0, b in XMM1, c in XMM2, d in XMM3, e pushed on stack
```

### <a name="example-of-argument-passing-3---mixed-ints-and-floats"></a>引数渡しの例 3 - 整数と浮動小数点数の混合

```cpp
func3(int a, double b, int c, float d);
// a in RCX, b in XMM1, c in R8, d in XMM3
```

### <a name="example-of-argument-passing-4--__m64-__m128-and-aggregates"></a>引数渡しの例 4 - __m64、\__m128、および集約型

```cpp
func4(__m64 a, _m128 b, struct c, float d);
// a in RCX, ptr to b in RDX, ptr to c in R8, d in XMM3
```

## <a name="varargs"></a>vararg

パラメーターが vararg を使用して渡される場合 (例: 省略記号の引数)、通常のレジスタ パラメーター渡しの規則 (5 番目以降の引数をスタックに書き込むなど) が適用されます。 アドレスが取得された引数をダンプするのは、呼び出し先の責任です。 浮動小数点値のみの場合、呼び出し先が整数レジスタの値を想定する場合に備えて、整数レジスタと浮動小数点レジスタの両方に値を含める必要があります。

## <a name="unprototyped-functions"></a>プロトタイプ宣言されていない関数

完全にプロトタイプ宣言されていない関数の場合、呼び出し元は整数値を整数として、浮動小数点値を倍精度として渡します。 浮動小数点値のみの場合、呼び出し先が整数レジスタの値を想定する場合に備えて、整数レジスタと浮動小数点レジスタの両方に浮動小数点値を含めます。

```cpp
func1();
func2() {   // RCX = 2, RDX = XMM1 = 1.0, and R8 = 7
   func1(2, 1.0, 7);
}
```

## <a name="return-values"></a>戻り値

64 ビットに収まるスカラー戻り値は、RAX を使用して返されます。これには __m64 型が含まれます。 float 型、double 型、および [__m128](../cpp/m128.md)、[__m128i](../cpp/m128i.md)、[__m128d](../cpp/m128d.md) などのベクター型を含む非スカラー型は、XMM0 で返されます。 RAX や XMM0 で返される値の未使用ビットの状態は未定義です。

ユーザー定義型は、グローバル関数や静的メンバー関数からの値で返すことができます。 RAX の値によってユーザー定義型を返すには、その長さが 1、2、4、8、16、32、または 64 ビットである必要があります。 また、ユーザー定義型のコンストラクター、デストラクター、またはコピー代入演算子を持たず、プライベートまたは保護された非静的データ メンバーを持たず、参照型の非静的データ メンバーを持たず、基底クラスを持たず、仮想関数を持たず、これらの要件を満たさないデータ メンバーも持たない必要があります。 (これは、実質的には C++03 POD 型の定義です。 C++11 標準ではこの定義は変更されているため、このテストに `std::is_pod` を使うことはお勧めしません。)それ以外の場合、呼び出し元は、メモリを割り当て、最初の引数として戻り値用のポインターを渡す責任を担います。 後続する引数は、引数 1 つ分だけ右にシフトされます。 RAX 内の呼び出し先は同じポインターを返す必要があります。

以下の例は、宣言を指定して関数に対してパラメーターと戻り値を渡す方法を示しています。

### <a name="example-of-return-value-1---64-bit-result"></a>戻り値の例 1 - 64 ビットの結果

```Output
__int64 func1(int a, float b, int c, int d, int e);
// Caller passes a in RCX, b in XMM1, c in R8, d in R9, e pushed on stack,
// callee returns __int64 result in RAX.
```

### <a name="example-of-return-value-2---128-bit-result"></a>戻り値の例 2 - 128 ビットの結果

```Output
__m128 func2(float a, double b, int c, __m64 d);
// Caller passes a in XMM0, b in XMM1, c in R8, d in R9,
// callee returns __m128 result in XMM0.
```

### <a name="example-of-return-value-3---user-type-result-by-pointer"></a>戻り値の例 3 - ポインターによるユーザー型の結果

```Output
struct Struct1 {
   int j, k, l;    // Struct1 exceeds 64 bits.
};
Struct1 func3(int a, double b, int c, float d);
// Caller allocates memory for Struct1 returned and passes pointer in RCX,
// a in RDX, b in XMM2, c in R9, d pushed on the stack;
// callee returns pointer to Struct1 result in RAX.
```

### <a name="example-of-return-value-4---user-type-result-by-value"></a>戻り値の例 4 - 値によるユーザー型の結果

```Output
struct Struct2 {
   int j, k;    // Struct2 fits in 64 bits, and meets requirements for return by value.
};
Struct2 func4(int a, double b, int c, float d);
// Caller passes a in RCX, b in XMM1, c in R8, and d in XMM3;
// callee returns Struct2 result by value in RAX.
```

## <a name="callercallee-saved-registers"></a>呼び出し元または呼び出し先保存済みレジスタ

レジスタ RAX、RCX、RDX、R8、R9、R10、R11、XMM0-5、および YMM0-15 と ZMM0-15 の上位部分は volatile であると見なされ、関数呼び出しで破棄されると見なされる必要があります (プログラム全体の最適化などのその他の分析によって安全性を確認できる場合を除く)。 AVX512VL では、ZMM、YMM、および XMM レジスタ 16-31 は volatile です。

レジスタ RBX、RBP、RDI、RSI、RSP、R12、R13、R14、R15、および XMM6-15 は非 volatile と見なされ、それらを使用する関数によって保存および復元される必要があります。

## <a name="function-pointers"></a>関数ポインター

関数ポインターは、単純にそれぞれの関数のラベルへのポインターです。 関数ポインターには目次 (TOC) の要件はありません。

## <a name="floating-point-support-for-older-code"></a>古いコードのための浮動小数点サポート

MMX および浮動小数点スタック レジスタ (MM0-MM7、ST0-ST7) は、コンテキ ストスイッチ間で保持されます。 これらのレジスタ用の明示的な呼び出し規則はありません。 これらのレジスタの使用は、カーネル モードのコードでは厳密には禁止されています。

## <a name="fpcsr"></a>FpCsr

レジスタの状態には、x87 FPU 制御ワードも含まれます。 呼び出し規則では、このレジスタが非 volatile であると指定されます。

x87 FPU 制御ワード レジスタは、プログラムの実行開始時に次の標準値に設定されます。

| レジスタ\[ビット] | 設定 |
|-|-|
| FPCSR\[0:6] | 例外によってすべての 1 がマスクされる (すべての例外がマスクされる) |
| FPCSR\[7] | 予約済み - 0 |
| FPCSR\[8:9] | 精度制御 - 10B (倍精度) |
| FPCSR\[10:11] | 丸め制御 - 0 (最も近い値に丸める) |
| FPCSR\[12] | 無限制御 - 0 (使用されません) |

呼び出し先で FPCSR 内のいずれかのフィールドを変更した場合は、それらを復元してから呼び出し元に返す必要があります。 また、呼び出し元でこれらのフィールドのいずれかを変更した場合は、呼び出し先で合意により変更された値が想定されていない限り、そのフィールドをその標準値に復元してから呼び出し先を呼び出す必要があります。

制御フラグの非 volatile 性に関する規則には、次の 2 つの例外があります。

1. 指定された関数のドキュメント化された目的が、非 volatile FpCsr フラグを変更することであるような関数内。

1. プログラムがこれらの規則に違反しても、(たとえばプログラム全体の分析を通じて) これらの規則に違反しなかった場合と同じように動作するのが明らかに正しい場合。

## <a name="mxcsr"></a>MxCsr

レジスタの状態には、MxCsr も含まれています。 呼び出し規則では、このレジスタは volatile の部分と非 volatile の部分に分割されます。 volatile の部分は MXCSR\[0:5] 内の 6 つの状態フラグで構成され、レジスタの残りの部分 MXCSR\[6:15] は非 volatile であると見なされます。

非 volatile の部分は、プログラムの実行開始時に次の標準値に設定されます。

| レジスタ\[ビット] | 設定 |
|-|-|
| MXCSR\[6] | 非正規化数はゼロ - 0 |
| MXCSR\[7:12] | 例外によってすべての 1 がマスクされる (すべての例外がマスクされる) |
| MXCSR\[13:14] | 丸め制御 - 0 (最も近い値に丸める) |
| MXCSR\[15] | マスクされたアンダーフロー用にゼロにフラッシュ - 0 (オフ) |

呼び出し先で MXCSR 内のいずれかの非 volatile フィールドを変更した場合は、それらを復元してから呼び出し元に返す必要があります。 また、呼び出し元でこれらのフィールドのいずれかを変更した場合は、呼び出し先で合意により変更された値が想定されていない限り、そのフィールドをその標準値に復元してから呼び出し先を呼び出す必要があります。

制御フラグの非 volatile 性に関する規則には、次の 2 つの例外があります。

- 指定された関数のドキュメント化された目的が、非 volatile MxCsr フラグを変更することであるような関数内。

- プログラムがこれらの規則に違反しても、(たとえばプログラム全体の分析を通じて) これらの規則に違反しなかった場合と同じように動作するのが明らかに正しい場合。

関数のドキュメントで特に説明されていない限り、関数の境界を越えて MXCSR の volatile の部分の状態について何かを想定することはできません。

## <a name="setjmplongjmp"></a>setjmp、longjmp

setjmpex.h または setjmp.h をインクルードする場合、[setjmp](../c-runtime-library/reference/setjmp.md) または [longjmp](../c-runtime-library/reference/longjmp.md) を呼び出すたびに、デストラクターと `__finally` を呼び出すアンワインドが発生します。  これは x86 とは異なります。x86 では、setjmp.h をインクルードすると `__finally` 句が生成され、デストラクターが呼び出されません。

`setjmp` を呼び出すと、現在のスタック ポインター、非 volatile レジスタ、および MxCsr レジスタが保持されます。  `longjmp` を呼び出すと、最も新しい `setjmp` の呼び出しサイトに戻り、スタック ポインター、非 volatile レジスタ、および MxCsr レジスタが、最も新しい `setjmp` 呼び出しによって保持されている状態にリセットされます。

## <a name="see-also"></a>関連項目

[x64 ソフトウェア規約](../build/x64-software-conventions.md)
