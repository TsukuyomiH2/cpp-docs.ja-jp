---
title: x64 での呼び出し規則
description: 既定の x64 ABI 呼び出し規約の詳細。
ms.date: 12/17/2018
ms.assetid: 41ca3554-b2e3-4868-9a84-f1b46e6e21d9
ms.openlocfilehash: 5b9801eff6a9789313d083fdd6ed69c3076643ad
ms.sourcegitcommit: 8e285a766523e653aeeb34d412dc6f615ef7b17b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/21/2020
ms.locfileid: "80078083"
---
# <a name="x64-calling-convention"></a>x64 での呼び出し規則

このセクションでは、1つの関数 (呼び出し元) が x64 コードで別の関数 (呼び出し先) への呼び出しを行うために使用する標準のプロセスと規則について説明します。

## <a name="calling-convention-defaults"></a>呼び出し規約の既定値

X64 アプリケーションバイナリインターフェイス (ABI) では、既定で4レジスタ高速呼び出し規約が使用されます。 呼び出し履歴には、そのレジスタを保存するための呼び出し先のシャドウストアとして領域が割り当てられます。 関数呼び出しへの引数と、それらの引数に使用されるレジスタとの間には、厳密に1対1の対応があります。 8バイトに収まらない、または1、2、4、または8バイトではない引数は、参照によって渡す必要があります。 1つの引数が複数のレジスタにまたがって分散されることはありません。 X87 レジスタスタックは使用されておらず、呼び出し先によって使用される場合がありますが、関数呼び出し間で volatile と見なされる必要があります。 すべての浮動小数点演算は、16個の XMM レジスタを使用して実行されます。 整数引数はレジスタの RCX、RDX、R8、および R9 で渡されます。 浮動小数点引数は、XMM0L、XMM1L、XMM2L、および XMM3L で渡されます。 16バイトの引数は参照によって渡されます。 パラメーターパッシングの詳細については、「[パラメーターの引き渡し](#parameter-passing)」を参照してください。 これらのレジスタに加えて、RAX、R10、R11、XMM4、および XMM5 は volatile と見なされます。 他のすべてのレジスタは非揮発性です。 レジスタの使用状況の詳細については、「レジスタの[使用状況](../build/x64-software-conventions.md#register-usage)」と「[呼び出し元/呼び出し先](#callercallee-saved-registers)」をご覧ください。

プロトタイプ関数の場合、渡される前にすべての引数が必要な呼び出し先の型に変換されます。 呼び出し元は、パラメーターの領域を呼び出し先に割り当てる役割を担います。また、呼び出し先が多くのパラメーターを取らない場合でも、4つのレジスタパラメーターを格納するのに十分な領域を常に割り当てる必要があります。 この規則により、unprototyped C 言語関数と vararg C/C++ functions のサポートが簡略化されます。 Vararg 関数または unprototyped 関数では、すべての浮動小数点値が、対応する汎用レジスタに重複している必要があります。 最初の4つを超えるすべてのパラメーターは、呼び出しの前にシャドウストアの後にスタックに格納する必要があります。 Vararg 関数の詳細については、 [Varargs](#varargs)を参照してください。 Unprototyped 関数の情報については、 [Unprototyped 関数](#unprototyped-functions)を参照してください。

## <a name="alignment"></a>Alignment

ほとんどの構造体は、自然な配置に合わせて配置されます。 主な例外は、パフォーマンスを向上させるために、スタックポインターと `malloc` または `alloca` メモリです。 16バイトを超えるアラインメントは手動で実行する必要がありますが、16バイトは XMM 操作のアラインメントサイズが一般的であるため、ほとんどのコードでこの値を使用する必要があります。 構造体のレイアウトと配置の詳細については、「[型とストレージ](../build/x64-software-conventions.md#types-and-storage)」を参照してください。 スタックレイアウトの詳細については、「 [x64 stack usage](../build/stack-usage.md)」を参照してください。

## <a name="unwindability"></a>Unwindability

リーフ関数は、非 volatile レジスタを変更しない関数です。 非リーフ関数は、たとえば関数を呼び出したり、ローカル変数に追加のスタック領域を割り当てたりすることによって、非 volatile の RSP を変更する場合があります。 例外が処理されたときに非揮発性レジスタを回復するには、非リーフ関数に、任意の命令で関数を適切にアンワインドする方法を記述した静的データで注釈を付ける必要があります。 このデータは、 *pdata*として格納されます。また、プロシージャデータは、例外処理データである *.xdata*を表します。 .Xdata には、アンワインド情報が含まれており、追加の pdata または例外ハンドラー関数を指すことができます。 Prologs とエピローグは、.xdata で適切に記述できるように、非常に制限されています。 スタックポインターは、リーフ関数内を除き、エピローグまたはプロローグの一部ではないコードの任意の領域で16バイトにアラインする必要があります。 リーフ関数は、戻り値をシミュレートするだけでアンワインドできます。したがって、pdata と .xdata は必要ありません。 関数プロローグとエピローグの適切な構造の詳細については、「 [x64 プロローグとエピローグ](../build/prolog-and-epilog.md)」を参照してください。 例外処理、および pdata と .xdata の例外処理とアンワインドの詳細については、「 [x64 例外処理](../build/exception-handling-x64.md)」を参照してください。

## <a name="parameter-passing"></a>パラメーター渡し

最初の4つの整数引数はレジスタで渡されます。 整数値は、それぞれ RCX、RDX、R8、および R9 で左から右の順序で渡されます。 スタックには、引数5以上が渡されます。 レジスタではすべての引数が右揃えになっているため、呼び出し先はレジスタの上位ビットを無視し、必要なレジスタの部分のみにアクセスできます。

最初の4つのパラメーターのすべての浮動小数点引数と倍精度引数は、位置に応じて XMM0-XMM3 で渡されます。 これらの位置に通常使用される RCX、RDX、R8、および R9 を登録する整数は、varargs 引数の場合を除き、無視されます。 詳細については、「 [Varargs](#varargs)」を参照してください。 同様に、対応する引数が整数型またはポインター型の場合、XMM0 XMM3 レジスタは無視されます。

[__m128](../cpp/m128.md)型、配列、および文字列は、直接値によって渡されることはありません。 代わりに、呼び出し元によって割り当てられたメモリにポインターが渡されます。 サイズが8、16、32、または64ビットの構造体と共用体と __m64 型は、同じサイズの整数であるかのように渡されます。 他のサイズの構造体または共用体は、呼び出し元によって割り当てられたメモリへのポインターとして渡されます。 \__m128 を含むポインターとして渡されるこれらの集計型については、呼び出し元によって割り当てられた一時メモリが16バイトでアラインされている必要があります。

スタック領域を割り当てず、他の関数を呼び出さない組み込み関数は、他の揮発性レジスタを使用して追加のレジスタ引数を渡すことがあります。 この最適化は、コンパイラと組み込み関数の実装の間の密バインディングによって可能になります。

呼び出し先は、必要に応じて、レジスタパラメーターをシャドウスペースにダンプする役割を担います。

次の表は、パラメーターを渡す方法をまとめたものです。

|パラメーターのタイプ|成功した方法|
|--------------------|----------------|
|浮動小数点|最初の4つのパラメーター-XMM0 から XMM3。 スタックで渡された他のユーザー。|
|整数|最初の4つのパラメーター-RCX、RDX、R8、R9。 スタックで渡された他のユーザー。|
|集計 (8、16、32、または64ビット) と __m64|最初の4つのパラメーター-RCX、RDX、R8、R9。 スタックで渡された他のユーザー。|
|集計 (その他)|ポインターで。 RCX、RDX、R8、および R9 でポインターとして渡された最初の4つのパラメーター|
|__m128|ポインターで。 RCX、RDX、R8、および R9 でポインターとして渡された最初の4つのパラメーター|

### <a name="example-of-argument-passing-1---all-integers"></a>1を渡す引数の例-すべての整数

```cpp
func1(int a, int b, int c, int d, int e);
// a in RCX, b in RDX, c in R8, d in R9, e pushed on stack
```

### <a name="example-of-argument-passing-2---all-floats"></a>2を渡す引数の例-all float

```cpp
func2(float a, double b, float c, double d, float e);
// a in XMM0, b in XMM1, c in XMM2, d in XMM3, e pushed on stack
```

### <a name="example-of-argument-passing-3---mixed-ints-and-floats"></a>3を渡す引数の例 3-混合 int と float

```cpp
func3(int a, double b, int c, float d);
// a in RCX, b in XMM1, c in R8, d in XMM3
```

### <a name="example-of-argument-passing-4--__m64-__m128-and-aggregates"></a>4 __m64、\__m128、および集計を渡す引数の例

```cpp
func4(__m64 a, _m128 b, struct c, float d);
// a in RCX, ptr to b in RDX, ptr to c in R8, d in XMM3
```

## <a name="varargs"></a>vararg

パラメーターが varargs (省略記号の引数など) を使用して渡された場合、通常のレジスタパラメーターの引き渡し規則が適用されます。これには、5番目以降の引数をスタックに書き込むすることが含まれます。 アドレスが取得された引数をダンプするのは、呼び出し先の責任です。 浮動小数点値の場合のみ、呼び出し先が整数レジスタの値を必要とする場合、整数レジスタと浮動小数点レジスタの両方に値が含まれている必要があります。

## <a name="unprototyped-functions"></a>Unprototyped 関数

完全にプロトタイプ宣言されていない関数の場合、呼び出し元は整数値と浮動小数点値を倍精度として渡します。 浮動小数点値の場合のみ、呼び出し先が整数レジスタの値を必要とする場合、整数レジスタと浮動小数点レジスタの両方に float 値が含まれます。

```cpp
func1();
func2() {   // RCX = 2, RDX = XMM1 = 1.0, and R8 = 7
   func1(2, 1.0, 7);
}
```

## <a name="return-values"></a>戻り値

64ビットに収めることができるスカラー戻り値は、RAX を通じて返されます。これには __m64 型が含まれます。 Float 型、double 型、および[__m128](../cpp/m128.md)、 [__m128i](../cpp/m128i.md)、 [__m128d](../cpp/m128d.md)などのベクター型を含む非スカラー型は、XMM0 で返されます。 RAX や XMM0 で返される値の未使用ビットの状態は未定義です。

ユーザー定義型は、グローバル関数や静的メンバー関数からの値で返すことができます。 RAX の値によってユーザー定義型を返すには、長さが1、2、4、8、16、32、または64ビットである必要があります。 また、ユーザー定義のコンストラクター、デストラクター、またはコピー代入演算子も含まれている必要があります。プライベートまたは保護された非静的データメンバーはありません。参照型の非静的データメンバーはありません。基底クラスはありません。仮想関数がありません。また、これらの要件を満たしていないデータメンバーはありません。 (これは、実質的には C++03 POD 型の定義です。 C++ 11 標準では定義が変更されているため、このテストには `std::is_pod` を使用しないことをお勧めします)。それ以外の場合、呼び出し元はメモリを割り当て、最初の引数として戻り値のポインターを渡す責任を担います。 後続する引数は、引数 1 つ分だけ右にシフトされます。 RAX 内の呼び出し先は同じポインターを返す必要があります。

以下の例は、宣言を指定して関数に対してパラメーターと戻り値を渡す方法を示しています。

### <a name="example-of-return-value-1---64-bit-result"></a>戻り値 1-64 ビットの結果の例

```Output
__int64 func1(int a, float b, int c, int d, int e);
// Caller passes a in RCX, b in XMM1, c in R8, d in R9, e pushed on stack,
// callee returns __int64 result in RAX.
```

### <a name="example-of-return-value-2---128-bit-result"></a>戻り値 2-128 ビットの結果の例

```Output
__m128 func2(float a, double b, int c, __m64 d);
// Caller passes a in XMM0, b in XMM1, c in R8, d in R9,
// callee returns __m128 result in XMM0.
```

### <a name="example-of-return-value-3---user-type-result-by-pointer"></a>戻り値の例 3-ポインターによるユーザー型の結果

```Output
struct Struct1 {
   int j, k, l;    // Struct1 exceeds 64 bits.
};
Struct1 func3(int a, double b, int c, float d);
// Caller allocates memory for Struct1 returned and passes pointer in RCX,
// a in RDX, b in XMM2, c in R9, d pushed on the stack;
// callee returns pointer to Struct1 result in RAX.
```

### <a name="example-of-return-value-4---user-type-result-by-value"></a>戻り値の例 4-値によるユーザー型の結果

```Output
struct Struct2 {
   int j, k;    // Struct2 fits in 64 bits, and meets requirements for return by value.
};
Struct2 func4(int a, double b, int c, float d);
// Caller passes a in RCX, b in XMM1, c in R8, and d in XMM3;
// callee returns Struct2 result by value in RAX.
```

## <a name="callercallee-saved-registers"></a>呼び出し元/呼び出し先に保存されたレジスタ

レジスタ RAX、RCX、RDX、R8、R9、R10、R11、、、XMM0、YMM0 ~ YMM5-5、および ZMM0-15 の上位部分は volatile であると見なされ、関数呼び出しで破棄されると見なされる必要があります (プログラム全体の最適化などの分析によって、その他の安全ではない場合)。 AVX512VL では、ZMM、YMM、および XMM レジスタ16-31 は揮発性です。

レジスタ RBX、RBX、RDI、RSI、RSP、R12、R13、R14、R15、および XMM6-15 は不揮発性と見なされ、それらを使用する関数によって保存および復元される必要があります。

## <a name="function-pointers"></a>関数ポインター

関数ポインターは、それぞれの関数のラベルへのポインターです。 関数ポインターには目次 (TOC) の要件はありません。

## <a name="floating-point-support-for-older-code"></a>古いコードの浮動小数点サポート

MMX および浮動小数点のスタックレジスタ (MM0-MM7/ST0) は、コンテキストスイッチ間で保持されます。 これらのレジスタに明示的な呼び出し規約はありません。 これらのレジスタの使用は、カーネルモードのコードでは厳密には禁止されています。

## <a name="fpcsr"></a>FpCsr

レジスタの状態には、x87 FPU 制御ワードも含まれます。 呼び出し規約は、このレジスタを不揮発性として指定します。

X87 FPU 制御ワードレジスタは、プログラムの実行開始時に次の標準値に設定されます。

| \[ビットの登録] | 設定 |
|-|-|
| FPCSR\[0:6] | 例外によって1のすべての例外がマスクされる (すべての例外がマスクされる) |
| FPCSR\[7] | 予約済み-0 |
| FPCSR\[8:9] | Precision 10B (倍精度) |
| FPCSR\[10:11] | 制御の丸め-0 (近似値に丸める) |
| FPCSR\[12] | 無限大制御-0 (使用されていません) |

FPCSR 内のいずれかのフィールドを変更する呼び出し先は、呼び出し元に戻る前にこれらを復元する必要があります。 また、これらのフィールドのいずれかを変更した呼び出し元は、呼び出し先が変更された値を想定していない限り、呼び出し先を呼び出す前に、それらのフィールドを標準値に復元する必要があります。

制御フラグの非揮発性に関する規則には、次の2つの例外があります。

1. 特定の関数のドキュメント化された目的で、不揮発性 FpCsr フラグを変更する関数。

1. これらの規則に違反すると、プログラム全体の分析など、これらの規則に違反していないプログラムと同じように動作するプログラムが provably されます。

## <a name="mxcsr"></a>MxCsr

登録状態には、MxCsr も含まれています。 呼び出し規約は、このレジスタを揮発性の部分と不揮発性の部分に分割します。 揮発性の部分は、MXCSR\[0:5] の6つの状態フラグで構成され、その他のレジスタである MXCSR\[6:15] は不揮発性と見なされます。

不揮発性の部分は、プログラムの実行開始時に次の標準値に設定されます。

| \[ビットの登録] | 設定 |
|-|-|
| MXCSR\[6] | Denormals は 0 ~ 0 です。 |
| MXCSR\[7:12] | 例外によって1のすべての例外がマスクされる (すべての例外がマスクされる) |
| MXCSR\[13:14] | 制御の丸め-0 (近似値に丸める) |
| MXCSR\[15] | マスクアンダーフローの場合は0にフラッシュします。 0 (オフ) |

MXCSR 内のいずれかの不揮発性フィールドを変更する呼び出し先は、呼び出し元に戻る前にそれらを復元する必要があります。 また、これらのフィールドのいずれかを変更した呼び出し元は、呼び出し先が変更された値を想定していない限り、呼び出し先を呼び出す前に、それらのフィールドを標準値に復元する必要があります。

制御フラグの非揮発性に関する規則には、次の2つの例外があります。

- 特定の関数のドキュメント化された目的で、不揮発性 MxCsr フラグを変更する関数。

- これらの規則に違反すると、プログラム全体の分析など、これらの規則に違反していないプログラムと同じように動作するプログラムが provably されます。

関数のドキュメントで特に説明されていない限り、関数の境界を越えた MXCSR の揮発性部分の状態について、想定を行うことはできません。

## <a name="setjmplongjmp"></a>setjmp/longjmp

Setjmpex.h または setjmp. h を含めると、 [setjmp](../c-runtime-library/reference/setjmp.md)または[longjmp](../c-runtime-library/reference/longjmp.md)のすべての呼び出しは、デストラクターを呼び出し、呼び出しを `__finally` するアンワインドになります。  これは x86 とは異なります。たとえば、setjmp を指定すると、`__finally` の句とデストラクターが呼び出されません。

`setjmp` を呼び出すと、現在のスタックポインター、非揮発性レジスタ、および MxCsr レジスタが保持されます。  を呼び出すと、最新の `setjmp` 呼び出しサイトに戻り `longjmp`、スタックポインター、不揮発性レジスタ、および MxCsr レジスタを、最新の `setjmp` 呼び出しによって保持されている状態にリセットします。

## <a name="see-also"></a>参照

[x64 ソフトウェア規約](../build/x64-software-conventions.md)
