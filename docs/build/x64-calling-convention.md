---
title: x64 での呼び出し規則
description: 既定の x64 ABI 呼び出し規約の詳細。
ms.date: 12/17/2018
ms.assetid: 41ca3554-b2e3-4868-9a84-f1b46e6e21d9
ms.openlocfilehash: caf22172ea5e9c20280bce8e508d72fd30c00c5b
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81335126"
---
# <a name="x64-calling-convention"></a>x64 での呼び出し規則

このセクションでは、x64 コードで別の関数 (呼び出し先) を呼び出すために 1 つの関数 (呼び出し元) が使用する標準プロセスと規則について説明します。

## <a name="calling-convention-defaults"></a>呼び出し規約の既定値

x64 アプリケーション バイナリ インターフェイス (ABI) は、既定で 4 レジスタの高速呼び出しの呼び出し規約を使用します。 これらのレジスタを保存する呼び出し先のシャドウ ストアとして、呼び出し履歴に領域が割り当てられます。 関数呼び出しの引数と、それらの引数に使用されるレジスタの間には、厳密な 1 対 1 の対応があります。 8 バイトに収まらない引数、または 1 バイト、2 バイト、4 バイト、または 8 バイトではない引数は、参照渡しする必要があります。 1 つの引数が複数のレジスタに分散されることはありません。 x87 レジスタ スタックは未使用であり、呼び出し先で使用できますが、関数呼び出し間で揮発性と見なす必要があります。 浮動小数点演算はすべて 16 XMM レジスタを使用して行われます。 整数の引数は、レジスタ RCX、RDX、R8、および R9 で渡されます。 浮動小数点引数は、XMM0L、XMM1L、XMM2L、および XMM3L で渡されます。 16 バイトの引数は参照によって渡されます。 パラメーターの引き渡しについては、「[パラメーターの引き渡し」で](#parameter-passing)詳しく説明します。 これらのレジスタに加えて、RAX、R10、R11、XMM4、およびXMM5は揮発性と見なされます。 その他のレジスタはすべて不揮発性です。 レジスターの使用状況については、レジスターの[使用状況](../build/x64-software-conventions.md#register-usage)と[呼び出し先/呼び出し先の保存済みレジスター](#callercallee-saved-registers)に詳細に記載されています。

プロトタイプ関数の場合、すべての引数は、渡す前に、予期される呼び出し先の型に変換されます。 呼び出し元は、呼び出し先にパラメーターの領域を割り当てる必要があり、呼び出し先がそれだけ多くのパラメーターを受け取らない場合でも、4 つのレジスタ パラメーターを格納するのに十分な領域を常に割り当てる必要があります。 この規則は、プロトタイプなしの C 言語関数と vararg C/C++ 関数のサポートを簡略化します。 vararg 関数またはプロトタイプ化されていない関数の場合、浮動小数点値は対応する汎用レジスタに重複する必要があります。 最初の 4 つより大きさいパラメーターは、呼び出しの前にシャドウ ストアの後にスタックに格納する必要があります。 Vararg 関数の詳細については、 [Varargs](#varargs)を参照してください。 プロトタイプ化されていない関数の情報については、「[プロトタイプ化されていない関数」を参照](#unprototyped-functions)してください。

## <a name="alignment"></a>Alignment

ほとんどの構造は、その自然な位置合わせに揃えられます。 主な例外は、パフォーマンスを向上させるために`malloc` `alloca` 16 バイトにアライメントされるスタック ポインターまたはメモリです。 16 バイトを超えるアライメントは手動で行う必要がありますが、XMM 操作では 16 バイトが共通のアラインメント・サイズであるため、ほとんどのコードではこの値が機能します。 構造のレイアウトと配置の詳細については、「[タイプと格納」](../build/x64-software-conventions.md#types-and-storage)を参照してください。 スタック レイアウトの詳細については、「 [x64 スタックの使用方法](../build/stack-usage.md)」を参照してください。

## <a name="unwindability"></a>アンワインドビリティ

リーフ関数は、不揮発性レジスタを変更しない関数です。 非リーフ関数は、関数を呼び出したり、ローカル変数に追加のスタック領域を割り当てたりして、不揮発性 RSP を変更する場合があります。 例外が処理されるときに不揮発性レジスタを回復するためには、非リーフ関数に、任意の命令で関数を適切にアンワインドする方法を記述した静的データを使用してアノフィトする必要があります。 このデータは*pdata*またはプロシージャ データとして格納され *、xdata*を参照します。 xdata にはアンワインド情報が含まれ、追加の pdata または例外ハンドラー関数を指すことができます。 プロローグとエピローグは、xdata で適切に記述できるように、非常に制限されています。 スタック ポインターは、リーフ関数内を除き、エピローグまたはプロローグの一部ではないコードの領域で 16 バイトに揃える必要があります。 リーフ関数は、単に戻り値をシミュレートするだけで巻き戻すことができるため、pdata と xdata は必要ありません。 関数のプロローグとエピローグの適切な構造の詳細については、 [x64 プロローグとエピローグ](../build/prolog-and-epilog.md)を参照してください。 例外処理、および pdata および xdata の例外処理とアンワインドの詳細については[、「x64 例外処理](../build/exception-handling-x64.md)」を参照してください。

## <a name="parameter-passing"></a>パラメーター渡し

最初の 4 つの整数引数はレジスタに渡されます。 整数値は、それぞれ RCX、RDX、R8、R9 で左から右に渡されます。 5 以上の引数はスタックに渡されます。 すべての引数はレジスタ内で右揃えされるため、呼び出し先はレジスタの上位ビットを無視して、必要なレジスタの部分だけにアクセスできます。

最初の 4 つのパラメーターの浮動小数点引数と倍精度引数は、位置に応じて XMM0 から XMM3 で渡されます。 これらの位置に通常使用される整数レジスタ RCX、RDX、R8、および R9 は、varargs 引数の場合を除いて無視されます。 詳細については[、Varargs](#varargs)を参照してください。 同様に、XMM0 から XMM3 レジスタは、対応する引数が整数型またはポインタ型の場合には無視されます。

[__m128](../cpp/m128.md)型、配列、および文字列は、即時値によって渡されることはありません。 代わりに、呼び出し元によって割り当てられたメモリにポインターが渡されます。 サイズ 8、16、32、または 64 ビットの構造体と共用体、および__m64型は、同じサイズの整数であるかのように渡されます。 他のサイズの構造体または共用体は、呼び出し元によって割り当てられたメモリへのポインターとして渡されます。 ポインターとして渡されるこれらの集計型 (_m128\_を含む) の場合、呼び出し元が割り当てた一時メモリは 16 バイトでアラインする必要があります。

スタック領域を割り当てない組み込み関数で、他の関数を呼び出さない場合は、他の揮発性レジスタを使用して追加のレジスタ引数を渡す場合があります。 この最適化は、コンパイラと組み込み関数の実装との間の緊密なバインドによって可能になります。

呼び出し先は、必要に応じて、レジスタ・パラメーターをシャドー・スペースにダンプする役割を担います。

次の表は、パラメータの受け渡し方法をまとめたものです。

|パラメーターのタイプ|どのように渡されたか|
|--------------------|----------------|
|浮動小数点数|最初の4つのパラメータ - XMM0からXMM3まで。 他の人はスタックで渡しました。|
|Integer|最初の 4 つのパラメーター - RCX、RDX、R8、R9。 他の人はスタックで渡しました。|
|集計 (8、16、32、または 64 ビット) と__m64|最初の 4 つのパラメーター - RCX、RDX、R8、R9。 他の人はスタックで渡しました。|
|集計 (その他)|ポインタによって。 RCX、RDX、R8、および R9 で、最初の 4 つのパラメーターがポインターとして渡されます。|
|__m128|ポインタによって。 RCX、RDX、R8、および R9 で、最初の 4 つのパラメーターがポインターとして渡されます。|

### <a name="example-of-argument-passing-1---all-integers"></a>引数渡しの例 1 - すべての整数

```cpp
func1(int a, int b, int c, int d, int e);
// a in RCX, b in RDX, c in R8, d in R9, e pushed on stack
```

### <a name="example-of-argument-passing-2---all-floats"></a>引数渡しの例 2 - すべての浮動小数点数

```cpp
func2(float a, double b, float c, double d, float e);
// a in XMM0, b in XMM1, c in XMM2, d in XMM3, e pushed on stack
```

### <a name="example-of-argument-passing-3---mixed-ints-and-floats"></a>引数渡しの例 3 - 混合イントと浮動小数点数

```cpp
func3(int a, double b, int c, float d);
// a in RCX, b in XMM1, c in R8, d in XMM3
```

### <a name="example-of-argument-passing-4--__m64-__m128-and-aggregates"></a>4 -__m64、_m128、\_および集計を渡す引数の例

```cpp
func4(__m64 a, _m128 b, struct c, float d);
// a in RCX, ptr to b in RDX, ptr to c in R8, d in XMM3
```

## <a name="varargs"></a>vararg

varargs (省略引数など) を使用してパラメーターを渡す場合、スタックに 5 番目以降の引数をこぼすなど、通常のレジスタ パラメーター渡し規約が適用されます。 アドレスを取った引数をダンプするのは、呼び出し先の責任です。 浮動小数点値の場合のみ、呼び出し先が整数レジスタの値を期待する場合に備えて、整数レジスタと浮動小数点レジスタの両方に値が含まれている必要があります。

## <a name="unprototyped-functions"></a>プロトタイプ化されていない関数

完全にプロトタイプ化されていない関数の場合、呼び出し元は整数値を整数として、浮動小数点値を倍精度として渡します。 浮動小数点値の場合のみ、整数レジスタと浮動小数点レジスタの両方に、呼び出し先が整数レジスタの値を期待する場合に、float 値が格納されます。

```cpp
func1();
func2() {   // RCX = 2, RDX = XMM1 = 1.0, and R8 = 7
   func1(2, 1.0, 7);
}
```

## <a name="return-values"></a>戻り値

64 ビットに収まるスカラー戻り値は RAX を介して返されます。これには__m64タイプが含まれます。 浮動小数点型、倍精度浮動小数点型、および[__m128](../cpp/m128.md)、 [__m128i](../cpp/m128i.md)などのベクトル型を含む非スカラー型[は](../cpp/m128d.md)、XMM0 で返__m128d。 RAX や XMM0 で返される値の未使用ビットの状態は未定義です。

ユーザー定義型は、グローバル関数や静的メンバー関数からの値で返すことができます。 RAX で値によってユーザー定義型を返す場合、長さは 1、2、4、8、16、32、または 64 ビットでなければなりません。 また、ユーザー定義のコンストラクター、デストラクター、またはコピー代入演算子を持たなければなりません。プライベートまたは保護された非静的データ メンバーはありません。参照型の非静的データ メンバーはありません。基本クラスはありません。仮想関数なし。また、これらの要件を満たしていないデータ メンバはありません。 (これは、実質的には C++03 POD 型の定義です。 定義は C++11 標準で変更されているため、このテストには使用`std::is_pod`しないことをお勧めします)。それ以外の場合、呼び出し元はメモリを割り当て、戻り値のポインターを最初の引数として渡す必要があります。 後続する引数は、引数 1 つ分だけ右にシフトされます。 RAX 内の呼び出し先は同じポインターを返す必要があります。

以下の例は、宣言を指定して関数に対してパラメーターと戻り値を渡す方法を示しています。

### <a name="example-of-return-value-1---64-bit-result"></a>戻り値 1 から 64 ビットの結果の例

```Output
__int64 func1(int a, float b, int c, int d, int e);
// Caller passes a in RCX, b in XMM1, c in R8, d in R9, e pushed on stack,
// callee returns __int64 result in RAX.
```

### <a name="example-of-return-value-2---128-bit-result"></a>戻り値 2 から 128 ビットの結果の例

```Output
__m128 func2(float a, double b, int c, __m64 d);
// Caller passes a in XMM0, b in XMM1, c in R8, d in R9,
// callee returns __m128 result in XMM0.
```

### <a name="example-of-return-value-3---user-type-result-by-pointer"></a>戻り値 3 の例 - ポインターによるユーザー・タイプの結果

```Output
struct Struct1 {
   int j, k, l;    // Struct1 exceeds 64 bits.
};
Struct1 func3(int a, double b, int c, float d);
// Caller allocates memory for Struct1 returned and passes pointer in RCX,
// a in RDX, b in XMM2, c in R9, d pushed on the stack;
// callee returns pointer to Struct1 result in RAX.
```

### <a name="example-of-return-value-4---user-type-result-by-value"></a>戻り値 4 の例 - 値によるユーザー・タイプの結果

```Output
struct Struct2 {
   int j, k;    // Struct2 fits in 64 bits, and meets requirements for return by value.
};
Struct2 func4(int a, double b, int c, float d);
// Caller passes a in RCX, b in XMM1, c in R8, and d in XMM3;
// callee returns Struct2 result by value in RAX.
```

## <a name="callercallee-saved-registers"></a>呼び出し元/呼び出し先のレジスタを保存

レジスタ RAX、RCX、RDX、R8、R9、R10、R11、XMM0-5、および YMM0-15 および ZMM0-15 の上部は揮発性と見なされ、関数呼び出しで破棄されるものと見なす必要があります (プログラム全体の最適化などの分析による安全性が特に高い場合を除く)。 AVX512VL では、ZMM、YMM、および XMM レジスタ 16-31 は揮発性です。

レジスタ RBX、RBP、RDI、RSI、RSP、R12、R13、R14、R15、および XMM6-15 は不揮発性と見なされ、それらを使用する関数によって保管および復元する必要があります。

## <a name="function-pointers"></a>関数ポインター

関数ポインターは、単にそれぞれの関数のラベルへのポインターです。 関数ポインターには目次 (TOC) の要件はありません。

## <a name="floating-point-support-for-older-code"></a>古いコードの浮動小数点サポート

MMX および浮動小数点スタック レジスタ (MM0-MM7/ST0-ST7) は、コンテキスト スイッチ間で保持されます。 これらのレジスタに対する明示的な呼び出し規約はありません。 これらのレジスタの使用は、カーネル モード コードでは厳しく禁止されています。

## <a name="fpcsr"></a>FpCsr

レジスタ状態には、x87 FPU 制御ワードも含まれます。 呼び出し規約では、このレジスタは不揮発性であると指定されます。

x87 FPU 制御ワードレジスタは、プログラム実行の開始時に以下の標準値に設定されます。

| レジスタ\[ビット] | 設定 |
|-|-|
| FPCSR\[0:6] | 例外マスクは、すべての 1(すべての例外がマスク) |
| FPCSR\[7] | 予約済み - 0 |
| FPCSR\[8:9] | 精密制御 - 10B(倍精度) |
| FPCSR\[10:11] | 丸め制御 - 0 (最も近い値に丸める) |
| FPCSR\[12] | 無限制御 - 0 (使用しない) |

FPCSR 内のいずれかのフィールドを変更する呼び出し先は、呼び出し元に戻る前に、フィールドを復元する必要があります。 さらに、これらのフィールドのいずれかを変更した呼び出し元は、呼び出し先が変更された値を期待していない限り、呼び出し先を呼び出す前に標準値に復元する必要があります。

制御フラグの非揮発性に関する規則には、次の 2 つの例外があります。

1. 指定された関数の文書化された目的は、不揮発性 FpCsr フラグを変更する関数です。

1. これらのルールに違反すると、プログラム全体の分析など、これらのルールに違反しないプログラムと同じように動作するプログラムが発生することが明らかに正しい場合。

## <a name="mxcsr"></a>MxCsr

レジスタの状態には MxCsr も含まれます。 呼び出し規約では、このレジスタを揮発性部分と不揮発性部分に分割します。 揮発性部分は MXCSR\[0:5] の 6 つの状態フラグで構成され、残りのレジスタ\[MXCSR 6:15] は不揮発性と見なされます。

不揮発性部分は、プログラム実行の開始時に以下の標準値に設定されます。

| レジスタ\[ビット] | 設定 |
|-|-|
| MXCSR\[6] | 非正規化はゼロ - 0 |
| MXCSR\[7:12] | 例外マスクは、すべての 1(すべての例外がマスク) |
| MXCSR\[13:14] | 丸め制御 - 0 (最も近い値に丸める) |
| MXCSR\[15] | マスクアンダーフローの場合はゼロにフラッシュ - 0 (オフ) |

MXCSR 内の不揮発性フィールドのいずれかを変更する呼び出し先は、呼び出し元に戻る前に、それらを復元する必要があります。 さらに、これらのフィールドのいずれかを変更した呼び出し元は、呼び出し先が変更された値を期待していない限り、呼び出し先を呼び出す前に標準値に復元する必要があります。

制御フラグの非揮発性に関する規則には、次の 2 つの例外があります。

- 指定された関数の文書化された目的は、不揮発性 MxCsr フラグを変更する関数です。

- これらのルールに違反すると、プログラム全体の分析など、これらのルールに違反しないプログラムと同じように動作するプログラムが発生することが明らかに正しい場合。

関数のドキュメントで特に説明されていない限り、関数境界を越えて MXCSR の揮発性部分の状態について仮定することはできません。

## <a name="setjmplongjmp"></a>セックジャンプ/ロングジャンプ

setjmpex.h または setjmp.h を含めると[、setjmp](../c-runtime-library/reference/setjmp.md)または[longjmp](../c-runtime-library/reference/longjmp.md)へのすべての呼び出しは、デ`__finally`ストラクタと呼び出しを呼び出すアンワインドになります。  これは、setjmp.h を含めると句が作成され、デ`__finally`ストラクタが呼び出されない場合に、x86 とは異なります。

現在のスタック`setjmp`ポインター、不揮発性レジスタ、および MxCsr レジスタを保持する呼び出し。  最新`longjmp``setjmp`の呼び出しサイトに戻る呼び出し、スタック ポインター、非揮発性レジスタ、および MxCsr レジスタを、最新`setjmp`の呼び出しによって保持されている状態にリセットします。

## <a name="see-also"></a>関連項目

[x64 ソフトウェア規約](../build/x64-software-conventions.md)
