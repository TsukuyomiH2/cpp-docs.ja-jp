---
description: 詳細については、「ヒープ競合の回避」を参照してください。
title: ヒープ競合の回避
ms.date: 11/04/2016
helpviewer_keywords:
- heap contention
ms.assetid: 797129d7-5f8c-4b0e-8974-bb93217e9ab5
ms.openlocfilehash: c58849bee46dd0d870d1067f17581429339fbc0e
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/11/2020
ms.locfileid: "97142572"
---
# <a name="avoidance-of-heap-contention"></a>ヒープ競合の回避

MFC および ATL によって提供される既定の文字列マネージャーは、グローバルヒープ上の単純なラッパーです。 このグローバルヒープは完全にスレッドセーフです。つまり、複数のスレッドがヒープを破壊することなく、メモリを同時に割り当てたり解放したりすることができます。 スレッドセーフを提供するために、ヒープはそれ自体へのアクセスをシリアル化する必要があります。 これは通常、クリティカルセクションまたは同様のロックメカニズムを使用して行います。 2つのスレッドが同時にヒープにアクセスしようとするたびに、他のスレッドの要求が完了するまで、1つのスレッドがブロックされます。 多くのアプリケーションでは、この状況が発生することはほとんどなく、ヒープのロックメカニズムによるパフォーマンスへの影響はごくわずかです。 ただし、複数のスレッドからヒープに頻繁にアクセスするアプリケーションでは、ヒープのロックの競合が発生すると、シングルスレッド (複数の Cpu を搭載したコンピューターであっても) の場合よりも、アプリケーションの実行速度が低下する可能性があります。

[CStringT](../atl-mfc-shared/reference/cstringt-class.md)を使用するアプリケーションは、多くの場合、オブジェクトに対する操作に `CStringT` よって文字列バッファーの再割り当てが必要になるため、ヒープの競合が発生しやすくなります。

スレッド間のヒープの競合を軽減する1つの方法は、各スレッドがプライベートスレッドローカルヒープから文字列を割り当てることです。 特定のスレッドのアロケーターで割り当てられた文字列がそのスレッドでのみ使用されている限り、アロケーターはスレッドセーフである必要はありません。

## <a name="example"></a>例

次の例では、スレッドのスレッドセーフでない独自のヒープを割り当てて、そのスレッドの文字列に使用するスレッドプロシージャを示しています。

[!code-cpp[NVC_ATLMFC_Utilities#182](../atl-mfc-shared/codesnippet/cpp/avoidance-of-heap-contention_1.cpp)]

## <a name="comments"></a>説明

この同じスレッドプロシージャを使用して複数のスレッドが実行されている可能性がありますが、各スレッドに独自のヒープがあるため、スレッド間の競合は発生しません。 さらに、各ヒープがスレッドセーフではないという事実は、スレッドの1つのコピーだけが実行されている場合でも、パフォーマンスを大幅に向上させることができます。 これは、同時アクセスから保護するために、コストの高いインタロック操作を使用しないヒープの結果です。

より複雑なスレッドプロシージャの場合は、スレッドの文字列マネージャーへのポインターをスレッドローカルストレージ (TLS) スロットに格納すると便利な場合があります。 これにより、スレッドプロシージャによって呼び出された他の関数が、スレッドの文字列マネージャーにアクセスできるようになります。

## <a name="see-also"></a>関連項目

[CStringT を使用したメモリ管理](../atl-mfc-shared/memory-management-with-cstringt.md)
