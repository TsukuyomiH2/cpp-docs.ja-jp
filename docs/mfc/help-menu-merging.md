---
title: '[ヘルプ] メニューのマージ'
ms.date: 11/04/2016
helpviewer_keywords:
- menus [MFC], merging
- merging Help menus [MFC]
- Help [MFC], for active document containers
ms.assetid: 9d615999-79ba-471a-9288-718f0c903d49
ms.openlocfilehash: 1bd70af6f24ee6f9873b89b2060f4b2d90149c90
ms.sourcegitcommit: c21b05042debc97d14875e019ee9d698691ffc0b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/09/2020
ms.locfileid: "84620126"
---
# <a name="help-menu-merging"></a>[ヘルプ] メニューのマージ

オブジェクトがコンテナー内でアクティブな場合、OLE ドキュメントのメニューのマージプロトコルによって、オブジェクトは [**ヘルプ**] メニューを完全に制御できます。 その結果、ユーザーがオブジェクトを非アクティブ化しない限り、コンテナーのヘルプトピックは使用できません。 アクティブなドキュメントコンテインメントアーキテクチャは、埋め込み先メニューの [マージ] の規則に基づいて拡張され、アクティブなコンテナーとアクティブなドキュメントの両方がメニューを共有できるようになります。 新しい規則は、どのコンポーネントがメニューのどの部分を所有しているか、および共有メニューの構築方法に関する追加の規則です。

新しい規則は単純です。 アクティブなドキュメントの [**ヘルプ**] メニューには、次のように整理された2つのトップレベルメニュー項目があります。

`Help`

`Container Help >`

`Object Help    >`

たとえば、Office バインダーで Word セクションがアクティブになっている場合、[**ヘルプ**] メニューは次のように表示されます。

`Help`

`Binder Help >`

`Word Help   >`

どちらのメニュー項目も、コンテナーとオブジェクトに固有の追加のメニュー項目がユーザーに提供されるカスケードメニューです。 ここに表示される項目は、関連するコンテナーとオブジェクトによって異なります。

このマージされた**ヘルプ**メニューを構築するには、アクティブなドキュメントコンテインメントアーキテクチャによって、通常の OLE ドキュメントプロシージャが変更されます。 OLE ドキュメントによると、結合されたメニューバーには、[**ファイル**]、[**編集**]、[**コンテナー**]、[**オブジェクト**]、[**ウィンドウ**]、[**ヘルプ**] の順に、6つのメニューグループを含めることができます。 各グループには、0個以上のメニューを設定できます。 グループ**ファイル**、**コンテナー**、および**ウィンドウ**は、コンテナーに属し、グループ**Edit**、 **object、** および**Help**がオブジェクトに属しています。 オブジェクトがメニューをマージする場合は、空のメニューバーが作成され、コンテナーに渡されます。 次に、を呼び出して、コンテナーがそのメニューを挿入し `IOleInPlaceFrame::InsertMenus` ます。 また、オブジェクトは、6つの LONG 型の値 (**OLEMENUGROUPWIDTHS**) の配列である構造体も渡します。 メニューを挿入すると、コンテナーは、各グループに追加されたメニューの数をマークし、を返します。 次に、オブジェクトは、各コンテナーグループ内のメニューの数に注意して、メニューを挿入します。 最後に、オブジェクトは、結合されたメニューバーと、(各グループのメニューの数を含む) 配列を OLE に渡します。これにより、不透明な "menu descriptor" ハンドルが返されます。 その後、オブジェクトは、を介してそのハンドルとマージされたメニューバーをコンテナーに渡し `IOleInPlaceFrame::SetMenu` ます。 この時点で、コンテナーはマージされたメニューバーを表示し、ole にハンドルを渡して、OLE がメニューメッセージを適切にディスパッチできるようにします。

変更された active ドキュメントプロシージャでは、オブジェクトがコンテナーに渡す前に、まず**OLEMENUGROUPWIDTHS**要素を0に初期化する必要があります。 次に、コンテナーは、1つの例外を使用して通常のメニュー挿入を実行します。コンテナーは、最後の項目として [**ヘルプ**] メニューを挿入し、 **OLEMENUGROUPWIDTHS**配列の最後の (6 番目の) エントリ (つまり、オブジェクトのヘルプグループに属している width [5]) に値1を格納します。 この**ヘルプ**メニューには、前に説明したように、[**コンテナーヘルプ**>] カスケードメニューであるサブメニューの項目が1つだけ表示されます。

その後、オブジェクトは通常のメニュー挿入コードを実行します。ただし、**ヘルプ**メニューを挿入する前に、 **OLEMENUGROUPWIDTHS**配列の6番目のエントリをチェックします。 値が1で、最後のメニューの名前が**Help** (または適切なローカライズされた文字列) の場合、オブジェクトは **、そのヘルプ**メニューをコンテナーの [**ヘルプ**] メニューのサブメニューとして挿入します。

次に、オブジェクトは**OLEMENUGROUPWIDTHS**の6番目の要素をゼロに設定し、5番目の要素を1つずつインクリメントします。 これにより、OLE では、[**ヘルプ**] メニューがコンテナーに属しており、そのメニュー (およびそのサブメニュー) に対応するメニューメッセージがコンテナーにルーティングされることが認識されます。 次に、[**ヘルプ**] メニューのオブジェクトの部分に属する、 **WM_INITMENUPOPUP**、 **WM_SELECT**、 **WM_COMMAND**、およびその他のメニュー関連メッセージを転送するのはコンテナーの役割です。 これを行うには**WM_INITMENU**を使用して、ユーザーがオブジェクトの [**ヘルプ**] メニューに移動したかどうかをコンテナーに示すフラグをクリアします。 コンテナーは、コンテナーが自身を追加していないことを示す [**ヘルプ**] メニューの任意の項目に対して、 **WM_MENUSELECT**を監視します。 これは、ユーザーがオブジェクトメニューに移動したことを意味します。そのため、コンテナーは "in object Help menu" フラグを設定し、そのフラグの状態を使用して、 **WM_MENUSELECT**、 **WM_INITMENUPOPUP**、および**WM_COMMAND**メッセージをオブジェクトウィンドウに最小値として転送します。 (終了時には、コンテナーによってフラグがクリアされ、同じメッセージ自体が処理されます)。コンテナーは、オブジェクトの関数から返されたウィンドウを、 `IOleInPlaceActiveObejct::GetWindow` これらのメッセージの送信先として使用する必要があります。

オブジェクトが**OLEMENUGROUPWIDTHS**の6番目の要素でゼロを検出すると、通常の OLE ドキュメントのルールに従って処理が続行されます。 この手順では、[**ヘルプ**] メニューのマージに参加するコンテナーと、そうでないコンテナーについて説明します。

オブジェクトがを呼び出すと、結合されたメニューバーが表示される前に、コンテナーが `IOleInPlaceFrame::SetMenu` 挿入した内容に加えて、[**ヘルプ**] メニューに追加のサブメニューがあるかどうかが確認されます。 その場合、コンテナーは、結合されたメニューバーに [**ヘルプ**] メニューを残します。 [**ヘルプ**] メニューに追加のサブメニューがない場合、コンテナーは、結合されたメニューバーから [**ヘルプ**] メニューを削除します。 この手順では、[**ヘルプ**] メニューのマージに参加するオブジェクトと、そうでないオブジェクトについて説明します。

最後に、メニューを逆アセンブルする時間が経過すると、オブジェクトは、挿入された他のメニューを削除するだけでなく、挿入された [**ヘルプ**] メニューを削除します。 コンテナーがメニューを削除すると、そのメニューは、挿入された他のメニューに加えて [**ヘルプ**] メニューを削除します。

## <a name="see-also"></a>関連項目

[Active ドキュメント コンテナー](active-document-containers.md)
