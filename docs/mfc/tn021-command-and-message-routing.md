---
title: 'テクニカル ノート 21: コマンドとメッセージのルーティング'
ms.date: 06/28/2018
f1_keywords:
- vc.routing
helpviewer_keywords:
- TN021
- command routing [MFC], technical note TN021
- Windows messages [MFC], routing
ms.assetid: b5952c8b-123e-406c-a36d-a6ac7c6df307
ms.openlocfilehash: bdd405bda5c0af9e04a50eee4ef5738f3a53259e
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81370406"
---
# <a name="tn021-command-and-message-routing"></a>テクニカル ノート 21: コマンドとメッセージのルーティング

> [!NOTE]
> 次のテクニカル ノートは、最初にオンライン ドキュメントの一部とされてから更新されていません。 結果として、一部のプロシージャおよびトピックが最新でないか、不正になります。 最新の情報について、オンライン ドキュメントのキーワードで関係のあるトピックを検索することをお勧めします。

この注では、コマンドのルーティングとディスパッチのアーキテクチャ、および一般的なウィンドウメッセージルーティングの高度なトピックについて説明します。

ここで説明するアーキテクチャの一般的な詳細、特に Windows メッセージ、コントロール通知、およびコマンドの違いについては、Visual C++ を参照してください。 このメモは、印刷されたドキュメントに記載されている問題に精通しており、非常に高度なトピックのみを扱っているものとします。

## <a name="command-routing-and-dispatch-mfc-10-functionality-evolves-to-mfc-20-architecture"></a>MFC 2.0 アーキテクチャに進化するコマンド ルーティングとディスパッチ MFC 1.0 の機能

Windows には、メニュー コマンド、アクセラレータ キー、およびダイアログ コントロール通知の通知を提供するためにオーバーロードされたWM_COMMAND メッセージがあります。

MFC 1.0 では、`CWnd`派生クラスのコマンド ハンドラー ("OnFileNew" など) が特定のWM_COMMANDに応答して呼び出されることを許可することで、その上に少し基づいて構築されています。 これは、メッセージ マップと呼ばれるデータ構造と共に接着され、非常にスペース効率の高いコマンド メカニズムになります。

MFC 1.0 では、コマンド メッセージから制御通知を分離するための追加機能も提供されています。 コマンドは、16 ビット ID (コマンド ID とも呼ばれます) で表されます。 通常、コマンドは から`CFrameWnd`開始し (メニュー選択または変換アクセラレータ) し、他のさまざまなウィンドウにルーティングされます。

MFC 1.0 では、マルチ ドキュメント インターフェイス (MDI) の実装に限定された意味でコマンド ルーティングを使用しました。 (MDI フレーム ウィンドウは、アクティブな MDI 子ウィンドウにコマンドを委任します)。

この機能は、MFC 2.0 では一般化および拡張されており、ウィンドウ オブジェクトだけでなく、より幅広いオブジェクトでコマンドを処理できるようにしました。 メッセージをルーティングするためのより形式的で拡張可能なアーキテクチャを提供し、コマンドの処理だけでなく、UI オブジェクト (メニュー項目やツール バー ボタンなど) を更新してコマンドの現在の可用性を反映するためにコマンド ターゲット ルーティングを再利用します。

## <a name="command-ids"></a>コマンド ID

コマンドのルーティングとバインドのプロセスについては、Visual C++ を参照してください。 [テクニカル ノート 20](../mfc/tn020-id-naming-and-numbering-conventions.md)には、ID の命名に関する情報が含まれています。

コマンド ID には、汎用プレフィックス "ID_" を使用します。 コマンド ID は >= 0x8000 です。 コマンド ID と同じ ID を持つ STRINGTABLE リソースがある場合、メッセージ行またはステータス バーにはコマンドの説明文字列が表示されます。

アプリケーションのリソースでは、コマンド ID は次の場所に表示されます。

- メッセージ行プロンプトと同じ ID を持つ 1 つの STRINGTABLE リソース内。

- 同じコマンドを呼び出すメニュー項目にアタッチされている場合は、おそらく多くの MENU リソースで使用できます。

- (ADVANCED) を使用して、GOSUB コマンドのダイアログ・ボタンをクリックします。

アプリケーションのソース コードでは、コマンド ID は次の場所に表示されます。

- あなたのリソースで。H (または他のメイン シンボル ヘッダー ファイル) を使用して、アプリケーション固有のコマンド ID を定義します。

- おそらく、ツールバーを作成するために使用されるID配列内。

- ON_COMMANDマクロで。

- おそらくON_UPDATE_COMMAND_UIマクロで。

現在、コマンド ID を >= 0x8000 にする必要がある MFC の実装は、GOSUB ダイアログ/コマンドの実装だけです。

## <a name="gosub-commands-using-command-architecture-in-dialogs"></a>GOSUB コマンド、ダイアログでのコマンド・アーキテクチャーの使用

ルーティングと有効化コマンドのコマンド アーキテクチャは、フレーム ウィンドウ、メニュー項目、ツールバー ボタン、ダイアログ バー ボタン、その他のコントロール バー、およびコマンドやコントロール ID をメイン コマンド ターゲット (通常はメイン フレーム ウィンドウ) にルーティングするように設計されたその他のユーザー インターフェイス要素で適切に機能します。 そのメイン コマンド ターゲットは、コマンドまたはコントロールの通知を、必要に応じて他のコマンド ターゲット オブジェクトにルーティングできます。

ダイアログ (モーダルまたはモードレス) は、ダイアログ コントロールのコントロール ID を適切なコマンド ID に割り当てると、コマンド アーキテクチャの一部の機能を利用できます。 ダイアログのサポートは自動的に行われるわけではないので、追加のコードを記述する必要がある場合があります。

これらの機能がすべて正しく機能するには、コマンド ID を >= 0x8000 にする必要があります。 多くのダイアログが同じフレームにルーティングされる可能性があるため、共有コマンドは>= 0x8000 にする必要がありますが、特定のダイアログ内の非共有 Idc は <= 0x7FFF にする必要があります。

通常のモーダル ダイアログに通常のボタンを配置し、ボタンの IDC を適切なコマンド ID に設定できます。 ユーザーがボタンを選択すると、ダイアログの所有者 (通常はメイン フレーム ウィンドウ) が他のコマンドと同様にコマンドを取得します。 これは、通常、別のダイアログ (最初のダイアログの GOSUB) を起動するために使用されるので GOSUB コマンドと呼ばれます。

ダイアログで関数`CWnd::UpdateDialogControls`を呼び出して、メイン フレーム ウィンドウのアドレスを渡すこともできます。 この関数は、フレームにコマンド ハンドラーが含まれているかどうかに基づいて、ダイアログ コントロールを有効または無効にします。 この関数は、アプリケーションのアイドル ループのコントロール バーに対して自動的に呼び出されますが、この機能を使用する通常のダイアログに対しては直接呼び出す必要があります。

## <a name="when-on_update_command_ui-is-called"></a>ON_UPDATE_COMMAND_UIが呼び出されたとき

すべてのプログラムのメニュー項目の有効/チェック状態を常に維持することは、計算上のコストのかかる問題になる可能性があります。 一般的な方法は、ユーザーが POPUP を選択したときにのみ、メニュー項目を有効/チェックすることです。 MFC 2.0 の`CFrameWnd`実装では、WM_INITMENUPOPUP メッセージを処理し、コマンド ルーティング アーキテクチャを使用して、ON_UPDATE_COMMAND_UI ハンドラーを通じてメニューの状態を決定します。

`CFrameWnd`また、WM_ENTERIDLE メッセージを処理して、ステータス バーで選択されている現在のメニュー項目 (メッセージ行とも呼ばれます) を示します。

Visual C++ によって編集されるアプリケーションのメニュー構造は、WM_INITMENUPOPUP時に使用できるコマンドを表すために使用されます。 ON_UPDATE_COMMAND_UIハンドラは、メニューの状態やテキストを変更したり、高度な用途 (ファイル MRU リストや OLE 動詞ポップアップメニューなど) を変更したりして、メニューが描画される前にメニュー構造を実際に変更できます。

アプリケーションがアイドル ループに入ると、ツールバー (およびその他のコントロール バー) でも同じ種類のON_UPDATE_COMMAND_UI処理が行われます。 コントロール バーの詳細については、「*クラス ライブラリ リファレンス*」および[「テクニカル ノート 31」](../mfc/tn031-control-bars.md)を参照してください。

## <a name="nested-pop-up-menus"></a>ネストされたポップアップ メニュー

ネストされたメニュー構造を使用している場合、ポップアップメニューの最初のメニュー項目のON_UPDATE_COMMAND_UIハンドラーが 2 つの異なるケースで呼び出されます。

まず、ポップアップメニュー自体に呼び出されます。 ポップアップメニューにはIDがないため、ポップアップメニューの最初のメニュー項目のIDを使用してポップアップメニュー全体を参照するため、これが必要です。 この場合、`CCmdUI`オブジェクトの*m_pSubMenu*メンバー変数は NULL 以外になり、ポップアップ メニューをポイントします。

次に、ポップアップメニューのメニュー項目が描画される直前に呼び出されます。 この場合、ID は最初のメニュー項目だけを参照し、`CCmdUI`オブジェクトの*m_pSubMenu*メンバー変数は NULL になります。

これにより、メニュー項目とは異なるポップアップメニューを有効にできますが、メニューに対応するコードを記述する必要があります。 たとえば、次の構造を持つネストされたメニューで、

```Output
File>
    New>
    Sheet (ID_NEW_SHEET)
    Chart (ID_NEW_CHART)
```

ID_NEW_SHEETコマンドとID_NEW_CHARTコマンドは、個別に有効または無効にすることができます。 [**新規**] ポップアップメニューは、どちらかが有効になっている場合に有効にする必要があります。

ID_NEW_SHEETのコマンド ハンドラ (ポップアップの最初のコマンド) は次のようになります。

```cpp
void CMyApp::OnUpdateNewSheet(CCmdUI* pCmdUI)
{
    if (pCmdUI->m_pSubMenu != NULL)
    {
        // enable entire pop-up for "New" sheet and chart
        BOOL bEnable = m_bCanCreateSheet || m_bCanCreateChart;
        // CCmdUI::Enable is a no-op for this case, so we
        // must do what it would have done.
        pCmdUI->m_pMenu->EnableMenuItem(pCmdUI->m_nIndex,
            MF_BYPOSITION |
            (bEnable  MF_ENABLED : (MF_DISABLED | MF_GRAYED)));

        return;
    }
    // otherwise just the New Sheet command
    pCmdUI->Enable(m_bCanCreateSheet);
}
```

ID_NEW_CHARTのコマンド ハンドラーは通常の更新コマンド ハンドラーであり、次のようになります。

```cpp
void CMyApp::OnUpdateNewChart(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_bCanCreateChart);
}
```

## <a name="on_command-and-on_bn_clicked"></a>ON_COMMANDとON_BN_CLICKED

**ON_COMMAND**と**ON_BN_CLICKED**のメッセージ マップ マクロは同じです。 MFC コマンドとコントロールの通知ルーティング 機構では、コマンド ID を使用してルーティング先を決定するだけです。 コントロール通知コードがゼロ (**BN_CLICKED**) のコントロール通知はコマンドとして解釈されます。

> [!NOTE]
> 実際、すべてのコントロール通知メッセージは、コマンド ハンドラー チェーンを通過します。 たとえば、ドキュメント クラスの**EN_CHANGE**のコントロール通知ハンドラーを記述することは技術的に可能です。 この機能の実際のアプリケーションは少なく、ClassWizard ではサポートされておらず、この機能を使用するとコードが脆弱な場合があるため、一般的には推奨されません。

## <a name="disabling-the-automatic-disabling-of-button-controls"></a>ボタン コントロールの自動無効化の無効化

ボタン コントロールをダイアログ バーに配置するか、または**CWnd::UpdateDialogControls**を呼び出すダイアログ ボックスに配置すると **、ON_COMMAND**ハンドラーまたは**ON_UPDATE_COMMAND_UI**ハンドラーを持たないボタンがフレームワークによって自動的に無効になることに気付くでしょう。 場合によっては、ハンドラーを用意する必要はありませんが、ボタンを有効にしておく必要があります。 これを実現する最も簡単な方法は、ダミーのコマンド ハンドラ (ClassWizard を使用して簡単に行うことができます) を追加し、その中で何もしません。

## <a name="window-message-routing"></a>ウィンドウ メッセージ ルーティング

MFC クラスに関する高度なトピックと、Windows メッセージ ルーティングとその他のトピックがそれらにどのような影響を与えるかについて、次に説明します。 ここでの情報は簡単に説明します。 パブリック API の詳細については、*クラス ライブラリ リファレンス*を参照してください。 実装の詳細については、MFC ライブラリのソース コードを参照してください。

すべての**CWnd**派生クラスの非常に重要なトピックであるウィンドウ クリーンアップの詳細については、[テクニカル ノート 17](../mfc/tn017-destroying-window-objects.md)を参照してください。

## <a name="cwnd-issues"></a>CWnd の問題

実装メンバー関数**CWnd::OnChildNotify**は、子ウィンドウ (コントロールとも呼ばれます) が、親 (または "所有者" ) に送られるメッセージ、コマンド、およびコントロール通知をフックまたは通知するための強力で拡張可能なアーキテクチャを提供します。 子ウィンドウ (/コントロール) が C++ **CWnd**オブジェクト自体である場合、仮想関数**OnChildNotify**は、最初に元のメッセージ (**つまり、MSG**構造体) からのパラメーターを使用して呼び出されます。 子ウィンドウは、メッセージをそのままにしておいたり、食べたり、親のメッセージを変更したりできます(まれ)。

既定の**CWnd**実装は、次のメッセージを処理し **、OnChildNotify**フックを使用して、子ウィンドウ (コントロール) がメッセージで最初にアクセスできるようにします。

- **WM_MEASUREITEM**と**WM_DRAWITEM(** セルフドロー用)

- **WM_COMPAREITEM**と**WM_DELETEITEM(** セルフドロー用)

- **WM_HSCROLL**と**WM_VSCROLL**

- **Wm_ctlcolor**

- **WM_PARENTNOTIFY**

オーナー描画メッセージを自己描画メッセージに変更するために**OnChildNotify**フックが使用されていることに気付くでしょう。

**OnChildNotify**フックに加えて、スクロール メッセージのルーティング動作がさらに多く生じます。 スクロールバーと**WM_HSCROLL**のソースと**WM_VSCROLL**メッセージの詳細については、以下を参照してください。

## <a name="cframewnd-issues"></a>CFrameWnd の問題

**CFrameWnd**クラスは、コマンド ルーティングとユーザー インターフェイス更新の実装のほとんどを提供します。 これは主に、アプリケーションのメイン フレーム ウィンドウ (**CWinApp::m_pMainWnd**) に使用されますが、すべてのフレーム ウィンドウに適用されます。

メイン フレーム ウィンドウは、メニュー バーを持つウィンドウで、ステータス バーまたはメッセージ行の親です。 コマンドルーティングとWM_INITMENUPOPUPに関する上記の説明を参照してください **。**

**CFrameWnd**クラスは、アクティブなビューの管理を提供します。 次のメッセージは、アクティブ なビューを経由してルーティングされます。

- すべてのコマンド メッセージ (アクティブ ビューは、最初にアクセスします)。

- **兄弟**スクロールバーからのメッセージ**をWM_HSCROLLおよびWM_VSCROLL**します(下記参照)。

- **WM_ACTIVATE** (および MDI の**WM_MDIACTIVATE)** は、仮想関数**CView::OnActivateView**への呼び出しに変換されます。

## <a name="cmdiframewndcmdichildwnd-issues"></a>問題を解決します。

MDI フレーム ウィンドウ クラスは**どちらも CFrameWnd**から派生しているため **、CFrameWnd**で提供される同じ種類のコマンド ルーティングとユーザー インターフェイス更新の両方で有効になっています。 一般的な MDI アプリケーションでは、メイン フレーム ウィンドウ **(CMDIFrameWnd**オブジェクト) だけがメニュー バーとステータス バーを保持するため、コマンド ルーティング実装のメイン ソースになります。

一般的なルーティングスキームは、アクティブな MDI 子ウィンドウがコマンドに最初にアクセスすることです。 既定の**PreTranslateMessage**関数は、MDI 子ウィンドウ (最初) と MDI フレーム (2 番目) の両方のアクセラレータ テーブルと、**通常は TranslateMDISysAccel** (最後) によって処理される標準の MDI システム コマンド アクセラレータのアクセラレータを処理します。

## <a name="scroll-bar-issues"></a>スクロール バーの問題

スクロール メッセージ/**(onHScroll** **WM_HSCROLL**や**OnVScroll** **WM_VSCROLL)**/を処理する場合は、スクロール バー メッセージの発生元に依存しないように、ハンドラー コードを記述する必要があります。 スクロール メッセージは、実際のスクロール バー コントロールまたはスクロール バー コントロールではない**WS_HSCROLLWS_VSCROLL**スクロール バーから来る可能性があるため、これは Windows**の**/一般的な問題だけではありません。

MFC では、スクロール バー コントロールをスクロールするウィンドウの子または兄弟にすることを拡張します (実際には、スクロール バーとスクロールされているウィンドウの親子関係は何でも可能です)。 これは、分割ウィンドウを持つ共有スクロール バーでは特に重要です。 **CSplitterWnd**の実装の詳細については、共有スクロール バーの問題に関する詳細を含む[テクニカル ノート 29](../mfc/tn029-splitter-windows.md)を参照してください。

一方、作成時に指定されたスクロール バースタイルがトラップされ、Windows に渡されない**CWnd**派生クラスが 2 つあります。 作成ルーチンに渡された場合 **、WS_HSCROLL**と**WS_VSCROLL**は個別に設定できますが、作成後は変更できません。 もちろん、作成したウィンドウのWS_SCROLLスタイルビットを直接テストしたり、設定したりしないでください。

**CMDIFrameWnd**の場合、**作成**または**ロードフレーム**に渡すスクロール バースタイルは、MDICLIENT の作成に使用されます。 スクロール可能な MDICLIENT 領域 (Windows プログラム マネージャなど) を使用する場合は **、CMDIFrameWnd**の作成に使用するスタイルに対して、両方のスクロール バー スタイル **(WS_HSCROLL** &#124; **WS_VSCROLL)** を設定してください。

**CSplitterWnd**の場合、スクロール バーのスタイルは、分割領域の特殊な共有スクロール バーに適用されます。 静的分割ウィンドウの場合、通常はスクロール バーのスタイルは設定しません。 動的分割ウィンドウの場合、通常は、分割する方向にスクロール バースタイルを設定します(つまり、行を分割できる場合は**WS_HSCROLL、** 列を分割できる場合**はWS_VSCROLL。**

## <a name="see-also"></a>関連項目

[番号順テクニカル ノート](../mfc/technical-notes-by-number.md)<br/>
[カテゴリ別テクニカル ノート](../mfc/technical-notes-by-category.md)
