---
description: '詳細については、「テクニカルノート 58: MFC モジュールの状態の実装」を参照してください。'
title: 'テクニカル ノート 58: MFC のモジュール状態の実装'
ms.date: 06/28/2018
helpviewer_keywords:
- thread state [MFC]
- module states [MFC], managing state data
- TN058
- MFC, managing state data
- module states [MFC], switching
- DLLs [MFC], module states
- process state [MFC]
ms.assetid: 72f5b36f-b3da-4009-a144-24258dcd2b2f
ms.openlocfilehash: c4b300b9aa184e9fa1c6cfd5a8cf668d163d85ef
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/11/2020
ms.locfileid: "97214781"
---
# <a name="tn058-mfc-module-state-implementation"></a>テクニカル ノート 58: MFC のモジュール状態の実装

> [!NOTE]
> 次のテクニカル ノートは、最初にオンライン ドキュメントの一部とされてから更新されていません。 結果として、一部のプロシージャおよびトピックが最新でないか、不正になります。 最新の情報について、オンライン ドキュメントのキーワードで関係のあるトピックを検索することをお勧めします。

このテクニカルノートでは、MFC の "モジュール状態" コンストラクトの実装について説明します。 DLL (または OLE インプロセスサーバー) から MFC 共有 Dll を使用するには、モジュール状態の実装について理解していることが重要です。

このメモを読む前に、「 [新しいドキュメント、ウィンドウ、およびビューの作成](../mfc/creating-new-documents-windows-and-views.md)」の「MFC モジュールの状態データの管理」を参照してください。 この記事には、この件名の重要な使用状況情報と概要情報が含まれています。

## <a name="overview"></a>概要

MFC の状態情報には、モジュールの状態、プロセスの状態、スレッドの状態の3種類があります。 場合によっては、これらの状態の種類を組み合わせることができます。 たとえば、MFC のハンドルマップは、モジュールローカルとスレッドローカルの両方です。 これにより、2つの異なるモジュールがそれぞれのスレッドで異なるマップを持つことができます。

プロセスの状態とスレッドの状態は似ています。 これらのデータ項目は、従来はグローバル変数であったものですが、適切な Win32s サポートまたは適切なマルチスレッドサポートのために、特定のプロセスまたはスレッドに固有である必要があります。 特定のデータ項目が適合するカテゴリは、その項目と、プロセスとスレッドの境界に関して必要なセマンティクスによって異なります。

モジュールの状態は、真のグローバルな状態またはローカルプロセスまたはスレッドローカルスレッドの状態を含むことができるということで一意です。 さらに、すばやく切り替えることができます。

## <a name="module-state-switching"></a>モジュールの状態の切り替え

各スレッドには、"現在" または "アクティブ" なモジュールの状態へのポインターが含まれています (当然ながら、ポインターは MFC のスレッドローカルの状態に含まれています)。 このポインターは、実行のスレッドがモジュールの境界 (OLE コントロールまたは DLL を呼び出すアプリケーションや、アプリケーションにコールバックする OLE コントロールなど) を渡すときに変更されます。

現在のモジュールの状態は、を呼び出すことによって切り替えられ `AfxSetModuleState` ます。 ほとんどの場合、API を直接処理することはできません。 MFC では、多くの場合、(WinMain、OLE エントリポイント、などで) これを呼び出すことになり `AfxWndProc` ます。 これは、特殊なに静的にリンクすることによって記述する任意のコンポーネントで実行され `WndProc` `WinMain` `DllMain` ます。また、どのモジュールの状態が最新である必要があるかを認識する特別な (または) です。 このコードについては、DLLMODUL を参照してください。CPP または APPMODUL。MFC\ SRC ディレクトリ内の CPP。

ほとんどの場合、モジュールの状態を設定してから設定し直す必要はありません。 ほとんどの場合、独自のモジュール状態を現在の状態に "プッシュ" した後、元のコンテキストを "ポップ" します。 これは、マクロ [AFX_MANAGE_STATE](reference/extension-dll-macros.md#afx_manage_state) と特別なクラスによって行われ `AFX_MAINTAIN_STATE` ます。

`CCmdTarget` には、モジュールの状態の切り替えをサポートする特別な機能があります。 特に、は、 `CCmdTarget` ole オートメーションおよび OLE COM エントリポイントに使用されるルートクラスです。 システムに公開されている他のエントリポイントと同様に、これらのエントリポイントは正しいモジュール状態を設定する必要があります。 "正しい" モジュールの状態がどのようになるかは、どのようにして、"現在の" モジュールの状態がどのように構築されているかを `CCmdTarget` "記憶" し、後でを呼び出したときに、現在のモジュールの状態を "記憶された" 値に設定できるということです。 その結果、特定のオブジェクトが関連付けられているモジュールの状態 `CCmdTarget` は、オブジェクトが構築されたときの現在のモジュールの状態になります。 INPROC サーバーの読み込み、オブジェクトの作成、およびメソッドの呼び出しの簡単な例を見てください。

1. DLL は、を使用して OLE によって読み込まれ `LoadLibrary` ます。

1. `RawDllMain` は最初に呼び出されます。 これにより、モジュールの状態が DLL の既知の静的モジュールの状態に設定されます。 このため `RawDllMain` 、は DLL に静的にリンクされます。

1. オブジェクトに関連付けられているクラスファクトリのコンストラクターが呼び出されます。 `COleObjectFactory` はから派生 `CCmdTarget` し、その結果、インスタンス化されたモジュールの状態を記憶します。 これは重要なことです。クラスファクトリがオブジェクトの作成を求められたら、現在のモジュールの状態を認識しています。

1. `DllGetClassObject` は、クラスファクトリを取得するために呼び出されます。 MFC は、このモジュールに関連付けられているクラスファクトリのリストを検索し、それを返します。

1. `COleObjectFactory::XClassFactory2::CreateInstance` が呼ばれたとき。 この関数は、オブジェクトを作成して返す前に、モジュールの状態を、手順3で最新であったモジュールの状態に設定します (がインスタンス化されたときに最新の状態になっていたもの `COleObjectFactory` )。 これは [METHOD_PROLOGUE](com-interface-entry-points.md)の内部で行われます。

1. オブジェクトが作成されると、それも `CCmdTarget` 派生したものであり、 `COleObjectFactory` どのモジュールの状態がアクティブだったかが同じであるため、この新しいオブジェクトが生成されます。 これで、オブジェクトは、呼び出されるたびに切り替えるモジュールの状態を認識します。

1. クライアントは、呼び出しから受け取った OLE COM オブジェクトに対して関数を呼び出し `CoCreateInstance` ます。 オブジェクトが呼び出されると、はを使用して `METHOD_PROLOGUE` 、と同様にモジュールの状態を切り替え `COleObjectFactory` ます。

ご覧のように、モジュールの状態は、作成時にオブジェクトからオブジェクトに反映されます。 モジュールの状態を適切に設定することが重要です。 これが設定されていない場合、DLL または COM オブジェクトは、それを呼び出している MFC アプリケーションと正常に通信できないか、または独自のリソースを見つけることができないか、他のひどい方法で失敗する可能性があります。

特定の種類の Dll (特に "MFC Extension" Dll) では、モジュールの状態がに切り替わることはありません `RawDllMain` (実際には、通常はを持っていません `RawDllMain` )。 これは、これらの機能を使用するアプリケーションに実際に存在していたとして動作することを意図しているためです。 これらは、実行中のアプリケーションの一部にすぎないため、アプリケーションのグローバル状態を変更することが意図されています。

OLE コントロールとその他の Dll は大きく異なります。 呼び出し元のアプリケーションの状態を変更する必要はありません。これを呼び出すアプリケーションは、MFC アプリケーションであるとは限りません。そのため、変更する状態がない可能性があります。 これは、モジュールの状態の切り替えが考案された理由です。

Dll 内のダイアログボックスを起動する関数など、DLL からエクスポートされた関数の場合は、関数の先頭に次のコードを追加する必要があります。

```cpp
AFX_MANAGE_STATE(AfxGetStaticModuleState())
```

これにより、現在のモジュールの状態が、現在のスコープの末尾まで [AfxGetStaticModuleState](reference/extension-dll-macros.md#afxgetstaticmodulestate) から返された状態と交換されます。

AFX_MODULE_STATE マクロを使用しないと、Dll 内のリソースに関する問題が発生します。 既定では、MFC はメインアプリケーションのリソースハンドルを使用して、リソーステンプレートを読み込みます。 このテンプレートは、実際には DLL に格納されています。 根本的な原因は、MFC のモジュール状態情報が AFX_MODULE_STATE マクロによって切り替えられていないことです。 リソースハンドルは、MFC のモジュール状態から回復されます。 モジュールの状態を切り替えないと、正しくないリソースハンドルが使用されます。

AFX_MODULE_STATE は、DLL 内のすべての関数に配置する必要はありません。 たとえば、は、 `InitInstance` アプリケーションの mfc コードによって AFX_MODULE_STATE せずに呼び出すことができます。これは、mfc によってモジュールの状態が自動的にシフトされ `InitInstance` た後、が返された後に再び切り替えられるため `InitInstance` です。 すべてのメッセージマップハンドラーにも同じことが当てはまります。 通常の MFC Dll には、メッセージをルーティングする前にモジュールの状態を自動的に切り替える特別なマスターウィンドウプロシージャがあります。

## <a name="process-local-data"></a>ローカルデータの処理

ローカルデータを処理することは、Win32s DLL モデルの難しさではなく、このような大きな問題にはなりませんでした。 Win32s では、複数のアプリケーションによって読み込まれた場合でも、すべての Dll がグローバルデータを共有します。 これは、"real" Win32 DLL データモデルとは大きく異なります。各 DLL は、DLL にアタッチされている各プロセスで、データ領域の個別のコピーを取得します。 複雑さを増すために、Win32s DLL のヒープに割り当てられたデータは、実際には (少なくとも所有者の限り) 実際のプロセス固有のものになります。 次のデータとコードについて考えてみましょう。

```cpp
static CString strGlobal; // at file scope

__declspec(dllexport)
void SetGlobalString(LPCTSTR lpsz)
{
    strGlobal = lpsz;
}

__declspec(dllexport)
void GetGlobalString(LPCTSTR lpsz, size_t cb)
{
    StringCbCopy(lpsz, cb, strGlobal);
}
```

上記のコードが DLL 内に配置されていて、その DLL が2つのプロセス A と B によって読み込まれた場合 (実際には、同じアプリケーションの2つのインスタンスである可能性があります)、どうなるかを考えてみます。 を呼び出し `SetGlobalString("Hello from A")` ます。 その結果、 `CString` プロセス a のコンテキストでデータにメモリが割り当てられます。 `CString` 自体がグローバルであり、a と B の両方から参照できることに注意してください。B を呼び出し `GetGlobalString(sz, sizeof(sz))` ます。 B は、セットされたデータを表示できるようになります。 これは、Win32s が Win32 のようなプロセス間の保護を提供しないためです。 これが最初の問題です。多くの場合、1つのアプリケーションが、別のアプリケーションによって所有されていると見なされるグローバルデータに影響を与えることは望ましくありません。

他にも問題があります。 では、が終了するとします。 が終了すると、' ' 文字列によって使用されるメモリ `strGlobal` がシステムで使用できるようになります。つまり、プロセス A によって割り当てられたメモリはすべて、オペレーティングシステムによって自動的に解放されます。 デストラクターが呼び出されているため解放されません `CString` 。まだ呼び出されていません。 これは、割り当てられたアプリケーションがシーンから離れているためだけに解放されます。 B が呼び出された場合 `GetGlobalString(sz, sizeof(sz))` 、有効なデータが取得されない可能性があります。 他のアプリケーションがそのメモリを使用している可能性があります。

明らかに問題が存在します。 MFC 3.x では、スレッドローカルストレージ (TLS) と呼ばれる手法が使用されていました。 MFC 3.x では、Win32s の下にある TLS インデックスが、プロセスローカルストレージインデックスとして機能しますが、これは呼び出されず、その TLS インデックスに基づいてすべてのデータを参照することになります。 これは、Win32 でスレッドローカルデータを格納するために使用された TLS インデックスに似ています (その対象の詳細については、以下を参照してください)。 これにより、すべての MFC DLL で1プロセスあたり少なくとも2つの TLS インデックスが使用されるようになりました。 多くの OLE コントロール Dll (OCXs) を読み込むために、TLS インデックスが不足しています (使用できるのは64のみです)。 さらに、MFC では、すべてのデータを1つの場所に1つの構造で配置する必要がありました。 これは非常に拡張性がなく、TLS インデックスの使用に関しては理想的ではありませんでした。

MFC 4.x では、クラステンプレートのセットを使用して、ローカルで処理する必要があるデータをラップすることができます。 たとえば、前述の問題は、次のように記述することによって解決できます。

```cpp
struct CMyGlobalData : public CNoTrackObject
{
    CString strGlobal;
};
CProcessLocal<CMyGlobalData> globalData;

__declspec(dllexport)
void SetGlobalString(LPCTSTR lpsz)
{
    globalData->strGlobal = lpsz;
}

__declspec(dllexport)
void GetGlobalString(LPCTSTR lpsz, size_t cb)
{
    StringCbCopy(lpsz, cb, globalData->strGlobal);
}
```

MFC では、これを2つの手順で実装しています。 まず、Win32 __tls \*__ api (**TlsAlloc**、 **TlsSetValue**、 **TlsGetValue** など) の上に層があります。これは、1つのプロセスにつき2つの tls インデックスのみを使用します。これは、dll の数に関係なく使用できます。 次に、 `CProcessLocal` このデータにアクセスするためのテンプレートが用意されています。 これは、前述の直感的な構文を許可する演算子 > をオーバーライドします。 によってラップされるすべてのオブジェクトは、 `CProcessLocal` から派生する必要があり `CNoTrackObject` ます。 `CNoTrackObject` / プロセスが終了したときに MFC がプロセスのローカルオブジェクトを自動的に破棄できるように、下位レベルのアロケーター (LocalAlloc **LocalFree**) と仮想デストラクターを提供します。 追加のクリーンアップが必要な場合、このようなオブジェクトはカスタムデストラクターを持つことができます。 前の例では、埋め込みオブジェクトを破棄するための既定のデストラクターがコンパイラによって生成されるため、これは必要ありません `CString` 。

このアプローチには他にも興味深い利点があります。 すべてのオブジェクトが `CProcessLocal` 自動的に破棄されるだけでなく、必要になるまでは構築されません。 `CProcessLocal::operator->` は、最初に呼び出されたときに、関連付けられたオブジェクトをインスタンス化し、それ以上は実行しません。 上記の例では、これは、 `strGlobal` 最初のまたはが呼び出されるまで ' ' 文字列が構築されないことを意味し `SetGlobalString` `GetGlobalString` ます。 場合によっては、これにより、DLL の起動時間が短縮されます。

## <a name="thread-local-data"></a>スレッドローカルデータ

ローカルデータの処理と同様に、スレッドローカルデータは、データが特定のスレッドに対してローカルである必要がある場合に使用されます。 つまり、そのデータにアクセスするスレッドごとに、データの別のインスタンスが必要になります。 これは、広範な同期機構の代わりに、何度も使用できます。 データを複数のスレッドで共有する必要がない場合、このようなメカニズムはコストが高く、不要になることがあります。 `CString`(上記のサンプルと同じように) オブジェクトがあるとします。 テンプレートを使用して、スレッドをローカルにすることができ `CThreadLocal` ます。

```cpp
struct CMyThreadData : public CNoTrackObject
{
    CString strThread;
};
CThreadLocal<CMyThreadData> threadData;

void MakeRandomString()
{
    // a kind of card shuffle (not a great one)
    CString& str = threadData->strThread;
    str.Empty();
    while (str.GetLength() != 52)
    {
        unsigned int randomNumber;
        errno_t randErr;
        randErr = rand_s(&randomNumber);

        if (randErr == 0)
        {
            TCHAR ch = randomNumber % 52 + 1;
            if (str.Find(ch) <0)
            str += ch; // not found, add it
        }
    }
}
```

`MakeRandomString`が2つの異なるスレッドから呼び出された場合、それぞれが別の方法で文字列を "シャッフル" します。 これは、 `strThread` 1 つのグローバルインスタンスだけではなく、実際にはスレッドごとにインスタンスが存在するためです。

参照を使用して、 `CString` ループの反復ごとに1回ではなく、アドレスを1回キャプチャする方法に注意してください。 ループコードは、 `threadData->strThread` ' ' が使用されるすべての場所で記述されている可能性 `str` がありますが、コードの実行速度が大幅に低下します。 このような参照がループで発生する場合は、データへの参照をキャッシュすることをお勧めします。

`CThreadLocal`クラステンプレートは、と同じ実装手法と同じメカニズムを使用し `CProcessLocal` ます。

## <a name="see-also"></a>関連項目

[番号別テクニカルノート](../mfc/technical-notes-by-number.md)<br/>
[カテゴリ別テクニカルノート](../mfc/technical-notes-by-category.md)
