---
title: CWinAppEx クラス
ms.date: 11/04/2016
f1_keywords:
- CWinAppEx
- AFXWINAPPEX/CWinAppEx
- AFXWINAPPEX/CWinAppEx::CWinAppEx
- AFXWINAPPEX/CWinAppEx::CleanState
- AFXWINAPPEX/CWinAppEx::EnableLoadWindowPlacement
- AFXWINAPPEX/CWinAppEx::EnableTearOffMenus
- AFXWINAPPEX/CWinAppEx::EnableUserTools
- AFXWINAPPEX/CWinAppEx::ExitInstance
- AFXWINAPPEX/CWinAppEx::GetBinary
- AFXWINAPPEX/CWinAppEx::GetContextMenuManager
- AFXWINAPPEX/CWinAppEx::GetDataVersion
- AFXWINAPPEX/CWinAppEx::GetDataVersionMajor
- AFXWINAPPEX/CWinAppEx::GetDataVersionMinor
- AFXWINAPPEX/CWinAppEx::GetInt
- AFXWINAPPEX/CWinAppEx::GetKeyboardManager
- AFXWINAPPEX/CWinAppEx::GetMouseManager
- AFXWINAPPEX/CWinAppEx::GetObject
- AFXWINAPPEX/CWinAppEx::GetRegSectionPath
- AFXWINAPPEX/CWinAppEx::GetRegistryBase
- AFXWINAPPEX/CWinAppEx::GetSectionBinary
- AFXWINAPPEX/CWinAppEx::GetSectionInt
- AFXWINAPPEX/CWinAppEx::GetSectionObject
- AFXWINAPPEX/CWinAppEx::GetSectionString
- AFXWINAPPEX/CWinAppEx::GetShellManager
- AFXWINAPPEX/CWinAppEx::GetString
- AFXWINAPPEX/CWinAppEx::GetTooltipManager
- AFXWINAPPEX/CWinAppEx::GetUserToolsManager
- AFXWINAPPEX/CWinAppEx::InitContextMenuManager
- AFXWINAPPEX/CWinAppEx::InitKeyboardManager
- AFXWINAPPEX/CWinAppEx::InitMouseManager
- AFXWINAPPEX/CWinAppEx::InitShellManager
- AFXWINAPPEX/CWinAppEx::InitTooltipManager
- AFXWINAPPEX/CWinAppEx::IsResourceSmartUpdate
- AFXWINAPPEX/CWinAppEx::IsStateExists
- AFXWINAPPEX/CWinAppEx::LoadState
- AFXWINAPPEX/CWinAppEx::OnAppContextHelp
- AFXWINAPPEX/CWinAppEx::OnViewDoubleClick
- AFXWINAPPEX/CWinAppEx::OnWorkspaceIdle
- AFXWINAPPEX/CWinAppEx::SaveState
- AFXWINAPPEX/CWinAppEx::SetRegistryBase
- AFXWINAPPEX/CWinAppEx::ShowPopupMenu
- AFXWINAPPEX/CWinAppEx::WriteBinary
- AFXWINAPPEX/CWinAppEx::WriteInt
- AFXWINAPPEX/CWinAppEx::WriteObject
- AFXWINAPPEX/CWinAppEx::WriteSectionBinary
- AFXWINAPPEX/CWinAppEx::WriteSectionInt
- AFXWINAPPEX/CWinAppEx::WriteSectionObject
- AFXWINAPPEX/CWinAppEx::WriteSectionString
- AFXWINAPPEX/CWinAppEx::WriteString
- AFXWINAPPEX/CWinAppEx::LoadCustomState
- AFXWINAPPEX/CWinAppEx::LoadWindowPlacement
- AFXWINAPPEX/CWinAppEx::OnClosingMainFrame
- AFXWINAPPEX/CWinAppEx::PreLoadState
- AFXWINAPPEX/CWinAppEx::PreSaveState
- AFXWINAPPEX/CWinAppEx::ReloadWindowPlacement
- AFXWINAPPEX/CWinAppEx::SaveCustomState
- AFXWINAPPEX/CWinAppEx::StoreWindowPlacement
- AFXWINAPPEX/CWinAppEx::m_bForceImageReset
helpviewer_keywords:
- CWinAppEx [MFC], CWinAppEx
- CWinAppEx [MFC], CleanState
- CWinAppEx [MFC], EnableLoadWindowPlacement
- CWinAppEx [MFC], EnableTearOffMenus
- CWinAppEx [MFC], EnableUserTools
- CWinAppEx [MFC], ExitInstance
- CWinAppEx [MFC], GetBinary
- CWinAppEx [MFC], GetContextMenuManager
- CWinAppEx [MFC], GetDataVersion
- CWinAppEx [MFC], GetDataVersionMajor
- CWinAppEx [MFC], GetDataVersionMinor
- CWinAppEx [MFC], GetInt
- CWinAppEx [MFC], GetKeyboardManager
- CWinAppEx [MFC], GetMouseManager
- CWinAppEx [MFC], GetObject
- CWinAppEx [MFC], GetRegSectionPath
- CWinAppEx [MFC], GetRegistryBase
- CWinAppEx [MFC], GetSectionBinary
- CWinAppEx [MFC], GetSectionInt
- CWinAppEx [MFC], GetSectionObject
- CWinAppEx [MFC], GetSectionString
- CWinAppEx [MFC], GetShellManager
- CWinAppEx [MFC], GetString
- CWinAppEx [MFC], GetTooltipManager
- CWinAppEx [MFC], GetUserToolsManager
- CWinAppEx [MFC], InitContextMenuManager
- CWinAppEx [MFC], InitKeyboardManager
- CWinAppEx [MFC], InitMouseManager
- CWinAppEx [MFC], InitShellManager
- CWinAppEx [MFC], InitTooltipManager
- CWinAppEx [MFC], IsResourceSmartUpdate
- CWinAppEx [MFC], IsStateExists
- CWinAppEx [MFC], LoadState
- CWinAppEx [MFC], OnAppContextHelp
- CWinAppEx [MFC], OnViewDoubleClick
- CWinAppEx [MFC], OnWorkspaceIdle
- CWinAppEx [MFC], SaveState
- CWinAppEx [MFC], SetRegistryBase
- CWinAppEx [MFC], ShowPopupMenu
- CWinAppEx [MFC], WriteBinary
- CWinAppEx [MFC], WriteInt
- CWinAppEx [MFC], WriteObject
- CWinAppEx [MFC], WriteSectionBinary
- CWinAppEx [MFC], WriteSectionInt
- CWinAppEx [MFC], WriteSectionObject
- CWinAppEx [MFC], WriteSectionString
- CWinAppEx [MFC], WriteString
- CWinAppEx [MFC], LoadCustomState
- CWinAppEx [MFC], LoadWindowPlacement
- CWinAppEx [MFC], OnClosingMainFrame
- CWinAppEx [MFC], PreLoadState
- CWinAppEx [MFC], PreSaveState
- CWinAppEx [MFC], ReloadWindowPlacement
- CWinAppEx [MFC], SaveCustomState
- CWinAppEx [MFC], StoreWindowPlacement
- CWinAppEx [MFC], m_bForceImageReset
ms.assetid: a3d3e053-3e22-463f-9444-c73abb1bb9d7
ms.openlocfilehash: 1e022f09986f5d49ab2bba44c62cb716ce939a0c
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81369615"
---
# <a name="cwinappex-class"></a>CWinAppEx クラス

`CWinAppEx`アプリケーションの状態を処理し、レジストリに状態を保存し、レジストリから状態を読み込み、アプリケーション マネージャを初期化し、同じアプリケーション マネージャへのリンクを提供します。

詳細については、Visual Studio のインストールの**\\VC\\atlmfc\\src mfc**フォルダーにあるソース コードを参照してください。

## <a name="syntax"></a>構文

```
class CWinAppEx : public CWinApp
```

## <a name="members"></a>メンバー

### <a name="public-constructors"></a>パブリック コンストラクター

|名前|説明|
|----------|-----------------|
|[CWinAppEx::CWinAppEx](#cwinappex)|`CWinAppEx` オブジェクトを構築します。|

### <a name="public-methods"></a>パブリック メソッド

|名前|説明|
|----------|-----------------|
|[クウィナップス::クリーンステート](#cleanstate)|アプリケーションに関する情報を Windows レジストリから削除します。|
|[::ロードウィンドウ配置を有効にします。](#enableloadwindowplacement)|アプリケーションがメイン フレーム ウィンドウの初期サイズと場所をレジストリから読み込むかどうかを指定します。|
|[CWinAppEx::イネーブルティアオフメニュー](#enabletearoffmenus)|アプリケーションのティアオフ メニューを有効にします。|
|[::ユーザーツールを有効にする](#enableusertools)|ユーザーがアプリケーションでカスタム メニュー コマンドを作成できるようにします。|
|[::出口インスタンス](#exitinstance)|アプリケーションのこのインスタンスを終了するために`Run`、メンバー関数内からフレームワークによって呼び出されます。 (CWinApp をオーバーライド[します。::インスタンスを終了](../../mfc/reference/cwinapp-class.md#exitinstance)します。|
|[::ゲットバイナリ](#getbinary)|指定したレジストリ値に関連付けられているバイナリ データを読み取ります。|
|[::コンテキストメニューマネージャー](#getcontextmenumanager)|グローバル[な CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md)オブジェクトへのポインターを返します。|
|[次のバージョンを取得します。](#getdataversion)||
|[CWinAppEx::取得データバージョンメジャー](#getdataversionmajor)|Windows レジストリに保存されているアプリケーションのメジャー バージョンを返します。|
|[CWinAppEx::データバージョンマイナー](#getdataversionminor)|Windows レジストリに保存されているアプリケーションのマイナー バージョンを返します。|
|[CWinAppEx::ゲットイント](#getint)|指定した値に関連付けられている数値データをレジストリから読み取ります。|
|[::ゲッキーキーボードマネージャー](#getkeyboardmanager)|グローバル[CKeyboard マネージャー](../../mfc/reference/ckeyboardmanager-class.md)オブジェクトへのポインターを返します。|
|[::ゲットマウスマネージャー](#getmousemanager)|グローバル[CMouseManager](../../mfc/reference/cmousemanager-class.md)オブジェクトへのポインターを返します。|
|[::オブジェクトを取得します。](#getobject)|指定`CObject`した値に関連付けられている派生データをレジストリから読み取ります。|
|[::ゲットレグセクションパス](#getregsectionpath)|レジストリ キーのパスを示す文字列を返します。 このパスは、指定された相対パスとアプリケーションパスを連結します。|
|[::レジストリベースを取得します。](#getregistrybase)|アプリケーションのレジストリ パスを返します。|
|[::ゲットセクションバイナリ](#getsectionbinary)|指定したキーと値に関連付けられているバイナリ データをレジストリから読み取ります。|
|[CWinAppEx::ゲットセクションイント](#getsectionint)|指定したキーと値に関連付けられているレジストリから数値データを読み取ります。|
|[::オブジェクトを取得します。](#getsectionobject)|指定`CObject`したキーと値に関連付けられているデータをレジストリから読み取ります。|
|[::ゲットセクション文字列](#getsectionstring)|指定したキーと値に関連付けられている文字列データをレジストリから読み取ります。|
|[::ゲットシェルマネージャー](#getshellmanager)|グローバル[CShellManager](../../mfc/reference/cshellmanager-class.md)オブジェクトへのポインターを返します。|
|[::ゲットストリング](#getstring)|指定した値に関連付けられている文字列データをレジストリから読み取ります。|
|[::ツールチップマネージャー](#gettooltipmanager)|グローバル[CTooltip マネージャー](../../mfc/reference/ctooltipmanager-class.md)オブジェクトへのポインターを返します。|
|[::ユーザーツールマネージャー](#getusertoolsmanager)|グローバルな[CUserTools マネージャー](../../mfc/reference/cusertoolsmanager-class.md)オブジェクトへのポインターを返します。|
|[::イニトコンテキストメニューマネージャー](#initcontextmenumanager)|`CContextMenuManager` オブジェクトを初期化します。|
|[::イニトキーボードマネージャー](#initkeyboardmanager)|`CKeyboardManager` オブジェクトを初期化します。|
|[CWinAppEx::イニトマウスマネージャー](#initmousemanager)|`CMouseManager` オブジェクトを初期化します。|
|[::イニトシェルマネージャー](#initshellmanager)|クラスを初期化`CShellManager`します。|
|[::イニトツールチップマネージャー](#inittooltipmanager)|`CTooltipManager` クラスを初期化します。|
|[を更新します。](#isresourcesmartupdate)||
|[CWinAppEx::IsState は存在します。](#isstateexists)|指定したキーがレジストリ内にあるかどうかを示します。|
|[を使用します。](#loadstate)|レジストリからアプリケーションの状態を読み込みます。|
|[をクリックしてください。](#onappcontexthelp)|ユーザーが **[カスタマイズ]** ダイアログ ボックスのコンテキスト ヘルプを要求したときに、フレームワークによって呼び出されます。|
|[CWinAppEx::オンビューダブルクリック](#onviewdoubleclick)|ユーザーがアプリケーション内の任意の場所をダブルクリックしたときに、ユーザー定義コマンドを呼び出します。|
|[::オンワークスペースアイドル](#onworkspaceidle)||
|[CWinAppEx::セーブステート](#savestate)|アプリケーション フレームワークの状態を Windows レジストリに書き込みます。|
|[::セットレジストリベース](#setregistrybase)|既定のレジストリ キーのパスを設定します。 このキーは、後続のすべてのレジストリ呼び出しのルートとして機能します。|
|[::ポップアップメニュー](#showpopupmenu)|ポップアップ メニューを表示します。|
|[::書き込みバイナリ](#writebinary)|バイナリ データを指定したレジストリ値に書き込みます。|
|[CWinAppEx::書き込みイント](#writeint)|指定したレジストリ値に数値データを書き込みます。|
|[オブジェクトを書き込む](#writeobject)|[CObject クラス](../../mfc/reference/cobject-class.md)から派生したデータを、指定されたレジストリ値に書き込みます。|
|[::書き込みセクションバイナリ](#writesectionbinary)|バイナリ データを指定されたレジストリ キーの値に書き込みます。|
|[CWinAppEx::書き込みセクションイント](#writesectionint)|数値データを指定されたレジストリ キーの値に書き込みます。|
|[オブジェクトを書き込みます。](#writesectionobject)|クラスから派生したデータ`CObject`を、指定したレジストリ キーの値に書き込みます。|
|[::セクション文字列を書き込みます](#writesectionstring)|指定したレジストリ キーの値に文字列データを書き込みます。|
|[::書き込み文字列](#writestring)|指定したレジストリ値に文字列データを書き込みます。|

### <a name="protected-methods"></a>プロテクト メソッド

|名前|説明|
|----------|-----------------|
|[を使用します。](#loadcustomstate)|アプリケーションの状態が読み込まれたときに、フレームワークによって呼び出されます。|
|[::ロードウィンドウ配置](#loadwindowplacement)|アプリケーションのサイズと場所をレジストリから読み込むときに、フレームワークによって呼び出されます。 読み込まれたデータには、アプリケーションが最後に閉じた時点でのメイン フレームのサイズと位置が含まれます。|
|[CWinAppEx::オンクロージングメインフレーム](#onclosingmainframe)|メイン フレーム ウィンドウがWM_CLOSEを処理しているときに、フレームワークによって呼び出されます。|
|[CWinAppEx::P読み込み状態](#preloadstate)|アプリケーションの状態が読み込まれる直前に、フレームワークによって呼び出されます。|
|[CWinAppEx::Pセーブステート](#presavestate)|アプリケーションの状態が保存される直前に、フレームワークによって呼び出されます。|
|[::リロードウィンドウ配置](#reloadwindowplacement)|指定されたウィンドウのサイズと場所をレジストリから再読み込みします。|
|[::カスタム状態を保存します。](#savecustomstate)|アプリケーションの状態をレジストリに書き込んだ後、フレームワークによって呼び出されます。|
|[::ストアウィンドウ配置](#storewindowplacement)|メイン フレームのサイズと場所をレジストリに書き込むために、フレームワークによって呼び出されます。|

### <a name="data-members"></a>データ メンバー

|名前|説明|
|----------|-----------------|
|[CWinAppEx::m_bForceImageReset](#m_bforceimagereset)|ツール バーを含むフレーム ウィンドウが読み込まれたときに、フレームワークがすべてのツール バー イメージをリセットするかどうかを指定します。|

## <a name="remarks"></a>解説

MFC フレームワークによって提供される機能の多くは、クラス`CWinAppEx`に依存します。 次の 2`CWinAppEx`つの方法のいずれかで、クラスをアプリケーションに組み込むことができます。

- メイン`CWinAppEx`スレッドでクラスを構築します。

- からメイン アプリケーション クラス`CWinAppEx`を派生します。

アプリケーションに組`CWinAppEx`み込んだ後、アプリケーション マネージャのいずれかを初期化できます。 アプリケーション マネージャーを使用する前に、適切な initialize メソッドを呼び出してアプリケーション マネージャーを初期化する必要があります。 特定のマネージャーへのポインターを取得するには、関連付けられている get メソッドを呼び出します。 クラス`CWinAppEx`は、次のアプリケーション マネージャーを管理します: [CMouse マネージャー クラス](../../mfc/reference/cmousemanager-class.md)[、CContextMenu マネージャー クラス](../../mfc/reference/ccontextmenumanager-class.md)[、C キーボード マネージャー クラス](../../mfc/reference/ckeyboardmanager-class.md) [、CUserTools マネージャー クラス](../../mfc/reference/cusertoolsmanager-class.md)、および[CMenuTearOffManager クラス](../../mfc/reference/cmenutearoffmanager-class.md)。

## <a name="inheritance-hierarchy"></a>継承階層

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWinThread](../../mfc/reference/cwinthread-class.md)

[Cwinapp](../../mfc/reference/cwinapp-class.md)

[CWinAppEx](../../mfc/reference/cwinappex-class.md)

## <a name="requirements"></a>必要条件

**ヘッダー:** afxwinappex.h

## <a name="cwinappexcleanstate"></a><a name="cleanstate"></a>クウィナップス::クリーンステート

アプリケーションに関するすべての情報を Windows レジストリから削除します。

```
virtual BOOL CleanState(LPCTSTR lpszSectionName=NULL);
```

### <a name="parameters"></a>パラメーター

*名前*<br/>
[in]レジストリ キーのパスを含む文字列。

### <a name="return-value"></a>戻り値

メソッドが成功した場合は 0 以外の値を返します。それ以外の場合は 0。

### <a name="remarks"></a>解説

このメソッドは、レジストリの特定のセクションからアプリケーション データを消去します。 クリアするセクションを指定するには、 *lpszSectionName*パラメーターを使用します。 *lpszSectionName*が NULL の場合、このメソッドはオブジェクトに格納されている`CWinAppEx`既定のレジストリ パスを使用します。 既定のレジストリ パスを取得するには[、CWinAppEx::GetRegistryBase](#getregistrybase)を使用します。

## <a name="cwinappexcwinappex"></a><a name="cwinappex"></a>CWinAppEx::CWinAppEx

`CWinAppEx` オブジェクトを構築します。

```
CWinAppEx(BOOL bResourceSmartUpdate = FALSE);
```

### <a name="parameters"></a>パラメーター

*を更新します。*<br/>
[in]ワークスペース オブジェクトがリソースの更新を検出して処理するかどうかを指定するブール値パラメーター。

### <a name="remarks"></a>解説

この`CWinAppEx`クラスには初期化メソッドがあり、アプリケーション情報をレジストリに保存および読み込む機能を提供し、グローバル アプリケーション設定を制御します。 また[、CKeyboardManager クラス](../../mfc/reference/ckeyboardmanager-class.md)や[CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md)クラスなどのグローバル マネージャを使用することもできます。 各アプリケーションは、クラスのインスタンスを`CWinAppEx`1 つだけ持つことができます。

## <a name="cwinappexenableloadwindowplacement"></a><a name="enableloadwindowplacement"></a>::ロードウィンドウ配置を有効にします。

アプリケーションがメイン フレーム ウィンドウの初期サイズと場所をレジストリから読み込むかどうかを指定します。

```
void EnableLoadWindowPlacement(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>パラメーター

*b 有効にする*<br/>
[in]アプリケーションがメイン フレーム ウィンドウの初期サイズと場所をレジストリから読み込むかどうかを指定します。

### <a name="remarks"></a>解説

既定では、メイン フレームのサイズと場所は、他のアプリケーション設定と共にレジストリから読み込まれます。 これは[、CWinAppEx::ロードステート中](#loadstate)に発生します。 レジストリから初期ウィンドウの配置を読み込まない場合は *、bEnable*を FALSE に設定してこのメソッドを呼び出します。

## <a name="cwinappexenabletearoffmenus"></a><a name="enabletearoffmenus"></a>CWinAppEx::イネーブルティアオフメニュー

[オブジェクトを](../../mfc/reference/cmenutearoffmanager-class.md)作成して初期化します。

```
BOOL EnableTearOffMenus(
    LPCTSTR lpszRegEntry,
    const UINT uiCmdFirst,
    const UINT uiCmdLast);
```

### <a name="parameters"></a>パラメーター

*をクリックします。*<br/>
[in]レジストリ キーのパスを含む文字列。 アプリケーションは、このレジストリ キーを使用して、ティアオフ メニューの情報を格納します。

*最初にコマンドを実行します。*<br/>
[in]最初のティアオフメニュー ID。

*をクリックします。*<br/>
[in]最後のティアオフメニュー ID。

### <a name="return-value"></a>戻り値

が正常に`CMenuTearOffManager`作成され、初期化された場合は TRUE。エラーが発生した場合、または既に`CMenuTearOffManager`存在する場合は FALSE。

### <a name="remarks"></a>解説

この関数を使用して、アプリケーションでティアオフ メニューを有効にします。 この関数は から呼`InitInstance`び出す必要があります。

## <a name="cwinappexenableusertools"></a><a name="enableusertools"></a>::ユーザーツールを有効にする

ユーザーがアプリケーションのキーストロークを減らすカスタム メニュー コマンドを作成できるようにします。 このメソッドは、[オブジェクトを](../../mfc/reference/cusertoolsmanager-class.md)作成します。

```
BOOL EnableUserTools(
    const UINT uiCmdToolsDummy,
    const UINT uiCmdFirst,
    const UINT uiCmdLast,
    CRuntimeClass* pToolRTC = RUNTIME_CLASS(CUserTool),
    UINT uArgMenuID = 0,
    UINT uInitDirMenuID = 0);
```

### <a name="parameters"></a>パラメーター

*uiCmdツールダミー*<br/>
[in]フレームワークがユーザー ツール メニューのコマンド ID のプレースホルダーとして使用する符号なし整数。

*最初にコマンドを実行します。*<br/>
[in]最初のユーザー ツール コマンドのコマンド ID。

*をクリックします。*<br/>
[in]最後のユーザー ツール コマンドのコマンド ID。

*をクリックします。*<br/>
[in]オブジェクトが新しい`CUserToolsManager`ユーザー ツールを作成するために使用するクラス。

*をクリックします。*<br/>
[in]引数メニュー ID。

*ユーイニトディルメニューID*<br/>
[in]初期ツール ディレクトリのメニュー ID。

### <a name="return-value"></a>戻り値

メソッドがオブジェクトを作成して初期化する場合`CUserToolsManager`は TRUE。メソッドが失敗した場合、またはオブジェクト`CUserToolsManager`が既に存在する場合は FALSE。

### <a name="remarks"></a>解説

ユーザー定義ツールを有効にすると、フレームワークはカスタマイズ時に拡張できる動的メニューを自動的にサポートします。 フレームワークは、新しい各項目を外部コマンドに関連付けます。 ユーザーが **[ツール]** メニューから適切な項目を選択すると、フレームワークはこれらのコマンドを呼び出します。

ユーザーが新しい項目を追加するたびに、フレームワークは新しいオブジェクトを作成します。 新しいオブジェクトのクラス型は*pToolRTC*によって定義されます。 *クラス型は*[、CUserTool クラス](../../mfc/reference/cusertool-class.md)から派生する必要があります。

ユーザー ツールの詳細と、ユーザー ツールをアプリケーションに組み込む方法については、「[ユーザー定義ツール](../../mfc/user-defined-tools.md)」を参照してください。

## <a name="cwinappexexitinstance"></a><a name="exitinstance"></a>::出口インスタンス

```
virtual int ExitInstance();
```

### <a name="return-value"></a>戻り値

### <a name="remarks"></a>解説

## <a name="cwinappexgetbinary"></a><a name="getbinary"></a>::ゲットバイナリ

指定したレジストリ キーからバイナリ データを読み取ります。

```
BOOL GetBinary(
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>パラメーター

*をクリックします。*<br/>
[in]レジストリ キーの名前を含む文字列。

*Ppdata*<br/>
[アウト]メソッドがバイナリ データで埋めるバッファーへのポインター。

*バイト数*<br/>
[アウト]読み取ったバイト数を書き込むためにメソッドが使用する符号なし整数へのポインター。

### <a name="return-value"></a>戻り値

成功した場合は TRUE。それ以外の場合は FALSE。

### <a name="remarks"></a>解説

このメソッドは、レジストリに書き込まれたバイナリ データを読み取ります。 レジストリにデータを書き込むには、メソッド[CWinAppEx::書き込みバイナリ](#writebinary)と[CWinAppEx:::WriteSectionBinary](#writesectionbinary)を使用します。

*lpszEntry*パラメーターは、アプリケーションの既定のレジストリ キーの下にあるレジストリ エントリの名前です。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase を](#setregistrybase)使用します。

## <a name="cwinappexgetcontextmenumanager"></a><a name="getcontextmenumanager"></a>::コンテキストメニューマネージャー

グローバル[な CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md)オブジェクトへのポインターを返します。

```
CContextMenuManager* GetContextMenuManager();
```

### <a name="return-value"></a>戻り値

グローバル`CContextMenuManager`オブジェクトへのポインター。

### <a name="remarks"></a>解説

オブジェクトが初期化されていない場合、この関数はポインターを返す前に[CWinAppEx::InitContextMenuManager](#initcontextmenumanager)を呼び出します。

## <a name="cwinappexgetdataversion"></a><a name="getdataversion"></a>次のバージョンを取得します。

```
int GetDataVersion() const;
```

### <a name="return-value"></a>戻り値

### <a name="remarks"></a>解説

## <a name="cwinappexgetdataversionmajor"></a><a name="getdataversionmajor"></a>CWinAppEx::取得データバージョンメジャー

[CWinAppEx::SaveState](#savestate)を呼び出すときに、Windows レジストリに保存されているアプリケーションのメジャー バージョンを返します。

```
int GetDataVersionMajor() const;
```

### <a name="return-value"></a>戻り値

メジャー バージョン番号を格納する整数値。

## <a name="cwinappexgetdataversionminor"></a><a name="getdataversionminor"></a>CWinAppEx::データバージョンマイナー

[CWinAppEx::SaveState](#savestate)を呼び出すときに、Windows レジストリに保存されているアプリケーションのマイナー バージョンを返します。

```
int GetDataVersionMinor() const;
```

### <a name="return-value"></a>戻り値

マイナー バージョン番号を含む整数値。

## <a name="cwinappexgetint"></a><a name="getint"></a>CWinAppEx::ゲットイント

指定したレジストリ キーから整数データを読み取ります。

```
int GetInt(
    LPCTSTR lpszEntry,
    int nDefault = 0);
```

### <a name="parameters"></a>パラメーター

*をクリックします。*<br/>
[in]レジストリ エントリの名前を含む文字列。

*nデフォルト*<br/>
[in]指定したレジストリ エントリが存在しない場合にメソッドが返す既定値。

### <a name="return-value"></a>戻り値

メソッドが成功した場合はレジストリ データ。それ以外*の場合は、nDefault を使用します*。

### <a name="remarks"></a>解説

このメソッドは、レジストリから整数データを読み取ります。 *lpszEntry*で示されるレジストリ キーに関連付けられている整数データがない場合、このメソッドは*nDefault*を返します。 レジストリにデータを書き込むには、メソッド[CWinAppEx::WriteSectionInt](#writesectionint)と[CWinAppEx::WriteInt](#writeint)を使用します。

*lpszEntry*パラメーターは、アプリケーションの既定のレジストリ キーの下にあるレジストリ エントリの名前です。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase を](#setregistrybase)使用します。

## <a name="cwinappexgetkeyboardmanager"></a><a name="getkeyboardmanager"></a>::ゲッキーキーボードマネージャー

グローバル[CKeyboard マネージャー](../../mfc/reference/ckeyboardmanager-class.md)オブジェクトへのポインターを返します。

```
CKeyboardManager* GetKeyboardManager();
```

### <a name="return-value"></a>戻り値

グローバル`CKeyboardManager`オブジェクトへのポインター。

### <a name="remarks"></a>解説

キーボード マネージャーが初期化されていない場合、この関数は、ポインターを返す前に[CWinAppEx::InitKeyboardManager](#initkeyboardmanager)を呼び出します。

## <a name="cwinappexgetmousemanager"></a><a name="getmousemanager"></a>::ゲットマウスマネージャー

グローバル[CMouseManager](../../mfc/reference/cmousemanager-class.md)オブジェクトへのポインターを返します。

```
CMouseManager* GetMouseManager();
```

### <a name="return-value"></a>戻り値

グローバル`CMouseManager`オブジェクトへのポインター。

### <a name="remarks"></a>解説

マウス マネージャーが初期化されていない場合、この関数は、ポインターを返す前に[CWinAppEx::InitMouseManager](#initmousemanager)を呼び出します。

## <a name="cwinappexgetobject"></a><a name="getobject"></a>::オブジェクトを取得します。

[CObject](../../mfc/reference/cobject-class.md)-dervied データをレジストリから読み取ります。

```
BOOL GetObject(
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>パラメーター

*をクリックします。*<br/>
[in]レジストリ エントリの相対パスを含む文字列。

*obj*<br/>
[アウト]への参照。 `CObject` このメソッドは、この参照を使用してレジストリ データを格納します。

### <a name="return-value"></a>戻り値

メソッドが成功した場合は 0 以外の値を返します。それ以外の場合は 0。

### <a name="remarks"></a>解説

このメソッドは、 から`CObject`派生したレジストリからデータを読み取ります。 レジストリに`CObject`データを書き込むには[、CWinAppEx::WriteObject](#writeobject)または[CWinAppEx::WriteSectionObject](#writesectionobject)を使用します。

*lpszEntry*パラメーターは、アプリケーションの既定のレジストリ キーの下にあるレジストリ エントリの名前です。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase を](#setregistrybase)使用します。

## <a name="cwinappexgetregistrybase"></a><a name="getregistrybase"></a>::レジストリベースを取得します。

アプリケーションの既定のレジストリ パスを取得します。

```
LPCTSTR GetRegistryBase();
```

### <a name="return-value"></a>戻り値

既定のレジストリの場所のパスを含む文字列。

### <a name="remarks"></a>解説

レジストリにアクセスする[CWinAppEx クラス](../../mfc/reference/cwinappex-class.md)のすべてのメソッドは、既定の場所で開始します。 このメソッドは、既定のレジストリの場所のパスを取得するために使います。 既定[のレジストリの場所を変更するには、CWinAppEx::SetRegistryBase](#setregistrybase)を使用します。

## <a name="cwinappexgetregsectionpath"></a><a name="getregsectionpath"></a>::ゲットレグセクションパス

レジストリ キーの絶対パスを作成して返します。

```
CString GetRegSectionPath(LPCTSTR szSectionAdd = _T(""));
```

### <a name="parameters"></a>パラメーター

*セクションの追加*<br/>
[in]レジストリ キーの相対パスを含む文字列。

### <a name="return-value"></a>戻り値

レジストリ`CString`キーの絶対パスを含む A。

### <a name="remarks"></a>解説

このメソッドは *、szSectionAdd*の相対パスをアプリケーションの既定のレジストリの場所に追加することによって、レジストリ キーの絶対パスを定義します。 既定のレジストリ キーを取得するには、メソッド[CWinAppEx::GetRegistryBase](#getregistrybase)を使用します。

## <a name="cwinappexgetsectionbinary"></a><a name="getsectionbinary"></a>::ゲットセクションバイナリ

レジストリからバイナリ データを読み取ります。

```
BOOL GetSectionBinary(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>パラメーター

*セクション*<br/>
[in]レジストリ キーの相対パスを含む文字列。

*をクリックします。*<br/>
[in]読み取る値を含む文字列。

*Ppdata*<br/>
[アウト]メソッドがデータを格納するバッファーへのポインター。

*バイト数*<br/>
[アウト]符号なし整数へのポインター。 このメソッドは *、ppData*のサイズをこのパラメーターに書き込みます。

### <a name="return-value"></a>戻り値

成功した場合は TRUE、それ以外の場合は FALSE。

### <a name="remarks"></a>解説

このメソッドは[、CWinAppEx::WriteBinary](#writebinary)および[CWinAppEx::WriteSectionBinary](#writesectionbinary)メソッドを使用してレジストリに書き込まれるバイナリ データを読み取ります。

*パラメーター*はレジストリ エントリの絶対パスではありません。 これは、アプリケーションの既定のレジストリ キーの末尾に追加される相対パスです。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase を](#setregistrybase)使用します。

## <a name="cwinappexgetsectionint"></a><a name="getsectionint"></a>CWinAppEx::ゲットセクションイント

レジストリから整数データを読み取ります。

```
int GetSectionInt(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    int nDefault = 0);
```

### <a name="parameters"></a>パラメーター

*セクション*<br/>
[in]レジストリ キーの相対パスを含む文字列。

*をクリックします。*<br/>
[in]読み取る値を含む文字列。

*nデフォルト*<br/>
[in]指定した値が存在しない場合に返す既定値。

### <a name="return-value"></a>戻り値

指定したレジストリ値に格納される整数データ。*nデータ*が存在しない場合はデフォルトです。

### <a name="remarks"></a>解説

整数データをレジストリに書き込むには[、CWinAppEx::WriteInt](#writeint)と[CWinAppEx::WriteSectionInt](#writesectionint)メソッドを使用します。

*パラメーター*はレジストリ エントリの絶対パスではありません。 これは、アプリケーションの既定のレジストリ キーの末尾に追加される相対パスです。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase を](#setregistrybase)使用します。

## <a name="cwinappexgetsectionobject"></a><a name="getsectionobject"></a>::オブジェクトを取得します。

[CObject](../../mfc/reference/cobject-class.md)レジストリ データをレジストリから読み取ります。

```
BOOL GetSectionObject(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>パラメーター

*セクション*<br/>
[in]レジストリ キーの相対パスを含む文字列。

*をクリックします。*<br/>
[in]読み取る値を含む文字列。

*obj*<br/>
[アウト]への参照。 `CObject` このメソッドは、`CObject`これを使用してレジストリ データを格納します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

このメソッドは、レジストリからデータを読み取ります。 読み取られる`CObject`データは、データ、または から`CObject`派生したクラスのデータです。 レジストリに`CObject`データを書き込むには[、CWinAppEx::WriteObject](#writeobject)または[CWinAppEx::WriteSectionObject](#writesectionobject)を使用します。

*パラメーター*はレジストリ エントリの絶対パスではありません。 これは、アプリケーションの既定のレジストリ キーの末尾に追加される相対パスです。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase を](#setregistrybase)使用します。

## <a name="cwinappexgetsectionstring"></a><a name="getsectionstring"></a>::ゲットセクション文字列

レジストリから文字列データを読み取ります。

```
CString GetSectionString(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszDefault = _T(""));
```

### <a name="parameters"></a>パラメーター

*セクション*<br/>
[in]レジストリ キーの相対パスを含む文字列。

*をクリックします。*<br/>
[in]読み取る値を含む文字列。

*デフォルト*<br/>
[in]指定した値が存在しない場合に返す既定値。

### <a name="return-value"></a>戻り値

データが存在する場合は、指定したレジストリ値に格納されている文字列データ。それ以外*の場合は、デフォルトを lpsz*します。

### <a name="remarks"></a>解説

このメソッドは、レジストリに書き込まれた文字列データを読み取ります。 文字列データをレジストリに書き込むには[、CWinAppEx::書き込み](#writestring)文字列と[CWinAppEx::WriteSectionString](#writesectionstring)を使用します。

*パラメーター*はレジストリ エントリの絶対パスではありません。 これは、アプリケーションの既定のレジストリ キーの末尾に追加される相対パスです。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase を](#setregistrybase)使用します。

## <a name="cwinappexgetshellmanager"></a><a name="getshellmanager"></a>::ゲットシェルマネージャー

グローバル[CShellManager](../../mfc/reference/cshellmanager-class.md)オブジェクトへのポインターを返します。

```
CShellManager* GetShellManager();
```

### <a name="return-value"></a>戻り値

グローバル`CShellManager`オブジェクトへのポインター。

### <a name="remarks"></a>解説

オブジェクトが`CShellManager`初期化されていない場合、この関数はポインターを返す前に[CWinAppEx::InitShellManager](#initshellmanager)を呼び出します。

## <a name="cwinappexgetstring"></a><a name="getstring"></a>::ゲットストリング

指定したレジストリ キーから文字列データを読み取ります。

```
CString GetString(
    LPCTSTR lpszEntry,
    LPCTSTR lpzDefault= _T(""));
```

### <a name="parameters"></a>パラメーター

*をクリックします。*<br/>
[in]レジストリ キーの名前を含む文字列

*デフォルト*<br/>
[in]指定したレジストリ エントリが存在しない場合にメソッドが返す既定値。

### <a name="return-value"></a>戻り値

正常終了した場合は、レジストリに格納されている文字列データ。*それ以外の場合はデフォルトです*。

### <a name="remarks"></a>解説

このメソッドは、レジストリに書き込まれた文字列データを読み取ります。 レジストリにデータを書き込むには、メソッド[CWinAppEx::書き込み文字列](#writestring)または[CWinAppEx::WriteSectionString](#writesectionstring)を使用します。

*lpszEntry*パラメーターは、アプリケーションの既定のレジストリ キーの下にあるレジストリ エントリの名前です。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase を](#setregistrybase)使用します。

## <a name="cwinappexgettooltipmanager"></a><a name="gettooltipmanager"></a>::ツールチップマネージャー

グローバル[CTooltip マネージャー](../../mfc/reference/ctooltipmanager-class.md)オブジェクトへのポインターを返します。

```
CTooltipManager* GetTooltipManager();
```

### <a name="return-value"></a>戻り値

グローバル`CTooltipManager`オブジェクトへのポインター。

### <a name="remarks"></a>解説

オブジェクトが`CTooltipManager`初期化されていない場合、この関数はポインターを返す前に[CWinAppEx::InitTooltipManager](#inittooltipmanager)を呼び出します。

## <a name="cwinappexgetusertoolsmanager"></a><a name="getusertoolsmanager"></a>::ユーザーツールマネージャー

グローバルな[CUserTools マネージャー](../../mfc/reference/cusertoolsmanager-class.md)オブジェクトへのポインターを返します。

```
CUserToolsManager* GetUserToolsManager();
```

### <a name="return-value"></a>戻り値

グローバル`CUserToolsManager`オブジェクトへのポインター。ユーザー ツール管理がアプリケーションに対して有効になっていない場合は NULL。

### <a name="remarks"></a>解説

オブジェクトへのポインターを取得する前`CUserToolsManager`に[、CWinAppEx::EnableUserTools](#enableusertools)を呼び出してマネージャーを初期化する必要があります。

## <a name="cwinappexinitcontextmenumanager"></a><a name="initcontextmenumanager"></a>::イニトコンテキストメニューマネージャー

[オブジェクトを](../../mfc/reference/ccontextmenumanager-class.md)初期化します。

```
BOOL InitContextMenuManager();
```

### <a name="return-value"></a>戻り値

メソッドが CContextMenuManager オブジェクトを作成する場合は 0 以外の値を返します。オブジェクトが既`CContextMenuManager`に存在する場合は 0。

### <a name="remarks"></a>解説

呼び出すと[、](#getcontextmenumanager)そのメソッドの既定の実装が呼び出`InitContextMenuManager`されます。

アプリケーションに既にコンテキスト メニュー マネージャが存在し`InitContextMenuManager`、 を呼び出すと、アプリケーションで[ASSERT](diagnostic-services.md#assert)エラーが発生します。 したがって、オブジェクトを直接作成`InitContextMenuManager`する場合は`CContextMenuManager`呼び出さないでください。 カスタム`CContextMenuManager`を使用していない場合は、 を使用`GetContextMenuManager`してオブジェクトを`CContextMenuManager`作成する必要があります。

## <a name="cwinappexinitkeyboardmanager"></a><a name="initkeyboardmanager"></a>::イニトキーボードマネージャー

[オブジェクトを](../../mfc/reference/ckeyboardmanager-class.md)初期化します。

```
BOOL InitKeyboardManager();
```

### <a name="return-value"></a>戻り値

メソッドがオブジェクトを作成する場合`CKeyboardManager`は 0 以外の値を返します。オブジェクトが既`CKeyboardManager`に存在する場合は 0。

### <a name="remarks"></a>解説

[CWinAppEx::GetKeyboardManager](#getkeyboardmanager)を呼び出すと、そのメソッドの既定`InitKeyboardManager`の実装が呼び出されます。

アプリケーションに既にキーボード マネージャーが存在し、`InitKeyboardManager`を呼び出すと、アプリケーションで[ASSERT](diagnostic-services.md#assert)エラーが発生します。 したがって、オブジェクトを直接作成`InitKeyboardManager`する場合は`CKeyboardManager`呼び出さないでください。 カスタム`CKeyboardManager`を使用していない場合は、 を使用`GetKeyboardManager`してオブジェクトを`CKeyboardManager`作成する必要があります。

## <a name="cwinappexinitmousemanager"></a><a name="initmousemanager"></a>CWinAppEx::イニトマウスマネージャー

[オブジェクト](../../mfc/reference/cmousemanager-class.md)を初期化します。

```
BOOL InitMouseManager();
```

### <a name="return-value"></a>戻り値

メソッドがオブジェクトを作成する場合`CMouseManager`は 0 以外の値を返します。オブジェクトが既`CMouseManager`に存在する場合は 0。

### <a name="remarks"></a>解説

[CWinAppEx::GetMouseManager](#getmousemanager)を呼び出すと、そのメソッドの既定`InitMouseManager`の実装が呼び出されます。

アプリケーションに既にマウス マネージャーが存在し、`InitMouseManager`を呼び出すと、アプリケーションで[ASSERT](diagnostic-services.md#assert)エラーが発生します。 したがって、オブジェクトを直接`InitMouseManager`作成する場合は`CMouseManager`呼び出さないでください。 カスタム`CMouseManager`を使用していない場合は、 を使用`GetMouseManager`してオブジェクトを`CMouseManager`作成する必要があります。

## <a name="cwinappexinitshellmanager"></a><a name="initshellmanager"></a>::イニトシェルマネージャー

[オブジェクトを](../../mfc/reference/cshellmanager-class.md)初期化します。

```
BOOL InitShellManager();
```

### <a name="return-value"></a>戻り値

メソッドがオブジェクトを作成する場合`CShellManager`は 0 以外の値を返します。オブジェクトが既`CShellManager`に存在する場合は 0。

### <a name="remarks"></a>解説

[CWinAppEx::GetShellManager](#getshellmanager)を呼び出すと、そのメソッドの既定`InitShellManager`の実装が呼び出されます。

アプリケーションにシェル マネージャが既に存在し、`InitShellManager`を呼び出すと、アプリケーションは[ASSERT](diagnostic-services.md#assert)エラーを発生させます。 したがって、オブジェクトを直接`InitShellManager`作成する場合は`CShellManager`呼び出さないでください。 カスタム`CShellManager`を使用していない場合は、`GetShellManager`を使用して`CShellManager`オブジェクトを作成します。

## <a name="cwinappexinittooltipmanager"></a><a name="inittooltipmanager"></a>::イニトツールチップマネージャー

[オブジェクトを](../../mfc/reference/ctooltipmanager-class.md)初期化します。

```
BOOL InitTooltipManager();
```

### <a name="return-value"></a>戻り値

メソッドがオブジェクトを作成する場合`CTooltipManager`は 0 以外の値を返します。オブジェクトが既`CTooltipManager`に存在する場合は 0。

### <a name="remarks"></a>解説

呼び出すと[、](#gettooltipmanager)そのメソッドの既定の実装が呼び出`InitTooltipManager`されます。

アプリケーションに既にツールヒント マネージャーが存在し`InitTooltipManager`、 を呼び出すと、アプリケーションで[ASSERT](diagnostic-services.md#assert)エラーが発生します。 したがって、オブジェクトを直接作成`InitTooltipManager`する場合は`CTooltipManager`呼び出さないでください。 カスタム`CTooltipManager`を使用していない場合は、 を使用`GetTooltipManager`してオブジェクトを`CTooltipManager`作成する必要があります。

## <a name="cwinappexisresourcesmartupdate"></a><a name="isresourcesmartupdate"></a>を更新します。

```
BOOL IsResourceSmartUpdate() const;
```

### <a name="return-value"></a>戻り値

### <a name="remarks"></a>解説

## <a name="cwinappexisstateexists"></a><a name="isstateexists"></a>CWinAppEx::IsState は存在します。

指定したキーがレジストリ内にあるかどうかを示します。

```
BOOL IsStateExists(LPCTSTR lpszSectionName);
```

### <a name="parameters"></a>パラメーター

*名前*<br/>
[in]レジストリ キーのパスを含む文字列。

### <a name="return-value"></a>戻り値

キーがレジストリにある場合は 0 以外の値を返します。それ以外の場合は 0。

## <a name="cwinappexloadcustomstate"></a><a name="loadcustomstate"></a>を使用します。

フレームワークは、レジストリからアプリケーションの状態を読み込んだ後、このメソッドを呼び出します。

```
virtual void LoadCustomState();
```

### <a name="remarks"></a>解説

アプリケーションがレジストリから状態を読み込んだ後に処理を行う場合は、このメソッドをオーバーライドします。 既定では、このメソッドは何も実行しません。

レジストリからカスタム状態情報を読み込むには、まず[CWinAppEx::SaveCustomState](#savecustomstate)を使用して情報を保存する必要があります。

## <a name="cwinappexloadstate"></a><a name="loadstate"></a>を使用します。

Windows レジストリからアプリケーションの状態を読み取ります。

```
BOOL LoadState(
    CMDIFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL LoadState(
    CFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL LoadState(
    COleIPFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

virtual BOOL LoadState(
    LPCTSTR lpszSectionName = NULL,
    CFrameImpl* pFrameImpl = NULL);
```

### <a name="parameters"></a>パラメーター

*フレーム*<br/>
[in]フレーム ウィンドウ オブジェクトへのポインター。 このメソッドは、レジストリ内の状態情報をこのフレーム ウィンドウに適用します。

*名前*<br/>
[in]レジストリ キーの相対パスを含む文字列。

*スプフレームインプル*<br/>
[in]`CFrameImpl`オブジェクトへのポインター。 このメソッドは、レジストリ内の状態情報をこのフレーム ウィンドウに適用します。

### <a name="return-value"></a>戻り値

成功した場合は 0 以外。それ以外の場合は 0。

### <a name="remarks"></a>解説

このメソッドは、アプリケーションの状態とフレーム ウィンドウの状態情報を読み込みます。 フレーム ウィンドウに読み込まれた情報が、指定されたフレーム ウィンドウに適用されます。 フレーム ウィンドウを指定しない場合は、アプリケーションの状態情報のみが読み込まれます。 アプリケーション情報には[、CMouseManager クラス](../../mfc/reference/cmousemanager-class.md)[、CContextMenuManager クラス](../../mfc/reference/ccontextmenumanager-class.md)[、CKeyboard マネージャ クラス](../../mfc/reference/ckeyboardmanager-class.md)、および[CUserToolsManager クラス](../../mfc/reference/cusertoolsmanager-class.md)の状態が含まれます。

呼び出し`CFrameImpl::OnLoadFrame``LoadState`の既定の実装。

*パラメーター*は、レジストリ エントリの絶対パスではありません。 これは、アプリケーションの既定のレジストリ キーの末尾に追加される相対パスです。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase を](#setregistrybase)使用します。

## <a name="cwinappexloadwindowplacement"></a><a name="loadwindowplacement"></a>::ロードウィンドウ配置

メイン フレーム ウィンドウのサイズと場所をレジストリから読み込むときに、フレームワークによって呼び出されます。

```
virtual BOOL LoadWindowPlacement(
    CRect& rectNormalPosition,
    int& nFlags,
    int& nShowCmd);
```

### <a name="parameters"></a>パラメーター

*直流垂直位置*<br/>
[アウト]復元された位置にあるメイン フレーム ウィンドウの座標を含む四角形。

*Nflags*<br/>
[アウト]最小化されたウィンドウの位置を制御するフラグ、およびオペレーティング システムが最小化されたウィンドウと復元されたウィンドウの間で切り替える方法を制御するフラグ。

*を表示します。*<br/>
[アウト]ウィンドウの表示状態を指定する整数。 指定できる値の詳細については[、「CWnd::ShowWindow](../../mfc/reference/cwnd-class.md#showwindow)」を参照してください。

### <a name="return-value"></a>戻り値

成功した場合は 0 以外。それ以外の場合は 0。

### <a name="remarks"></a>解説

既定では、MFC は、アプリケーションの起動時に、メイン フレーム ウィンドウの前の位置と状態を自動的に読み込みます。 この情報がレジストリに格納される方法の詳細については[、「CWinAppEx::ストア ウィンドウ配置」を参照してください](#storewindowplacement)。

メイン フレーム ウィンドウに関する追加情報を読み込む場合は、このメソッドをオーバーライドします。

## <a name="cwinappexm_bforceimagereset"></a><a name="m_bforceimagereset"></a>CWinAppEx::m_bForceImageReset

フレームワークがツール バーを含むフレーム ウィンドウを再読み込みするときに、すべてのツール バー イメージをリセットするかどうかを指定します。

```
BOOL m_bForceImageReset;
```

### <a name="remarks"></a>解説

データ`m_bForceImageReset`メンバーは、保護された変数です。

## <a name="cwinappexonappcontexthelp"></a><a name="onappcontexthelp"></a>をクリックしてください。

フレームワークは、ユーザーが **[カスタマイズ]** ダイアログ ボックスのコンテキスト ヘルプを要求したときに、このメソッドを呼び出します。

```
virtual void OnAppContextHelp(
    CWnd* pWndControl,
    const DWORD dwHelpIDArray[]);
```

### <a name="parameters"></a>パラメーター

*コントロール*<br/>
[in]ユーザーがコンテキスト ヘルプを呼び出したウィンドウ オブジェクトへのポインター。

*を行います。*<br/>
[in]予約値。

### <a name="remarks"></a>解説

このメソッドは、現在、将来使用するために予約されています。 既定の実装では何も行われ、現在はフレームワークによって呼び出されません。

## <a name="cwinappexonclosingmainframe"></a><a name="onclosingmainframe"></a>CWinAppEx::オンクロージングメインフレーム

フレームワークは、フレーム ウィンドウがWM_CLOSEを処理しているときにこのメソッドを呼び出します。

```
virtual void OnClosingMainFrame(CFrameImpl* pFrameImpl);
```

### <a name="parameters"></a>パラメーター

*スプフレームインプル*<br/>
[in]`CFrameImpl`オブジェクトへのポインター。

### <a name="remarks"></a>解説

このメソッドの既定の実装では *、pFrameImpl*の状態を保存します。

## <a name="cwinappexonviewdoubleclick"></a><a name="onviewdoubleclick"></a>CWinAppEx::オンビューダブルクリック

ユーザーがそのビュー内の任意の場所をダブルクリックしたときに、ビューに関連付けられているユーザー定義コマンドを呼び出します。

```
virtual BOOL OnViewDoubleClick(
    CWnd* pWnd,
    int iViewId);
```

### <a name="parameters"></a>パラメーター

*Pwnd*<br/>
[in][CView クラス](../../mfc/reference/cview-class.md)から派生したオブジェクトへのポインター。

*をクリックします。*<br/>
[in]ビュー ID。

### <a name="return-value"></a>戻り値

フレームワークがコマンドを見つける場合は TRUE。それ以外の場合は FALSE。

### <a name="remarks"></a>解説

カスタム マウス動作をサポートするには、WM_LBUTTONDBLCLK メッセージを処理するときにこの関数を呼び出す必要があります。 このメソッドは *、iViewId*によって提供されるビュー ID に関連付けられたコマンドを実行します。 カスタム マウスの動作の詳細については、「[キーボードとマウスのカスタマイズ](../../mfc/keyboard-and-mouse-customization.md)」を参照してください。

## <a name="cwinappexonworkspaceidle"></a><a name="onworkspaceidle"></a>::オンワークスペースアイドル

```
virtual BOOL OnWorkspaceIdle(CWnd*);
```

### <a name="parameters"></a>パラメーター

[in]*クウンド・&#38;*<br/>

### <a name="return-value"></a>戻り値

### <a name="remarks"></a>解説

## <a name="cwinappexpreloadstate"></a><a name="preloadstate"></a>CWinAppEx::P読み込み状態

フレームワークは、レジストリからアプリケーションの状態を読み込む直前に、このメソッドを呼び出します。

```
virtual void PreLoadState();
```

### <a name="remarks"></a>解説

フレームワークがアプリケーション状態を読み込む直前に処理を実行する場合は、このメソッドをオーバーライドします。

## <a name="cwinappexpresavestate"></a><a name="presavestate"></a>CWinAppEx::Pセーブステート

フレームワークは、アプリケーションの状態を保存する直前にこのメソッドを呼び出します。

```
virtual void PreSaveState();
```

### <a name="remarks"></a>解説

フレームワークがアプリケーションの状態を保存する直前に処理を実行する場合は、このメソッドをオーバーライドします。

## <a name="cwinappexreloadwindowplacement"></a><a name="reloadwindowplacement"></a>::リロードウィンドウ配置

ウィンドウのサイズと場所をレジストリから再読み込みします。

```
virtual BOOL ReloadWindowPlacement(CFrameWnd* pFrame);
```

### <a name="parameters"></a>パラメーター

*フレーム*<br/>
[in]フレーム ウィンドウへのポインター。

### <a name="return-value"></a>戻り値

メソッドが成功した場合は 0 以外の値を返します。ロードに失敗した場合、またはロードするデータがない場合は 0。

### <a name="remarks"></a>解説

関数[CWinAppEx::StoreWindowPlacement](#storewindowplacement)を使用して、ウィンドウのサイズと場所をレジストリに書き込みます。

## <a name="cwinappexsavecustomstate"></a><a name="savecustomstate"></a>::カスタム状態を保存します。

フレームワークは、アプリケーションの状態をレジストリに保存した後に、このメソッドを呼び出します。

```
virtual void SaveCustomState();
```

### <a name="remarks"></a>解説

アプリケーションが状態をレジストリに保存した後に処理を行う場合は、このメソッドをオーバーライドします。 既定では、このメソッドは何も実行しません。

## <a name="cwinappexsavestate"></a><a name="savestate"></a>CWinAppEx::セーブステート

アプリケーションの状態を Windows レジストリに書き込みます。

```
virtual BOOL SaveState(
    LPCTSTR lpszSectionName = NULL,
    CFrameImpl* pFrameImpl = NULL);

BOOL SaveState(
    CMDIFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL SaveState(
    CFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL SaveState(
    COleIPFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);
```

### <a name="parameters"></a>パラメーター

*名前*<br/>
[in]レジストリ キーの相対パスを含む文字列。

*スプフレームインプル*<br/>
[in]`CFrameImpl`オブジェクトへのポインター。 このフレームは Windows レジストリに保存されます。

*フレーム*<br/>
[in]フレーム ウィンドウ オブジェクトへのポインター。 このフレームは Windows レジストリに保存されます。

### <a name="return-value"></a>戻り値

成功した場合は TRUE。それ以外の場合は FALSE。

### <a name="remarks"></a>解説

このメソッドは、アプリケーションの状態と、指定されたフレーム ウィンドウの状態情報を保存します。 フレーム ウィンドウを指定しない場合、メソッドはアプリケーションの状態のみを保存します。 アプリケーション情報には[、CMouseManager クラス](../../mfc/reference/cmousemanager-class.md)[、CContextMenuManager クラス](../../mfc/reference/ccontextmenumanager-class.md)[、CKeyboard マネージャ クラス](../../mfc/reference/ckeyboardmanager-class.md)、および[CUserToolsManager クラス](../../mfc/reference/cusertoolsmanager-class.md)の状態が含まれます。

*パラメーター*は、レジストリ エントリの絶対パスではありません。 これは、アプリケーションの既定のレジストリ キーの末尾に追加される相対パスです。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase を](#setregistrybase)使用します。

## <a name="cwinappexsetregistrybase"></a><a name="setregistrybase"></a>::セットレジストリベース

アプリケーションの既定のレジストリ パスを設定します。

```
LPCTSTR SetRegistryBase(LPCTSTR lpszSectionName = NULL);
```

### <a name="parameters"></a>パラメーター

*名前*<br/>
[in]レジストリ キーのパスを含む文字列。

### <a name="return-value"></a>戻り値

既定のレジストリの場所のパスを含む文字列。

### <a name="remarks"></a>解説

レジストリにアクセスする[CWinAppEx クラス](../../mfc/reference/cwinappex-class.md)のすべてのメソッドは、既定の場所で開始します。 このメソッドは、既定のレジストリの場所を変更するために使います。 [既定のレジストリの場所を取得するには、CWinAppEx::GetRegistryBase](#getregistrybase)を使用します。

## <a name="cwinappexshowpopupmenu"></a><a name="showpopupmenu"></a>::ポップアップメニュー

ポップアップ メニューを表示します。

```
virtual BOOL ShowPopupMenu(
    UINT uiMenuResId,
    const CPoint& point,
    CWnd* pWnd);
```

### <a name="parameters"></a>パラメーター

*をクリックします。*<br/>
[in]メニュー リソース ID。

*ポイント*<br/>
[in]メニューの位置を画面座標で指定する[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)です。

*Pwnd*<br/>
[in]ポップアップ メニューを所有するウィンドウへのポインター。

### <a name="return-value"></a>戻り値

ポップアップ メニューが正常に表示された場合は 0 以外の値を返します。それ以外の場合は 0。

### <a name="remarks"></a>解説

このメソッドは *、uiMenuResId*に関連付けられているメニューを表示します。

ポップアップ メニューをサポートするには[、CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md)オブジェクトが必要です。 `CContextMenuManager`オブジェクトを初期化していない場合は、`ShowPopupMenu`失敗します。

## <a name="cwinappexstorewindowplacement"></a><a name="storewindowplacement"></a>::ストアウィンドウ配置

メイン フレーム ウィンドウのサイズと場所をレジストリに書き込むために、フレームワークによって呼び出されます。

```
virtual BOOL StoreWindowPlacement(
    const CRect& rectNormalPosition,
    int nFlags,
    int nShowCmd);
```

### <a name="parameters"></a>パラメーター

*Nflags*<br/>
[in]最小化されたウィンドウの位置を制御するフラグ、およびオペレーティング システムが最小化されたウィンドウと復元されたウィンドウの間で切り替える方法を制御するフラグ。

*を表示します。*<br/>
[in]ウィンドウの表示状態を指定する整数。 指定できる値の詳細については[、「CWnd::ShowWindow](../../mfc/reference/cwnd-class.md#showwindow)」を参照してください。

*直流垂直位置*<br/>
[in]復元された状態のメイン フレーム ウィンドウの座標を含む四角形。

### <a name="return-value"></a>戻り値

成功した場合は 0 以外。それ以外の場合は 0。

### <a name="remarks"></a>解説

既定では、MFC は、アプリケーションが終了する前に、メイン フレーム ウィンドウの位置と状態を自動的に保存します。 この情報は、アプリケーションの既定のレジストリの場所にある WindowPlacement キーの下の Windows レジストリに格納されます。 アプリケーションの既定のレジストリの場所の詳細については[、「CWinAppEx::GetRegistryBase](#getregistrybase)」を参照してください。

メイン フレーム ウィンドウに関する追加情報を格納する場合は、このメソッドをオーバーライドします。

## <a name="cwinappexwritebinary"></a><a name="writebinary"></a>::書き込みバイナリ

バイナリ データをレジストリに書き込みます。

```
BOOL WriteBinary(
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>パラメーター

*をクリックします。*<br/>
[in]レジストリ キーの名前を含む文字列。

*Pdata*<br/>
[in]格納するデータ。

*Nbytes*<br/>
[in]*pData*のサイズ (バイト単位)。

### <a name="return-value"></a>戻り値

このメソッドが成功した場合は TRUE。それ以外の場合は FALSE。

### <a name="remarks"></a>解説

*lpszEntry*パラメーターは、アプリケーションの既定のレジストリ キーの下にあるレジストリ エントリの名前です。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase を](#setregistrybase)使用します。

*lpszEntry*で指定されたキーが存在しない場合、このメソッドはそれを作成します。

## <a name="cwinappexwriteint"></a><a name="writeint"></a>CWinAppEx::書き込みイント

数値データをレジストリに書き込みます。

```
BOOL WriteInt(
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>パラメーター

*をクリックします。*<br/>
[in]レジストリ キーの名前を含む文字列。

*n値*<br/>
[in]格納するデータ。

### <a name="return-value"></a>戻り値

このメソッドが成功した場合は TRUE。それ以外の場合は FALSE。

### <a name="remarks"></a>解説

*lpszEntry*パラメーターは、アプリケーションの既定のレジストリ キーの下にあるレジストリ エントリの名前です。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase を](#setregistrybase)使用します。

*lpszEntry*で指定されたキーが存在しない場合、このメソッドはそれを作成します。

## <a name="cwinappexwriteobject"></a><a name="writeobject"></a>オブジェクトを書き込む

[CObject クラス](../../mfc/reference/cobject-class.md)から派生したデータをレジストリに書き込みます。

```
BOOL WriteObject(
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>パラメーター

*をクリックします。*<br/>
[in]設定する値を含む文字列。

*obj*<br/>
[in]メソッドが格納`CObject`するデータへの参照。

### <a name="return-value"></a>戻り値

このメソッドが成功した場合は TRUE。それ以外の場合は FALSE。

### <a name="remarks"></a>解説

このメソッドは、*既定*のレジストリ キーの下の指定された値に obj データを書き込みます。 現在のレジストリ キーを決定するには[、CWinAppEx::GetRegistryBase](#getregistrybase)を使用します。

## <a name="cwinappexwritesectionbinary"></a><a name="writesectionbinary"></a>::書き込みセクションバイナリ

バイナリ データをレジストリの値に書き込みます。

```
BOOL WriteSectionBinary(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>パラメーター

*セクション*<br/>
[in]レジストリ キーの名前を含む文字列

*をクリックします。*<br/>
[in]設定する値を含む文字列。

*Pdata*<br/>
[in]レジストリに書き込むデータ。

*Nbytes*<br/>
[in]*pData*のサイズ (バイト単位)。

### <a name="return-value"></a>戻り値

このメソッドが成功した場合は TRUE。それ以外の場合は FALSE。

### <a name="remarks"></a>解説

*パラメーター*は、レジストリ エントリの絶対パスではありません。 これは、アプリケーションの既定のレジストリ キーの末尾に追加される相対パスです。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase を](#setregistrybase)使用します。

*lpszEntry*で指定されたキーが存在しない場合、このメソッドはそれを作成します。

## <a name="cwinappexwritesectionint"></a><a name="writesectionint"></a>CWinAppEx::書き込みセクションイント

数値データをレジストリに書き込みます。

```
BOOL WriteSectionInt(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>パラメーター

*セクション*<br/>
[in]レジストリ キーの相対パスを含む文字列。

*をクリックします。*<br/>
[in]設定する値を含む文字列。

*n値*<br/>
[in]レジストリに書き込むデータ。

### <a name="return-value"></a>戻り値

このメソッドが成功した場合は TRUE。それ以外の場合は FALSE。

### <a name="remarks"></a>解説

*パラメーター*はレジストリ エントリの絶対パスではありません。 これは、アプリケーションの既定のレジストリ キーに追加される相対パスです。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase を](#setregistrybase)使用します。

*lpszEntry*で指定されたキーが存在しない場合、このメソッドはそれを作成します。

## <a name="cwinappexwritesectionobject"></a><a name="writesectionobject"></a>オブジェクトを書き込みます。

[CObject クラス](../../mfc/reference/cobject-class.md)から派生したデータを特定のレジストリ値に書き込みます。

```
BOOL WriteSectionObject(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>パラメーター

*セクション*<br/>
[in]レジストリ キーの名前を含む文字列。

*をクリックします。*<br/>
[in]設定する値の名前を含む文字列。

*obj*<br/>
[in]格納するデータ。

### <a name="return-value"></a>戻り値

このメソッドが成功した場合は TRUE。それ以外の場合は FALSE。

### <a name="remarks"></a>解説

*パラメーター*はレジストリ エントリの絶対パスではありません。 これは、アプリケーションの既定のレジストリ キーの末尾に追加される相対パスです。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)を使用します。

指定された値が*lpszSubSection*で指定されたレジストリ キーの*lpszSubSection*下に存在しない場合、このメソッドはその値を作成します。

## <a name="cwinappexwritesectionstring"></a><a name="writesectionstring"></a>::セクション文字列を書き込みます

文字列データをレジストリの値に書き込みます。

```
BOOL WriteSectionString(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>パラメーター

*セクション*<br/>
[in]レジストリ キーの名前を含む文字列。

*をクリックします。*<br/>
[in]設定する値を含む文字列。

*値*<br/>
[in]レジストリに書き込む文字列データ。

### <a name="return-value"></a>戻り値

このメソッドが成功した場合は TRUE。それ以外の場合は FALSE。

### <a name="remarks"></a>解説

*パラメーター*はレジストリ エントリの絶対パスではありません。 これは、アプリケーションの既定のレジストリ キーの末尾に追加される相対パスです。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)を使用します。

*lpszEntry*で指定された値が*lpszSubSection*の下に存在しない場合、このメソッドはそれを作成します。

## <a name="cwinappexwritestring"></a><a name="writestring"></a>::書き込み文字列

文字列データをレジストリに書き込みます。

```
BOOL WriteString(
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>パラメーター

*をクリックします。*<br/>
[in]レジストリ キーの名前を含む文字列。

*値*<br/>
[in]格納するデータ。

### <a name="return-value"></a>戻り値

このメソッドが成功した場合は TRUE。それ以外の場合は FALSE。

### <a name="remarks"></a>解説

*lpszEntry*パラメーターは、アプリケーションの既定のレジストリ キーの下にあるレジストリ エントリの名前です。 既定のレジストリ キーを取得または設定するには、それぞれメソッド[CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase を](#setregistrybase)使用します。

*lspzEntry*で指定されたキーが存在しない場合、このメソッドはそれを作成します。

## <a name="see-also"></a>関連項目

[階層グラフ](../../mfc/hierarchy-chart.md)<br/>
[クラス](../../mfc/reference/mfc-classes.md)<br/>
[CWinApp クラス](../../mfc/reference/cwinapp-class.md)<br/>
[クラス](../../mfc/reference/cmousemanager-class.md)<br/>
[CContextMenuManager クラス](../../mfc/reference/ccontextmenumanager-class.md)<br/>
[クラス](../../mfc/reference/ckeyboardmanager-class.md)<br/>
[クラス](../../mfc/reference/cusertoolsmanager-class.md)
