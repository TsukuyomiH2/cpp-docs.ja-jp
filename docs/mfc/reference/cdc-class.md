---
title: CDCクラス
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: 830c6d068a5074d0918107ca601c51d198a8a912
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81375710"
---
# <a name="cdc-class"></a>CDCクラス

デバイス コンテキスト オブジェクトのクラスを定義します。

## <a name="syntax"></a>構文

```
class CDC : public CObject
```

## <a name="members"></a>メンバー

### <a name="public-constructors"></a>パブリック コンストラクター

|名前|説明|
|----------|-----------------|
|[CDC::CDC](#cdc)|`CDC` オブジェクトを構築します。|

### <a name="public-methods"></a>パブリック メソッド

|名前|説明|
|----------|-----------------|
|[CDC::アボートドック](#abortdoc)|現在の印刷ジョブを終了し、メンバー関数の最後の呼び出し以降にアプリケーションがデバイスに書`StartDoc`き込んだものをすべて削除します。|
|[CDC::アボートパス](#abortpath)|デバイス コンテキスト内のパスを閉じて破棄します。|
|[CDC::ファイルのコメントを追加します。](#addmetafilecomment)|バッファーから指定した拡張形式メタファイルにコメントをコピーします。|
|[CDC::アルファブレンド](#alphablend)|透明または半透明のピクセルを持つビットマップを表示します。|
|[CDC::アングルアーク](#anglearc)|線分と円弧を描画し、現在の位置を円弧の終点に移動します。|
|[CDC::アーク](#arc)|楕円弧を描画します。|
|[CDC::アークト](#arcto)|楕円弧を描画します。この関数は、現在`Arc`の位置が更新される点を除いて、 に似ています。|
|[CDC::アタッチ](#attach)|Windows デバイス コンテキストをこの`CDC`オブジェクトにアタッチします。|
|[CDC::ビギンパス](#beginpath)|デバイス コンテキストでパス ブラケットを開きます。|
|[CDC::BitBlt](#bitblt)|指定したデバイス コンテキストからビットマップをコピーします。|
|[CDC::コード](#chord)|弦(楕円と線分の交差部分に囲まれた閉じた図形)を描画します。|
|[CDC::クローズフィギュア](#closefigure)|パス内の開いている図形を閉じます。|
|[CDC:作成互換性のあるDC](#createcompatibledc)|別のデバイス コンテキストと互換性のあるメモリ デバイス コンテキストを作成します。 メモリ内のイメージを準備するために使用できます。|
|[CDC::DC の作成](#createdc)|特定のデバイスのデバイス コンテキストを作成します。|
|[CDC::創造](#createic)|特定のデバイスの情報コンテキストを作成します。 これにより、デバイス コンテキストを作成せずにデバイスに関する情報を取得する高速な方法が提供されます。|
|[CDC::DエレテDC](#deletedc)|このオブジェクトに関連付けられている Windows`CDC`デバイス コンテキストを削除します。|
|[CDC::D一時マップ](#deletetempmap)|によって作成された`CWinApp`一時`CDC`オブジェクトを削除するために、アイドル時ハンドラによって`FromHandle`呼び出されます。 また、デバイス コンテキストをデタッチします。|
|[CDC::Dエタッハ](#detach)|Windows デバイス コンテキストをこの`CDC`オブジェクトからデタッチします。|
|[CDC::Dプトヒメトリック](#dptohimetric)|デバイス単位を HIMETRIC 単位に変換します。|
|[CDC::Dプトープ](#dptolp)|デバイス単位を論理単位に変換します。|
|[CDC::Dロー3dRect](#draw3drect)|3 次元の四角形を描画します。|
|[CDC::Dロードラグレック](#drawdragrect)|ドラッグ時に四角形を消去し、再描画します。|
|[CDC::Dローエッジ](#drawedge)|四角形のエッジを描画します。|
|[CDC::Dローエスケープ](#drawescape)|グラフィックス デバイス インターフェイス (GDI) を通じて直接使用できないビデオ ディスプレイの描画機能にアクセスします。|
|[CDC::Dローフォーカスレック](#drawfocusrect)|フォーカスを示すために使用するスタイルの四角形を描画します。|
|[CDC::Dローフレームコントロール](#drawframecontrol)|フレーム コントロールを描画します。|
|[CDC::Dローアイコン](#drawicon)|アイコンを描画します。|
|[CDC::Dローステート](#drawstate)|イメージを表示し、状態を示す視覚効果を適用します。|
|[nFormat](#drawtext)|指定された四角形に書式設定されたテキストを描画します。|
|[CDC::Dローテキスト](#drawtextex)|追加の書式を使用して、指定した四角形に書式設定されたテキストを描画します。|
|[CDC::楕円](#ellipse)|楕円を描きます。|
|[CDC::エンドドック](#enddoc)|メンバー関数によって開始された印刷ジョブ`StartDoc`を終了します。|
|[CDC::エンドページ](#endpage)|ページが終了していることをデバイス ドライバに通知します。|
|[CDC::エンドパス](#endpath)|パス ブラケットを閉じ、ブラケットで定義されたパスをデバイス コンテキストに選択します。|
|[CDC::列挙オブジェクト](#enumobjects)|デバイス コンテキストで使用できるペンとブラシを列挙します。|
|[CDC::エスケープ](#escape)|GDI を使用して、特定のデバイスから直接利用できない機能にアプリケーションがアクセスできるようにします。 また、Windowsのエスケープ関数へのアクセスを許可します。 アプリケーションによって行われたエスケープ呼び出しは、変換され、デバイス ドライバーに送信されます。|
|[CDC::クリップレックを除外](#excludecliprect)|既存のクリッピング領域から指定された四角形を引いた新しいクリッピング領域を作成します。|
|[CDC::除外更新プログラム](#excludeupdatergn)|ウィンドウ内の更新された領域をクリッピング領域から除外することにより、ウィンドウの無効な領域内で描画を行わないようにします。|
|[CDC::スプラッドフィル](#extfloodfill)|現在のブラシで領域を塗りつぶします。 メンバー関数の柔軟性を[高めるには、CDC::FloodFill](#floodfill)メンバー関数よりも多くの柔軟性があります。|
|[CDC::テキストアウト](#exttextout)|現在選択されているフォントを使用して、四角形の領域内に文字列を書き込みます。|
|[CDC::フィルパス](#fillpath)|現在のパスで開いている図形をすべて閉じ、現在のブラシモードとポリゴン塗りつぶしモードを使用してパスの内部を塗りつぶします。|
|[CDC::フィルレック](#fillrect)|特定のブラシを使用して、指定された四角形を塗りつぶします。|
|[CDC::フィルルグン](#fillrgn)|指定したブラシで特定の領域を塗りつぶします。|
|[CDC::フィルソリッドレック](#fillsolidrect)|四角形を単色で塗りつぶします。|
|[CDC::フラットパス](#flattenpath)|選択したパス内のカーブを現在のデバイス コンテキストに変換し、各曲線を一連の線に変換します。|
|[CDC::洪水フィル](#floodfill)|現在のブラシで領域を塗りつぶします。|
|[CDC::フレームレック](#framerect)|四角形の周囲に境界線を描画します。|
|[CDC::フレームルグン](#framergn)|ブラシを使用して、特定の領域の周囲に境界線を描画します。|
|[CDC::ハンドルから](#fromhandle)|デバイス コンテキストへのハンドル`CDC`が与えられた場合、オブジェクトへのポインターを返します。 `CDC` オブジェクトがハンドルに関連付けられていない場合は、一時的な `CDC` オブジェクトが生成され、関連付けられます。|
|[CDC::ゲットアークディレクション](#getarcdirection)|デバイス コンテキストの現在の円弧方向を返します。|
|[CDC::アスペクト比フィルター](#getaspectratiofilter)|現在の縦横比フィルターの設定を取得します。|
|[CDC::ゲットブレクカラー](#getbkcolor)|現在の背景色を取得します。|
|[CDC::ゲットBkモード](#getbkmode)|バックグラウンド モードを取得します。|
|[CDC::ゲットバウンドレクト](#getboundsrect)|指定されたデバイス コンテキストの現在の累積外接する四角形を返します。|
|[CDC::ゲットブラシオルグ](#getbrushorg)|現在のブラシの原点を取得します。|
|[CDC::取得文字ABC幅](#getcharabcwidths)|指定された範囲の連続する文字の幅を現在のフォントから取得します。|
|[CDC::取得チャルアブサシ](#getcharabcwidthsi)|現在の TrueType フォントから、指定された範囲の連続するグリフ インデックスの幅を論理単位で取得します。|
|[CDC::文字配置](#getcharacterplacement)|文字列に関するさまざまな情報を取得します。|
|[CDC::取得文字幅](#getcharwidth)|現在のフォントから、指定された範囲内の連続する文字の小数幅を取得します。|
|[CDC::ゲットチャル幅I](#getcharwidthi)|現在のフォントから指定された範囲内の連続するグリフ インデックスの幅を論理座標で取得します。|
|[CDC::ゲットクリップボックス](#getclipbox)|現在のクリップ境界の周りの最も狭い境界の四角形の寸法を取得します。|
|[CDC::色調整](#getcoloradjustment)|デバイス コンテキストの色調整値を取得します。|
|[CDC::現在のビットマップを取得します。](#getcurrentbitmap)|現在選択`CBitmap`されているオブジェクトへのポインターを返します。|
|[CDC::ゲットカレントブラシ](#getcurrentbrush)|現在選択`CBrush`されているオブジェクトへのポインターを返します。|
|[CDC::現在のフォントを取得します。](#getcurrentfont)|現在選択`CFont`されているオブジェクトへのポインターを返します。|
|[CDC::現在のパレットを取得します。](#getcurrentpalette)|現在選択`CPalette`されているオブジェクトへのポインターを返します。|
|[CDC::ゲットカレントペン](#getcurrentpen)|現在選択`CPen`されているオブジェクトへのポインターを返します。|
|[CDC::現在の位置を取得します。](#getcurrentposition)|ペンの現在位置を取得します (論理座標)。|
|[CDC::ゲットDCブラシカラー](#getdcbrushcolor)|現在のブラシの色を取得します。|
|[CDC::ゲットDCペンカラー](#getdcpencolor)|現在のペンの色を取得します。|
|[CDC::デバイスキャップ](#getdevicecaps)|特定のディスプレイ デバイスの機能に関する、指定した種類のデバイス固有の情報を取得します。|
|[を取得します。](#getfontdata)|スケーラブルフォント ファイルからフォント メトリック情報を取得します。 取得する情報は、フォント ファイルのオフセットと返す情報の長さを指定することによって識別されます。|
|[を取得します。](#getfontlanguageinfo)|指定した表示コンテキストで現在選択されているフォントに関する情報を返します。|
|[CDC::グリフアウトライン](#getglyphoutline)|現在のフォントのアウトライン文字のアウトライン 曲線またはビットマップを取得します。|
|[CDC::グラフィックモードを取得します。](#getgraphicsmode)|指定したデバイス コンテキストの現在のグラフィックス モードを取得します。|
|[CDC::ゲットハーフトーンブラシ](#gethalftonebrush)|ハーフトーン ブラシを取得します。|
|[CDC::ゲトケニングペア](#getkerningpairs)|指定したデバイス コンテキストで現在選択されているフォントの文字カーニング ペアを取得します。|
|[CDC::ゲットレイアウト](#getlayout)|デバイス コンテキスト (DC) のレイアウトを取得します。 レイアウトは、左から右(デフォルト)または右から左(ミラーリング)のいずれかにできます。|
|[CDC::ゲットマップモード](#getmapmode)|現在のマッピング モードを取得します。|
|[CDC::ゲットマイターリミット](#getmiterlimit)|デバイス コンテキストのマイター制限を返します。|
|[CDC::最も近い色を取得します。](#getnearestcolor)|指定されたデバイスが表すことができる、指定された論理色に最も近い論理色を取得します。|
|[テキスト メトリックスを取得します。](#getoutlinetextmetrics)|TrueType フォントのフォント メトリック情報を取得します。|
|[CDC::出力文字幅](#getoutputcharwidth)|出力デバイス コンテキストを使用して、現在のフォントから連続した文字グループ内の個々の文字の幅を取得します。|
|[テキスト範囲を取得します。](#getoutputtabbedtextextent)|出力デバイス コンテキストでの文字列の幅と高さを計算します。|
|[テキスト範囲を取得します。](#getoutputtextextent)|現在のフォントを使用して、出力デバイス コンテキストのテキスト行の幅と高さを計算し、サイズを決定します。|
|[テキスト メトリックスを取得します。](#getoutputtextmetrics)|出力デバイス コンテキストから現在のフォントのメトリックを取得します。|
|[CDC::ゲットパス](#getpath)|デバイス コンテキスト内で選択されたパスにある、線の端点と曲線の制御点を定義する座標を取得します。|
|[CDC::ゲットピクセル](#getpixel)|指定したポイントにあるピクセルの RGB カラー値を取得します。|
|[CDC::ゲットポリフィルモード](#getpolyfillmode)|現在のポリゴン塗りつぶしモードを取得します。|
|[CDC::ゲットロップ2](#getrop2)|現在の描画モードを取得します。|
|[CDC::ゲットセーフハドック](#getsafehdc)|出力デバイス コンテキストの[CDC::m_hDC](#m_hdc)を返します。|
|[CDC::ゲットストレッチブルトモード](#getstretchbltmode)|現在のビットマップ伸縮モードを取得します。|
|[テキスト範囲を取得します。](#gettabbedtextextent)|属性のデバイス コンテキストでの文字列の幅と高さを計算します。|
|[CDC::テキスト整列](#gettextalign)|テキスト配置フラグを取得します。|
|[テキスト文字の追加](#gettextcharacterextra)|文字間の間隔の量の現在の設定を取得します。|
|[テキストの色を取得します。](#gettextcolor)|現在のテキストの色を取得します。|
|[CDC::テキスト範囲を取得します。](#gettextextent)|現在のフォントを使用して、属性デバイス コンテキストのテキスト行の幅と高さを計算して、サイズを決定します。|
|[CDC::テキストエクステントエクスポイント](#gettextextentexpointi)|指定した文字列内の指定したスペース内に収まる文字数を取得し、配列にそれらの文字の各文字のテキスト範囲を設定します。|
|[CDC::テキストエクステントポイント](#gettextextentpointi)|指定したグリフ インデックスの配列の幅と高さを取得します。|
|[CDC::テキストフェイス](#gettextface)|現在のフォントの書体名を、null で終わる文字列としてバッファーにコピーします。|
|[CDC::テキストメトリックス](#gettextmetrics)|属性デバイス コンテキストから現在のフォントのメトリックを取得します。|
|[CDC::ゲットビューポートエクスタブ](#getviewportext)|ビューポートの x 範囲と y 範囲を取得します。|
|[CDC::ゲットビューポートオルグ](#getviewportorg)|ビューポートの原点の x 座標と y 座標を取得します。|
|[CDC::ウィンドウを取得します。](#getwindow)|表示デバイス コンテキストに関連付けられているウィンドウを返します。|
|[CDC::ゲットウィンドウエクスク](#getwindowext)|関連付けられたウィンドウの x および y の範囲を取得します。|
|[CDC::ゲットウィンドウオルグ](#getwindoworg)|関連付けられたウィンドウの原点の x 座標と y 座標を取得します。|
|[CDC::ゲットワールドトランスフォーム](#getworldtransform)|ページ空間変換への現在のワールド空間を取得します。|
|[CDC::グラデーション塗りつぶし](#gradientfill)|四角形と三角形の構造体を、グラデーションカラーで塗りつぶします。|
|[CDC::グレイストリング](#graystring)|指定された位置に淡色 (灰色) のテキストを描画します。|
|[CDC::ヒメトリクトデ](#himetrictodp)|HIMETRIC 単位をデバイス単位に変換します。|
|[CDC::ヒメトリクトルプ](#himetrictolp)|HIMETRIC 単位を論理単位に変換します。|
|[CDC::交差クリップレック](#intersectcliprect)|現在の領域と四角形の交差部分を形成して、新しいクリッピング領域を作成します。|
|[CDC::反転レック](#invertrect)|四角形の内容を反転します。|
|[CDC:インヴァートルグン](#invertrgn)|領域内の色を反転します。|
|[CDC::イズプリント](#isprinting)|デバイス コンテキストが印刷に使用されているかどうかを判断します。|
|[CDC::ライント](#lineto)|現在の位置からポイントまで線を描画しますが、その点は含まれません。|
|[CDC::LPtoDP](#lptodp)|論理単位を装置単位に変換します。|
|[CDC::LPtohiMETRIC](#lptohimetric)|論理単位を HIMETRIC 単位に変換します。|
|[CDC::マスクブレット](#maskblt)|指定されたマスクとラスター操作を使用して、変換元とコピー先のビットマップのカラー データを結合します。|
|[CDC::変換](#modifyworldtransform)|指定したモードを使用してデバイス コンテキストのワールド変換を変更します。|
|[CDC::移動先](#moveto)|現在の位置を移動します。|
|[CDC::オフセットクリップルグン](#offsetcliprgn)|指定されたデバイスのクリッピング領域を移動します。|
|[CDC:オフセットビューポートオルガ](#offsetviewportorg)|現在のビューポート原点の座標に対するビューポートの原点を修正します。|
|[CDC::オフセットウィンドウオルグ](#offsetwindoworg)|現在のウィンドウ原点の座標を基準にして、ウィンドウの原点を変更します。|
|[CDC::PaintRgn](#paintrgn)|選択したブラシで領域を塗りつぶします。|
|[CDC::Pアットブルト](#patblt)|ビット パターンを作成します。|
|[CDC::P](#pie)|パイの形をしたくさびを描きます。|
|[CDC::Pレイメタファイル](#playmetafile)|指定されたデバイス上の指定したメタファイルの内容を再生します。 拡張バージョンのの`PlayMetaFile`場合、指定された拡張形式のメタファイルに保存されている画像が表示されます。 メタファイルは、何度でも再生できます。|
|[CDC::PlgBlt](#plgblt)|ソース デバイス コンテキスト内の指定された四角形から、指定されたデバイス コンテキスト内の指定された平行四辺形への色データのビット ブロック転送を実行します。|
|[CDC::Pオリーベジエ](#polybezier)|1 つまたは複数のベジエ スプラインを描画します。 現在の位置は使用も更新もされません。|
|[CDC::Pオリーベジエト](#polybezierto)|1 つまたは複数のベジエ スプラインを描画し、現在の位置を最後のベジエ スプラインの終了点に移動します。|
|[CDC::Pオリードロー](#polydraw)|線分セグメントとベジエ スプラインのセットを描画します。 この関数は、現在の位置を更新します。|
|[CDC::Pり](#polygon)|線で接続された 2 つ以上のポイント (頂点) からなるポリゴンを描画します。|
|[CDC::Pオリン](#polyline)|指定した点を結ぶ線分のセットを描画します。|
|[CDC::Pオリリント](#polylineto)|1 つまたは複数の直線を描画し、現在の位置を最後の線の終点に移動します。|
|[CDC::Pオリーポリゴン](#polypolygon)|現在のポリゴン塗りつぶしモードを使用して塗りつぶされる 2 つ以上のポリゴンを作成します。 ポリゴンが不整合になっているか、重なる場合があります。|
|[CDC::Pりポリライン](#polypolyline)|複数の一連の接続線分を描画します。 現在の位置は、この関数によって使用も更新もされません。|
|[CDC::P不可](#ptvisible)|指定したポイントがクリップ領域内にあるかどうかを指定します。|
|[CDC::ア実現パレット](#realizepalette)|現在の論理パレットのパレット エントリをシステム パレットにマップします。|
|[CDC::長方形](#rectangle)|現在のペンを使用して四角形を描画し、現在のブラシを使用して塗りつぶします。|
|[CDC::整流可能](#rectvisible)|指定された四角形の一部がクリッピング領域内にあるかどうかを判断します。|
|[CDC::リリースアットリブDC](#releaseattribdc)|属性`m_hAttribDC`デバイス コンテキスト をリリースします。|
|[CDC::リリースアウトプットDC](#releaseoutputdc)|出力`m_hDC`デバイス コンテキスト をリリースします。|
|[CDC::リセットDC](#resetdc)|デバイス`m_hAttribDC`コンテキストを更新します。|
|[CDC::復元DC](#restoredc)|で保存された以前の状態にデバイス コンテキストを`SaveDC`復元します。|
|[CDC::ラウンドレック](#roundrect)|現在のペンを使用して角を丸くして四角形を描画し、現在のブラシを使用して塗りつぶします。|
|[CDC::セーブDC](#savedc)|デバイス コンテキストの現在の状態を保存します。|
|[CDC:スケールビューポートエクスタブ](#scaleviewportext)|現在の値に対するビューポート範囲を変更します。|
|[CDC::スケールウィンドウエクスク](#scalewindowext)|現在の値に対するウィンドウ範囲を変更します。|
|[CDC::スクロールDC](#scrolldc)|ビットの四角形を水平方向および垂直方向にスクロールします。|
|[CDC::クリップパスを選択します。](#selectclippath)|現在のパスをデバイス コンテキストのクリッピング領域として選択し、指定したモードを使用して、新しい領域と既存のクリップ領域を組み合わせます。|
|[CDC::選択クリップルグン](#selectcliprgn)|指定したモードを使用して、指定した領域と現在のクリッピング領域を結合します。|
|[CDC::SelectObject](#selectobject)|ペンなどの GDI 描画オブジェクトを選択します。|
|[CDC::パレットの選択](#selectpalette)|論理パレットを選択します。|
|[CDC::SelectStockObject](#selectstockobject)|Windows で提供されている定義済みのストック ペン、ブラシ、またはフォントのいずれかを選択します。|
|[CDC::セットアボート・プロセス](#setabortproc)|印刷ジョブを中止する必要がある場合に Windows が呼び出すプログラマ提供のコールバック関数を設定します。|
|[CDC::セットアークディレクション](#setarcdirection)|円弧関数および四角形関数で使用する描画方向を設定します。|
|[CDC::セットリブDC](#setattribdc)|属性`m_hAttribDC`デバイス コンテキスト を設定します。|
|[CDC::セットBkカラー](#setbkcolor)|現在の背景色を設定します。|
|[CDC::セットBkモード](#setbkmode)|バックグラウンド モードを設定します。|
|[CDC::セットバウンドレクト](#setboundsrect)|指定したデバイス コンテキストの外接四角形情報の蓄積を制御します。|
|[CDC::セットブラシオルグ](#setbrushorg)|デバイス コンテキストで選択された次のブラシの原点を指定します。|
|[CDC::カラー調整](#setcoloradjustment)|指定した値を使用して、デバイス コンテキストの色調整値を設定します。|
|[CDC::セットDCブラシカラー](#setdcbrushcolor)|現在のブラシの色を設定します。|
|[CDC::セットDCペンカラー](#setdcpencolor)|現在のペンの色を設定します。|
|[CDC::セットグラフィックスモード](#setgraphicsmode)|指定したデバイス コンテキストの現在のグラフィックス モードを設定します。|
|[CDC::セットレイアウト](#setlayout)|デバイス コンテキスト (DC) のレイアウトを変更します。|
|[CDC::セットマップモード](#setmapmode)|現在のマッピング モードを設定します。|
|[CDC::セットマッパーフラグ](#setmapperflags)|論理フォントを物理フォントにマップするときにフォント マッパーが使用するアルゴリズムを変更します。|
|[CDC::セットマイターリミット](#setmiterlimit)|デバイス コンテキストのマイター結合の長さの制限を設定します。|
|[CDC::出力DC](#setoutputdc)|出力`m_hDC`デバイス コンテキスト を設定します。|
|[CDC::セットピクセル](#setpixel)|指定したポイントのピクセルを、指定した色の最も近似値に設定します。|
|[CDC::セットピクセルV](#setpixelv)|指定した座標のピクセルを、指定した色の最も近似値に設定します。 `SetPixelV`実際に描画`SetPixel`された点の色値を返す必要がないため、より高速です。|
|[CDC::セットポリフィルモード](#setpolyfillmode)|ポリゴン塗りつぶしモードを設定します。|
|[CDC::セットロップ2](#setrop2)|現在の描画モードを設定します。|
|[CDC::セットストレッチブルトモード](#setstretchbltmode)|ビットマップストレッチ モードを設定します。|
|[CDC::テキスト整列](#settextalign)|テキスト配置フラグを設定します。|
|[テキスト文字エクストラ](#settextcharacterextra)|文字間の間隔を設定します。|
|[テキストの色を設定します。](#settextcolor)|テキストの色を設定します。|
|[CDC::テキストの正当化](#settextjustification)|文字列内の改行文字にスペースを追加します。|
|[CDC::ビューポートを設定します。](#setviewportext)|ビューポートの X 範囲と Y 範囲を設定します。|
|[CDC::セットビューポートオルガ](#setviewportorg)|ビューポートの原点を設定します。|
|[CDC::セットウィンドウエクスク](#setwindowext)|関連付けられたウィンドウの x 範囲と y 範囲を設定します。|
|[CDC::セットウィンドウオルグ](#setwindoworg)|デバイス コンテキストのウィンドウの原点を設定します。|
|[CDC::セットワールドトランスフォーム](#setworldtransform)|現在のワールド空間からページ空間への変換を設定します。|
|[CDC::スタートドック](#startdoc)|新しい印刷ジョブが開始していることをデバイス ドライバに通知します。|
|[CDC::スタートページ](#startpage)|新しいページが開始していることをデバイス ドライバに通知します。|
|[CDC::ストレッチブレット](#stretchblt)|コピー元の四角形とデバイスからターゲットの四角形にビットマップを移動し、必要に応じてビットマップを拡大または圧縮します。|
|[CDC::ストロークアンドフィルパス](#strokeandfillpath)|パス内の開いている図形を閉じ、現在のペンを使用してパスのアウトラインを打ち、現在のブラシを使用して内部を塗りつぶします。|
|[CDC::ストロークパス](#strokepath)|現在のペンを使用して、指定したパスをレンダリングします。|
|[CDC::タブベッドテキストアウト](#tabbedtextout)|指定した位置に文字列を書き込み、タブ位置の配列で指定された値にタブを展開します。|
|[CDC::テキストアウト](#textout)|現在選択されているフォントを使用して、指定した位置に文字列を書き込みます。|
|[CDC::トランスペアレントブレット](#transparentblt)|指定したソース デバイス コンテキストからターゲット デバイス コンテキストに色データのビット ブロックを転送し、転送で指定した色を透明にレンダリングします。|
|[CDC::更新色](#updatecolors)|クライアント領域の現在の色をピクセル単位でシステム パレットに合わせて、デバイス コンテキストのクライアント領域を更新します。|
|[CDC::ワイドパス](#widenpath)|現在のパスをデバイス コンテキストで現在選択されているペンを使用してストロークされた場合に描画される領域として、現在のパスを再定義します。|

### <a name="public-operators"></a>パブリック演算子

|名前|説明|
|----------|-----------------|
|[CDC::オペレーターHDC](#operator_hdc)|デバイス コンテキストのハンドルを取得します。|

### <a name="public-data-members"></a>パブリック データ メンバー

|名前|説明|
|----------|-----------------|
|[CDC::m_hAttribDC](#m_hattribdc)|この`CDC`オブジェクトによって使用される属性デバイス コンテキスト。|
|[CDC::m_hDC](#m_hdc)|この`CDC`オブジェクトによって使用される出力デバイス コンテキスト。|

## <a name="remarks"></a>解説

この`CDC`オブジェクトは、ディスプレイやプリンターなどのデバイス コンテキストを操作するためのメンバー関数と、ウィンドウのクライアント領域に関連付けられた表示コンテキストを操作するためのメンバー関数を提供します。

オブジェクトのメンバー関数を使用して描画を`CDC`行います。 このクラスは、デバイス コンテキスト操作、描画ツールの操作、タイプ セーフグラフィックス デバイス インターフェイス (GDI) オブジェクトの選択、および色とパレットの操作のためのメンバー関数を提供します。 また、描画属性の取得と設定、マッピング、ビューポートの操作、ウィンドウ範囲の操作、座標の変換、領域の操作、クリッピング、線の描画、および単純なシェイプ、楕円、および多角形の描画を行うためのメンバー関数も用意されています。 また、テキストの描画、フォントの操作、プリンターのエスケープの使用、スクロール、メタファイルの再生に使用するメンバー関数も用意されています。

オブジェクトを使用`CDC`するには、オブジェクトを構築し、デバイス コンテキストを使用する Windows 関数を並列処理するメンバー関数を呼び出します。

> [!NOTE]
> Windows 95/98 では、すべての画面座標は 16 ビットに制限されています。 したがって、`CDC`メンバー関数に渡される**int**は-32768 から 32767 の範囲内になければなりません。

特定の用途に対して、 から派生したクラスが`CDC`Microsoft Foundation クラス ライブラリに用意されています。 `CPaintDC`と の呼`BeginPaint`び`EndPaint`出しをカプセル化します。 `CClientDC`は、ウィンドウのクライアント領域に関連付けられた表示コンテキストを管理します。 `CWindowDC`は、フレームやコントロールを含む、ウィンドウ全体に関連付けられた表示コンテキストを管理します。 `CMetaFileDC`は、デバイス コンテキストをメタファイルに関連付けます。

`CDC`には、ウィンドウからレイアウトを継承しないデバイス コンテキストのレイアウトを反転するための 2 つのメンバー関数[GetLayout](#getlayout)と[SetLayout](#setlayout)が用意されています。 このような右から左への向きは、文字レイアウトがヨーロッパ標準ではないアラビア語やヘブライ語などのカルチャ用に記述されたアプリケーションに必要です。

`CDC`[m_hDC](#m_hdc)と[m_hAttribDC](#m_hattribdc)の 2 つのデバイス コンテキストが`CDC`含まれます。 `CDC`すべての出力 GDI 呼び`m_hDC`出しをに、ほとんどの属性`m_hAttribDC`GDI 呼び出しを に指示します。 (属性呼び出しの例`GetTextColor`として`SetTextColor`は、出力呼び出しがあります。

たとえば、フレームワークは、これら 2 つのデバイス コンテキストを`CMetaFileDC`使用して、物理デバイスから属性を読み取りながら、メタファイルに出力を送信するオブジェクトを実装します。 印刷プレビューは、同様の方法でフレームワークに実装されます。 また、アプリケーション固有のコードで、2 つのデバイス コンテキストを同様の方法で使用することもできます。

と`m_hDC``m_hAttribDC`デバイス コンテキストの両方からテキスト メトリック情報が必要になる場合があります。 次の関数のペアがこの機能を提供します。

|m_hAttribDCを使用|使用m_hDC|
|-----------------------|-----------------|
|[テキスト範囲を取得します。](#gettextextent)|[テキスト範囲を取得します。](#getoutputtextextent)|
|[テキスト範囲を取得します。](#gettabbedtextextent)|[テキスト範囲を取得します。](#getoutputtabbedtextextent)|
|[テキストメトリックス](#gettextmetrics)|[テキスト メトリックス](#getoutputtextmetrics)|
|[文字幅を取得します。](#getcharwidth)|[出力文字幅](#getoutputcharwidth)|

の詳細については、「 `CDC`[デバイス コンテキスト](../../mfc/device-contexts.md)」を参照してください。

## <a name="inheritance-hierarchy"></a>継承階層

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>必要条件

**ヘッダー:** afxwin.h

## <a name="cdcabortdoc"></a><a name="abortdoc"></a>CDC::アボートドック

現在の印刷ジョブを終了し[、StartDoc](#startdoc)メンバー関数への最後の呼び出し以降にアプリケーションがデバイスに書き込んだすべてのものを消去します。

```
int AbortDoc();
```

### <a name="return-value"></a>戻り値

成功した場合は 0 以上の値、エラーが発生した場合は負の値。 次の一覧は、一般的なエラー値とその意味を示しています。

- SP_ERROR一般エラーです。

- SP_OUTOFDISKスプールに使用できるディスク領域が不足しており、これ以上使用可能な領域はありません。

- SP_OUTOFMEMORY スプールに使用できるメモリが不足しています。

- SP_USERABORT ユーザーが印刷マネージャーを使用してジョブを終了しました。

### <a name="remarks"></a>解説

このメンバー関数は、ABORTDOC プリンター・エスケープを置き換えます。

`AbortDoc`は、次の処理を終了するために使用する必要があります。

- を使用して中止関数を指定しない印刷操作[。](#setabortproc)

- 最初の NEWFRAME または NEXTBAND エスケープ呼び出しにまだ達していない印刷操作。

アプリケーションで印刷エラーまたは印刷操作の取り消しが発生した場合は、 [EndDoc](#enddoc)または`AbortDoc`クラス`CDC`のメンバー関数を使用して操作を終了しないでください。 GDI は、エラー値を返す前に、操作を自動的に終了します。

アプリケーションがユーザーに印刷操作をキャンセルするためのダイアログ ボックスを表示する場合は、ダイアログ`AbortDoc`ボックスを破棄する前に呼び出す必要があります。

印刷ジョブの開始に印刷マネージャーを使用した場合、`AbortDoc`呼び出しによってスプール ジョブ全体が消去されます。 印刷ジョブの開始に印刷マネージャーを使用していない場合は、データが呼び出される前`AbortDoc`にプリンタに送信されている可能性があります。 この場合、プリンタ ドライバはプリンタをリセットし (可能な場合)、印刷ジョブを終了します。

### <a name="example"></a>例

  [CDC::StartDoc](#startdoc)の例を参照してください。

## <a name="cdcabortpath"></a><a name="abortpath"></a>CDC::アボートパス

デバイス コンテキスト内のパスを閉じて破棄します。

```
BOOL AbortPath();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

デバイス コンテキストにオープン パス ブラケットがある場合、パス ブラケットは閉じられ、パスは破棄されます。 デバイス コンテキストに閉じたパスがある場合、パスは破棄されます。

## <a name="cdcaddmetafilecomment"></a><a name="addmetafilecomment"></a>CDC::ファイルのコメントを追加します。

バッファーから指定した拡張形式メタファイルにコメントをコピーします。

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>パラメーター

*データサイズ*<br/>
コメント バッファの長さをバイト単位で指定します。

*を使用します。*<br/>
コメントを含むバッファーへのポイント。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

コメントには、画像のソースや作成日などの個人情報を含めることができます。 コメントは、アプリケーション署名で始まり、その後にデータを続けます。 コメントには、位置固有のデータを含めないようにしてください。 位置固有のデータはレコードの場所を指定しますが、メタファイルが別のメタファイルに埋め込まれている可能性があるため、レコードを含めるべきではありません。 この関数は、拡張メタファイルでのみ使用できます。

## <a name="cdcalphablend"></a><a name="alphablend"></a>CDC::アルファブレンド

透明または半透明のピクセルを持つビットマップを表示します。

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>パラメーター

*xDest*<br/>
移動先の四角形の左上隅の x 座標を論理単位で指定します。

*イデスト*<br/>
移動先の四角形の左上隅の y 座標を論理単位で指定します。

*幅*<br/>
コピー先の四角形の幅を論理単位で指定します。

*最も高い*<br/>
コピー先の四角形の高さを論理単位で指定します。

*pSrcDC*<br/>
ソース デバイス コンテキストへのポインター。

*xSrc*<br/>
ソース四角形の左上隅の x 座標を論理単位で指定します。

*ySrc*<br/>
ソース四角形の左上隅の y 座標を論理単位で指定します。

*幅*<br/>
ソース四角形の幅を論理単位で指定します。

*NSrcHeight*<br/>
ソース四角形の高さを論理単位で指定します。

*ブレンド*<br/>
[ブレンド関数](/windows/win32/api/wingdi/ns-wingdi-blendfunction)構造体を指定します。

### <a name="return-value"></a>戻り値

成功した場合は TRUE、それ以外の場合は FALSE。

### <a name="remarks"></a>解説

詳細については、Windows SDK の[アルファブレンド](/windows/win32/api/wingdi/nf-wingdi-alphablend)を参照してください。

## <a name="cdcanglearc"></a><a name="anglearc"></a>CDC::アングルアーク

線分と円弧を描画します。

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
円の中心の論理 x 座標を指定します。

*Y*<br/>
円の中心の論理 y 座標を指定します。

*n半径*<br/>
円の半径を論理単位で指定します。 必ず正の値を指定します。

*fスタートアングル*<br/>
X 軸を基準とした角度を角度で指定します。

*fスイープアングル*<br/>
開始角度に対するスイープ角度を角度で指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

線分は、現在の位置から円弧の始点まで描画されます。円弧は、指定された半径と中心を持つ円の周囲に沿って描画されます。 円弧の長さは、指定された開始角度とスイープ角度によって定義されます。

`AngleArc`現在の位置を円弧の終了点に移動します。この関数によって描画される円弧は、現在の変換モードとマッピング モードに応じて楕円に見えることがあります。 円弧を描画する前に、この関数は、現在位置から円弧の始点までの線分を描画します。円弧は、指定した中心点を中心に指定した半径を持つ虚円を作成して描画されます。 円弧の始点は、円の x 軸から始点角の角度で反時計回りに計測することで決定されます。 終点は、スイープ角度の角度の数で始点から反時計回りに測定することによって同様に位置します。

スイープ角度が 360 度を超える場合、円弧は複数回スイープされます。 この関数は、現在のペンを使用して線を描画します。 図は塗りつぶされません。

## <a name="cdcarc"></a><a name="arc"></a>CDC::アーク

楕円弧を描画します。

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
外接する四角形の左上隅の x 座標を指定します (論理単位)。

*y1*<br/>
外接する四角形の左上隅の y 座標を指定します (論理単位)。

*x2*<br/>
外接する四角形の右下隅の x 座標を指定します (論理単位)。

*y2*<br/>
外接する四角形の右下隅の y 座標を指定します (論理単位)。

*x3*<br/>
円弧の始点を定義する点の x 座標を指定します(論理単位)。 この点は、円弧上に正確に配置する必要はありません。

*y3*<br/>
円弧の始点を定義する点の y 座標を指定します(論理単位)。 この点は、円弧上に正確に配置する必要はありません。

*x4*<br/>
円弧の端点を定義する点の x 座標を指定します (論理単位)。 この点は、円弧上に正確に配置する必要はありません。

*y4*<br/>
円弧の終点を定義する点の y 座標を指定します (論理単位)。 この点は、円弧上に正確に配置する必要はありません。

*Lprect*<br/>
外接する四角形を指定します (論理単位)。 このパラメーターには LPRECT または[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクトを渡すことができます。

*ptStart*<br/>
円弧の始点を定義する点の x 座標と y 座標を指定します(論理単位)。 この点は、円弧上に正確に配置する必要はありません。このパラメーターには[、POINT](/windows/win32/api/windef/ns-windef-point)構造体または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)オブジェクトのいずれかを渡すことができます。

*ptEnd*<br/>
円弧の終点を定義する点の x 座標と y 座標を指定します (論理単位)。 この点は、円弧上に正確に配置する必要はありません。このパラメーターには、`POINT`構造体またはオブジェクトを`CPoint`渡すことができます。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

関数を使用して描画される円弧は、指定された外接する四角形によって定義される楕円のセグメントです。

円弧の実際の始点は、外接する四角形の中心から指定した開始点を通って描画された光線が楕円と交差する点です。 円弧の実際の終点は、外接する四角形の中心から指定された終点を通って描画されたレイが楕円と交差する点です。 円弧は反時計回りに描画されます。 円弧は閉じた図形ではないため、塗りつぶされません。 四角形の幅と高さの両方が 2 単位より大きく、32,767 単位未満である必要があります。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

## <a name="cdcarcto"></a><a name="arcto"></a>CDC::アークト

楕円弧を描画します。

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
外接する四角形の左上隅の x 座標を指定します (論理単位)。

*y1*<br/>
外接する四角形の左上隅の y 座標を指定します (論理単位)。

*x2*<br/>
外接する四角形の右下隅の x 座標を指定します (論理単位)。

*y2*<br/>
外接する四角形の右下隅の y 座標を指定します (論理単位)。

*x3*<br/>
円弧の始点を定義する点の x 座標を指定します(論理単位)。 この点は、円弧上に正確に配置する必要はありません。

*y3*<br/>
円弧の始点を定義する点の y 座標を指定します(論理単位)。 この点は、円弧上に正確に配置する必要はありません。

*x4*<br/>
円弧の端点を定義する点の x 座標を指定します (論理単位)。 この点は、円弧上に正確に配置する必要はありません。

*y4*<br/>
円弧の終点を定義する点の y 座標を指定します (論理単位)。 この点は、円弧上に正確に配置する必要はありません。

*Lprect*<br/>
外接する四角形を指定します (論理単位)。 このパラメーターには[、RECT](/windows/win32/api/windef/ns-windef-rect)データ構造体へのポインターまたは[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクトのいずれかを渡すことができます。

*ptStart*<br/>
円弧の始点を定義する点の x 座標と y 座標を指定します(論理単位)。 この点は、円弧上に正確に配置する必要はありません。このパラメーターには[、POINT](/windows/win32/api/windef/ns-windef-point)データ構造または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)オブジェクトのいずれかを渡すことができます。

*ptEnd*<br/>
円弧の終点を定義する点の x 座標と y 座標を指定します (論理単位)。 この点は、円弧上に正確に配置する必要はありません。このパラメーターには、`POINT`データ構造またはオブジェクトのいずれかを`CPoint`渡すことができます。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

この関数は、現在`CDC::Arc`の位置が更新される点を除いて、 に似ています。 *(x1*、 *y1*) および ( *x2*, *y2*) は、外接する四角形を指定します。 指定された外接する四角形によって形成される楕円は、円弧の曲線を定義します。円弧は、外接する四角形の中心から *(x3, y3)* に対して半径線と交差する点から反時計回り*y3*(既定の円弧方向)に延びる。 円弧は、外接する四角形の中心から *(x4, y4)* までの放射*y4*状の線と交差する位置で終了します。 始点と終点が同じ場合は、楕円全体が描画されます。

現在の位置から円弧の始点まで線が引かれます。エラーが発生しない場合、現在の位置は円弧の終了点に設定されます。円弧は現在のペンを使用して描画されます。満たされていません。

## <a name="cdcattach"></a><a name="attach"></a>CDC::アタッチ

このメンバー関数を使用して *、hDC*を`CDC`オブジェクトにアタッチします。

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>パラメーター

*Hdc*<br/>
Windows デバイス コンテキスト。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

*hDC*は、出力デバイス`m_hDC`コンテキスト、および 属性デバイス`m_hAttribDC`コンテキストの両方に格納されます。

## <a name="cdcbeginpath"></a><a name="beginpath"></a>CDC::ビギンパス

デバイス コンテキストでパス ブラケットを開きます。

```
BOOL BeginPath();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

パス ブラケットが開いた後、アプリケーションは GDI 描画関数の呼び出しを開始して、パス内のポイントを定義できます。 アプリケーションは、メンバー関数を呼び出すことによって、`EndPath`オープン パス ブラケットを閉じることができます。 アプリケーションが を`BeginPath`呼び出すと、以前のパスはすべて破棄されます。

パス内のポイントを定義する描画関数の一覧については、Windows SDK の[BeginPath](/windows/win32/api/wingdi/nf-wingdi-beginpath)を参照してください。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

## <a name="cdcbitblt"></a><a name="bitblt"></a>CDC::ビットブレット

ソース デバイス コンテキストからこの現在のデバイス コンテキストにビットマップをコピーします。

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
移動先の四角形の左上隅の論理 x 座標を指定します。

*Y*<br/>
移動先の四角形の左上隅の論理 y 座標を指定します。

*n幅*<br/>
コピー先の四角形と元のビットマップの幅を論理単位で指定します。

*nHeight*<br/>
コピー先の四角形と元のビットマップの高さを論理単位で指定します。

*pSrcDC*<br/>
ビットマップの`CDC`コピー元のデバイス コンテキストを識別するオブジェクトへのポインター。 *dwRop*がソースを含まないラスター操作を指定する場合は、NULL にする必要があります。

*xSrc*<br/>
ソース ビットマップの左上隅の論理 x 座標を指定します。

*ySrc*<br/>
ソース ビットマップの左上隅の論理 y 座標を指定します。

*dwRop*<br/>
実行するラスター オペレーションを指定します。 ラスター操作コードは、GDI が現在のブラシ、ソース ビットマップ、および出力先ビットマップを含む出力操作で色を組み合わせる方法を定義します。 *dwRop*のラスター オペレーション コードとその説明の一覧については、Windows SDK の[BitBlt](/windows/win32/api/wingdi/nf-wingdi-bitblt)を参照してください。

ラスター オペレーション コードの完全な一覧については、「Windows SDK の[ラスター オペレーション コードについて](/windows/win32/gdi/raster-operation-codes)」を参照してください。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

アプリケーションは、バイト境界上のウィンドウまたはクライアント領域を整列して、バイト配置`BitBlt`された四角形で操作を実行できます。 (ウィンドウ クラスを登録するときに、CS_BYTEALIGNWINDOW フラグまたはCS_BYTEALIGNCLIENT フラグを設定します)。

`BitBlt`バイト配列の四角形に対する操作は、バイト`BitBlt`位置合わせされていない四角形に対する操作よりもかなり高速です。 独自のデバイス コンテキストのバイト配置などのクラス スタイルを指定する場合は、Microsoft Foundation クラスを使用せずに、ウィンドウ クラスを登録する必要があります。 グローバル関数を使用[します](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)。

GDI は、変換先のデバイス コンテキストを使用して 1 回、およびソース デバイス コンテキストを使用して 1 回*nWidth*と*nHeight*を変換します。 結果のエクステントが一致しない場合、GDI は`StretchBlt`Windows 関数を使用して、必要に応じてソース ビットマップを圧縮または拡大します。

変換先ビットマップ、変換元ビットマップ、およびパターン ビットマップのカラー形式が同じ`BitBlt`でない場合、この関数は変換元ビットマップとパターン ビットマップを変換先に変換します。 変換先ビットマップの前景色と背景色が変換に使用されます。

この関数`BitBlt`は、モノクロ ビットマップをカラーに変換するときに、白いビット (1) を背景色に、黒ビット (0) を前景色に設定します。 ターゲット デバイス コンテキストの前景色と背景色が使用されます。 カラーをモノクロに変換するには、`BitBlt`背景色に合ったピクセルを白に設定し、その他のすべてのピクセルを黒に設定します。 `BitBlt`では、カラー デバイス コンテキストの前景色と背景色を使用して、カラーをモノクロに変換します。

すべてのデバイス コンテキストがサポート`BitBlt`されているわけではないことに注意してください。 指定されたデバイス コンテキストがをサポート`BitBlt`しているかどうかを確認するには、`GetDeviceCaps`メンバー関数を使用して RASTERCAPS インデックスを指定します。

### <a name="example"></a>例

  [CDC::CreateCompatibleDC](#createcompatibledc)の例を参照してください。

## <a name="cdccdc"></a><a name="cdc"></a>CDC::CDC

`CDC` オブジェクトを構築します。

```
CDC();
```

## <a name="cdcchord"></a><a name="chord"></a>CDC::コード

弦(楕円と線分の交差部分に囲まれた閉じた図形)を描画します。

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
弦の外接する四角形の左上隅の x 座標を指定します (論理単位)。

*y1*<br/>
弦の外接する四角形の左上隅の y 座標を指定します (論理単位)。

*x2*<br/>
弦の外接する四角形の右下隅の x 座標を指定します (論理単位)。

*y2*<br/>
弦の外接する四角形の右下隅の y 座標を指定します (論理単位)。

*x3*<br/>
弦の始点を定義する点の x 座標を指定します(論理単位)。

*y3*<br/>
弦の始点を定義する点の Y 座標を指定します(論理単位)。

*x4*<br/>
弦の終点を定義する点の x 座標を指定します(論理単位)。

*y4*<br/>
弦の終点を定義する点の y 座標を指定します(論理単位)。

*Lprect*<br/>
外接する四角形を指定します (論理単位)。 このパラメーターには LPRECT または[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクトを渡すことができます。

*ptStart*<br/>
弦の始点を定義する点の x 座標と y 座標を指定します(論理単位)。 この点は、コード上に正確に配置する必要はありません。 このパラメーターには、`POINT`構造体またはオブジェクトを`CPoint`渡すことができます。

*ptEnd*<br/>
弦の終了点を定義する点の x 座標と y 座標を指定します(論理単位)。 この点は、コード上に正確に配置する必要はありません。 このパラメーターには[、POINT](/windows/win32/api/windef/ns-windef-point)構造体または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)オブジェクトのいずれかを渡すことができます。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

( *x1*, *y1*) および ( *x2*, *y2*) のパラメータは、和音の一部である楕円に外接する長方形の左上隅と右下隅をそれぞれ指定します。 ( *x3*, *y3*) および ( *x4*, *y4*) のパラメータは、楕円と交差する線の端点を指定します。 選択したペンを使用してコードを描画し、選択したブラシを使用して塗りつぶします。

関数によって描画された`Chord`図形は、右と下の座標を含まないまで拡張します。 つまり、図の高さは*y2* - *y1、* 図形の幅は*x2* - *x1*です。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

## <a name="cdcclosefigure"></a><a name="closefigure"></a>CDC::クローズフィギュア

パス内の開いている図形を閉じます。

```
BOOL CloseFigure();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

この関数は、現在位置から図形の最初の点 (通常は、`MoveTo`メンバー関数の最後の呼び出しで指定された点) に線を引いて図形を閉じ、線結合スタイルを使用して線を接続します。 の代わりに`CloseFigure`メンバー関数を使用して`LineTo`図形を閉じる場合は、結合ではなく角を作成するために、終了キャップが使用されます。 `CloseFigure`デバイス コンテキストにオープン パス ブラケットがある場合にのみ呼び出されます。

パス内の図形は、この関数を使用して明示的に閉じられている場合を除いて開きます。 (図の現在の点と始点が同じであっても、図は開くことができます。新しい図形を開始した後`CloseFigure`にパスに追加された線または曲線。

## <a name="cdccreatecompatibledc"></a><a name="createcompatibledc"></a>CDC:作成互換性のあるDC

*pDC*で指定されたデバイスと互換性のあるメモリ デバイス コンテキストを作成します。

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>パラメーター

*pDC*<br/>
デバイス コンテキストへのポインター。 *pDC*が NULL の場合、この関数はシステムディスプレイと互換性のあるメモリデバイスコンテキストを作成します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

メモリ デバイス コンテキストは、表示サーフェスを表すメモリのブロックです。 互換性のあるデバイスの実際のデバイス表面にコピーする前に、メモリ内のイメージを準備するために使用することができます。

メモリ デバイス コンテキストが作成されると、GDI は自動的に 1× 1 のモノクロ ストック ビットマップを選択します。 GDI 出力関数は、ビットマップが作成され、そのコンテキストに選択されている場合にのみ、メモリ デバイス コンテキストで使用できます。

この関数は、ラスター操作をサポートするデバイスに互換性のあるデバイス コンテキストを作成する場合にのみ使用できます。 デバイス コンテキスト間のビット ブロック転送に関する情報については[、CDC::BitBlt](#bitblt)メンバー関数を参照してください。 デバイス コンテキストがラスター操作をサポートしているかどうかを判断するには、メンバー関数`CDC::GetDeviceCaps`のラスター機能RC_BITBLTを参照してください。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

## <a name="cdccreatedc"></a><a name="createdc"></a>CDC::DC の作成

指定したデバイスのデバイス コンテキストを作成します。

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>パラメーター

*ドライバー名を指定します。*<br/>
デバイス ドライバのファイル名 (拡張子なし) を指定する null で終わる文字列 ("EPSON" など) を指します。 このパラメータにオブジェクトを`CString`渡すこともできます。

*名前を指定します。*<br/>
サポートする特定のデバイスの名前を指定する NULL で終わる文字列を指します ("EPSON FX-80"など)。 モジュールが複数のデバイスをサポートしている場合は *、lpszDeviceName*パラメーターが使用されます。 このパラメータにオブジェクトを`CString`渡すこともできます。

*出力*<br/>
物理出力メディア (ファイルまたは出力ポート) のファイルまたはデバイス名を指定する、null で終わる文字列を指します。 このパラメータにオブジェクトを`CString`渡すこともできます。

*データ*<br/>
デバイス ドライバー`DEVMODE`のデバイス固有の初期化データを含む構造体へのポイント。 Windows`DocumentProperties`関数は、指定されたデバイスに対して入力されたこの構造体を取得します。 デバイス ドライバーがコントロール パネルでユーザーによって指定された既定の初期化 (存在する場合) を使用する場合は *、lpInitData*パラメーターを NULL にする必要があります。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

印刷。[DEVMODE](/windows/win32/api/wingdi/ns-wingdi-devmodea)構造体を使用する場合は、H ヘッダー ファイルが必要です。

デバイス名は、次の規則に従います: コロンの最後 (:)は推奨されますが、オプションです。 Windows は、コロンで終わるデバイス名がコロンなしで同じ名前と同じポートにマップされるように、終端コロンを取り除きます。 ドライバー名とポート名には、先頭または末尾のスペースを含めることはできません。 GDI 出力関数は、情報コンテキストでは使用できません。

## <a name="cdccreateic"></a><a name="createic"></a>CDC::創造

指定したデバイスの情報コンテキストを作成します。

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>パラメーター

*ドライバー名を指定します。*<br/>
デバイス ドライバのファイル名 (拡張子なし) を指定する null で終わる文字列 ("EPSON" など) を指します。 このパラメーターのオブジェクト`CString`を渡すことができます。

*名前を指定します。*<br/>
サポートする特定のデバイスの名前を指定する NULL で終わる文字列を指します ("EPSON FX-80"など)。 モジュールが複数のデバイスをサポートしている場合は *、lpszDeviceName*パラメーターが使用されます。 このパラメーターのオブジェクト`CString`を渡すことができます。

*出力*<br/>
物理出力メディア (ファイルまたはポート) のファイルまたはデバイス名を指定する、null で終わる文字列を指します。 このパラメーターのオブジェクト`CString`を渡すことができます。

*データ*<br/>
デバイス ドライバーのデバイス固有の初期化データを指します。 デバイス ドライバーがコントロール パネルでユーザーによって指定された既定の初期化 (存在する場合) を使用する場合は *、lpInitData*パラメーターを NULL にする必要があります。 デバイス`CreateDC`固有の初期化のデータ形式については、「」を参照してください。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

情報コンテキストは、デバイス コンテキストを作成せずに、デバイスに関する情報を取得する高速な方法を提供します。

デバイス名は、次の規則に従います: コロンの最後 (:)は推奨されますが、オプションです。 Windows は、コロンで終わるデバイス名がコロンなしで同じ名前と同じポートにマップされるように、終端コロンを取り除きます。 ドライバー名とポート名には、先頭または末尾のスペースを含めることはできません。 GDI 出力関数は、情報コンテキストでは使用できません。

## <a name="cdcdeletedc"></a><a name="deletedc"></a>CDC::DエレテDC

一般に、この関数は呼び出しません。デストラクタはあなたのためにそれを行います。

```
BOOL DeleteDC();
```

### <a name="return-value"></a>戻り値

関数が正常に完了した場合は 0 以外の値を返します。それ以外の場合は 0。

### <a name="remarks"></a>解説

メンバー`DeleteDC`関数は、現在`m_hDC``CDC`のオブジェクトに関連付けられている Windows デバイス コンテキストを削除します。 この`CDC`オブジェクトが特定のデバイスの最後のアクティブなデバイス コンテキストである場合、そのデバイスに通知され、デバイスが使用するすべてのストレージとシステム リソースが解放されます。

デバイス コンテキストでオブジェクト`DeleteDC`が選択されている場合、アプリケーションは呼び出されません。 オブジェクトは、削除する前にデバイス コンテキストから選択する必要があります。

[CWnd::GetDC](../../mfc/reference/cwnd-class.md#getdc)を呼び出してハンドルを取得したデバイス コンテキストをアプリケーションが削除することはできません。 代わりに、デバイス コンテキストを解放するために[CWnd::ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc)を呼び出す必要があります。 この機能をラップするために[、CClientDC](../../mfc/reference/cclientdc-class.md)クラスと[CWindowDC](../../mfc/reference/cwindowdc-class.md)クラスが提供されています。

この`DeleteDC`関数は、通常[、CreateDC](#createdc)、 CreateIC 、または[CreateCompatibleDC](#createcompatibledc)で作成されたデバイス コンテキストを削除するために使用されます。 [CreateIC](#createic)

### <a name="example"></a>例

  [次](../../mfc/reference/cprintdialog-class.md#getprinterdc)の例を参照してください。

## <a name="cdcdeletetempmap"></a><a name="deletetempmap"></a>CDC::D一時マップ

`CWinApp`アイドル時ハンドラによって自動的に呼び出`DeleteTempMap`され、によって`CDC``FromHandle`作成された一時オブジェクトは削除されますが、オブジェクトに一時的に`hDC`関連付けられたデバイス コンテキスト`CDC`ハンドルは破棄されません。

```
static void PASCAL DeleteTempMap();
```

## <a name="cdcdetach"></a><a name="detach"></a>CDC::Dエタッハ

オブジェクトから (出力`m_hDC`デバイス コンテキスト) をデタッチし、両方`m_hDC`を`m_hAttribDC`NULL に設定します。 `CDC`

```
HDC Detach();
```

### <a name="return-value"></a>戻り値

Windows デバイス コンテキスト。

## <a name="cdcdptohimetric"></a><a name="dptohimetric"></a>CDC::Dプトヒメトリック

この関数は、HIMETRIC サイズを OLE に与え、ピクセルを HIMETRIC に変換するときに使用します。

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>パラメーター

*lp サイズ*<br/>
[SIZE](/windows/win32/api/windef/ns-windef-size)構造体または[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクトへのポイント。

### <a name="remarks"></a>解説

デバイス コンテキスト オブジェクトのマッピング モードがMM_LOENGLISH、MM_HIENGLISH、MM_LOMETRIC、またはMM_HIMETRIC場合、変換は物理インチ単位のピクセル数に基づきます。 マッピング モードが他の非制約モード (MM_TEXTなど) の場合、変換は論理インチのピクセル数に基づいて行われます。

## <a name="cdcdptolp"></a><a name="dptolp"></a>CDC::Dプトープ

デバイス単位を論理単位に変換します。

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>パラメーター

*Lppoints*<br/>
[POINT](/windows/win32/api/windef/ns-windef-point)構造体または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)オブジェクトの配列へのポイント。

*nカウント*<br/>
配列内のポイント数。

*Lprect*<br/>
[RECT](/windows/win32/api/windef/ns-windef-rect)構造体または[CRect オブジェクトへのポイント](../../atl-mfc-shared/reference/crect-class.md)。 このパラメーターは、1 つの四角形をデバイス ポイントから論理ポイントに変換する単純な場合に使用されます。

*lp サイズ*<br/>
[SIZE](/windows/win32/api/windef/ns-windef-size)構造体または[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクトへのポイント。

### <a name="remarks"></a>解説

この関数は、デバイス座標系から GDI の論理座標系に、サイズの各ポイントの座標をマップします。 変換は、現在のマッピング モード、およびデバイスのウィンドウとビューポートの原点と範囲の設定によって異なります。

## <a name="cdcdraw3drect"></a><a name="draw3drect"></a>CDC::Dロー3dRect

3 次元の四角形を描画します。

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>パラメーター

*Lprect*<br/>
外接する四角形を指定します (論理単位)。 このパラメーターには[、RECT](/windows/win32/api/windef/ns-windef-rect)構造体へのポインターまたは[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクトのいずれかを渡すことができます。

*クラストップレフト*<br/>
3 次元の四角形の上辺と左側の色を指定します。

*右下*<br/>
3 次元の四角形の下辺と右側の色を指定します。

*X*<br/>
3 次元四角形の左上隅の論理 x 座標を指定します。

*Y*<br/>
3 次元四角形の左上隅の論理 y 座標を指定します。

*Cx*<br/>
3 次元の四角形の幅を指定します。

*Cy*<br/>
3 次元の四角形の高さを指定します。

### <a name="remarks"></a>解説

四角形は *、clrTopLeft*で指定された色の上辺と左側、および*clrBottomRight*で指定された色の下辺と右側の辺で描画されます。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

## <a name="cdcdrawdragrect"></a><a name="drawdragrect"></a>CDC::Dロードラグレック

ドラッグ四角形を再描画するには、このメンバー関数を繰り返し呼び出します。

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>パラメーター

*Lprect*<br/>
[RECT](/windows/win32/api/windef/ns-windef-rect)構造体または四角形の論理座標を指定する[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクトへのポインター (この場合は、再描画される四角形の終了位置)。

*サイズ*<br/>
外枠の左上隅から四角形の内側の境界線の左上隅 (つまり、境界線の太さ) までの変位を指定します。

*ラプレックラスト*<br/>
[RECT](/windows/win32/api/windef/ns-windef-rect)構造体または四角形の位置の論理座標を指定する[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクトへのポインター (この場合は、再描画される四角形の元の位置)。

*サイズラスト*<br/>
再描画する元の四角形の、外側の境界線の左上隅から内側の境界線の左上隅 (つまり、境界線の太さ) までの変位を指定します。

*pブラシ*<br/>
ブラシ オブジェクトへのポインター。 既定のハーフトーン ブラシを使用するには、NULL に設定します。

*pブラシラスト*<br/>
最後に使用されたブラシ オブジェクトへのポインター。 既定のハーフトーン ブラシを使用するには、NULL に設定します。

### <a name="remarks"></a>解説

視覚的なフィードバックを与えるために、マウスの位置をサンプリングするときにループ内でそれを呼び出します。 を呼び`DrawDragRect`出すと、前の四角形が消去され、新しい四角形が描画されます。 たとえば、ユーザーが画面全体に四角形をドラッグすると、元`DrawDragRect`の四角形が消去され、新しい四角形が新しい位置に再描画されます。 既定では、`DrawDragRect`フリッカを排除し、滑らかに動く四角形の外観を作成するために、ハーフトーン ブラシを使用して四角形を描画します。

初めて呼び出`DrawDragRect`す場合は *、lpRectLast*パラメータを NULL にする必要があります。

## <a name="cdcdrawedge"></a><a name="drawedge"></a>CDC::Dローエッジ

指定した型とスタイルの四角形の端を描画します。

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>パラメーター

*Lprect*<br/>
四角形の`RECT`論理座標を格納する構造体へのポインター。

*nエッジ*<br/>
描画する内側エッジと外側のエッジの種類を指定します。 このパラメーターは、1 つの内部境界フラグと 1 つの外部境界フラグの組み合わせである必要があります。 パラメーターの型の表については、Windows SDK の[DrawEdge](/windows/win32/api/winuser/nf-winuser-drawedge)を参照してください。

*Nflags*<br/>
描画する境界線の種類を指定するフラグ。 パラメーター`DrawEdge`の値の表については、Windows SDK を参照してください。 対角線の場合、BF_RECTフラグは、矩形パラメーターで囲まれたベクトルの終点を指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

## <a name="cdcdrawescape"></a><a name="drawescape"></a>CDC::Dローエスケープ

グラフィックス デバイス インターフェイス (GDI) を通じて直接使用できないビデオ ディスプレイの描画機能にアクセスします。

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>パラメーター

*nエスケープ*<br/>
実行するエスケープ関数を指定します。

*入力サイズ*<br/>
*lpszInputData*パラメーターによって指されるデータのバイト数を指定します。

*データを入力します。*<br/>
指定されたエスケープに必要な入力構造体を指します。

### <a name="return-value"></a>戻り値

関数の結果を指定します。 正常終了した場合は 0 より大きいが、実装のみをチェックする QUERYESCSUPPORT 描画エスケープを除く。エスケープが実装されていない場合はゼロ。エラーが発生した場合は 0 未満です。

### <a name="remarks"></a>解説

アプリケーションが 呼`DrawEscape`び出すと *、nInputSize*および*lpszInputData*で識別されるデータが、指定されたディスプレイ ドライバーに直接渡されます。

## <a name="cdcdrawfocusrect"></a><a name="drawfocusrect"></a>CDC::Dローフォーカスレック

四角形にフォーカスがあることを示すために使用するスタイルの四角形を描画します。

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>パラメーター

*Lprect*<br/>
[RECT](/windows/win32/api/windef/ns-windef-rect)構造体または描画する四角形の論理座標を指定する[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクトへのポインター。

### <a name="remarks"></a>解説

これはブール XOR 関数であるため、同じ四角形を使用してこの関数をもう一度呼び出すと、表示から四角形が削除されます。 この関数によって描画された四角形はスクロールできません。 この関数によって描画された四角形を含む領域をスクロールするには`DrawFocusRect`、まず、表示から四角形を削除し、次に領域をスクロール`DrawFocusRect`してから、もう一度呼び出して新しい位置に四角形を描画します。

> [!CAUTION]
> `DrawFocusRect`MM_TEXTモードでのみ動作します。 他のモードでは、この関数はフォーカスの四角形を正しく描画しませんが、エラー値を返しません。

## <a name="cdcdrawframecontrol"></a><a name="drawframecontrol"></a>CDC::Dローフレームコントロール

指定した型とスタイルのフレーム コントロールを描画します。

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>パラメーター

*Lprect*<br/>
四角形の`RECT`論理座標を格納する構造体へのポインター。

*nType*<br/>
描画するフレーム コントロールの種類を指定します。 このパラメーターの使用可能な値の一覧については、Windows SDK の*UType*パラメーターを参照してください。 [DrawFrameControl](/windows/win32/api/winuser/nf-winuser-drawframecontrol)

*nステート*<br/>
フレーム コントロールの初期状態を指定します。 Windows SDK で`DrawFrameControl`*の uState*パラメーターに記述されている値の 1 つ以上を指定できます。 プッシュ ボタンの周囲の端を除外するために外接する四角形を調整するには *、nState*値DFCS_ADJUSTRECTを使用します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

いくつかのケースでは *、nState*は*nType*パラメーターに依存します。 次のリストは、4 つの*nType*値と*nState*の関係を示しています。

- DFC_BUTTON

  - DFCS_BUTTON3STATE3 ステート ボタン

  - DFCS_BUTTONCHECKチェック ボックス

  - DFCS_BUTTONPUSHプッシュボタン

  - DFCS_BUTTONRADIOラジオボタン

  - DFCS_BUTTONRADIOIMAGEラジオボタンの画像(非スクエアは画像を必要とします)

  - ラジオボタンのためのDFCS_BUTTONRADIOMASKマスク(非スクエアはマスクを必要とします)

- DFC_CAPTION

  - [DFCS_CAPTIONCLOSE閉じる] ボタン

  - [ヘルプDFCS_CAPTIONHELPボタン

  - 最大化ボタンDFCS_CAPTIONMAX

  - DFCS_CAPTIONMIN最小化ボタン

  - [復元DFCS_CAPTIONRESTOREボタン

- DFC_MENU

  - サブメニュー矢印DFCS_MENUARROW

  - DFCS_MENUBULLET弾丸

  - チェック マークDFCS_MENUCHECK

- DFC_SCROLL

  - コンボ ボックスのスクロール バーDFCS_SCROLLCOMBOBOX

  - スクロール バーの下向き矢印をDFCS_SCROLLDOWN

  - スクロール バーの左矢印をDFCS_SCROLLLEFT

  - スクロール バーの右矢印をDFCS_SCROLLRIGHT

  - DFCS_SCROLLSIZEGRIP ウィンドウの右下隅のサイズグリップ

  - スクロール バーの上矢印をDFCS_SCROLLUP

### <a name="example"></a>例

このコードは、ウィンドウの右下隅にサイズグリッパーを描画します。 これは、スタイルを`OnPaint`持たないダイアログ ボックスのハンドラーに適しており、通常はサイズ グリッパーを与える可能性のある他のコントロール (ステータス バーなど) を含みません。

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

## <a name="cdcdrawicon"></a><a name="drawicon"></a>CDC::Dローアイコン

現在`CDC`のオブジェクトで表されるデバイス上にアイコンを描画します。

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
アイコンの左上隅の論理 x 座標を指定します。

*Y*<br/>
アイコンの左上隅の論理 y 座標を指定します。

*Hicon*<br/>
描画するアイコンのハンドルを識別します。

*ポイント*<br/>
アイコンの左上隅の論理 x 座標と y 座標を指定します。 このパラメータには[、POINT](/windows/win32/api/windef/ns-windef-point)構造体または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)オブジェクトを渡すことができます。

### <a name="return-value"></a>戻り値

関数が正常に完了した場合は 0 以外の値を返します。それ以外の場合は 0。

### <a name="remarks"></a>解説

この関数は、アイコンの左上隅を*x*と*y*で指定された位置に配置します。 場所は、デバイス コンテキストの現在のマッピング モードに依存します。

アイコン リソースは、 `CWinApp::LoadIcon`、 、`CWinApp::LoadStandardIcon`または`CWinApp::LoadOEMIcon`を使用して以前に読み込まれている必要があります。 この`MM_TEXT`関数を使用する前に、マッピング モードを選択する必要があります。

### <a name="example"></a>例

  [CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic)の例を参照してください。

## <a name="cdcdrawstate"></a><a name="drawstate"></a>CDC::Dローステート

イメージを表示し、視覚効果を適用して、無効な状態や既定の状態などの状態を示します。

> [!NOTE]
> DSS_NORMALを除くすべての*nFlag*状態では、イメージはモノクロに変換されてから視覚効果が適用されます。

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>パラメーター

*Pt*<br/>
イメージの場所を指定します。

*サイズ*<br/>
イメージのサイズを指定します。

*hビットマップ*<br/>
ビットマップへのハンドル。

*Nflags*<br/>
イメージの種類と状態を指定するフラグ。 可能な*nFlags*の型と状態については、Windows SDK の[「描画状態](/windows/win32/api/winuser/nf-winuser-drawstatew)」を参照してください。

*hブラシ*<br/>
ブラシへのハンドル。

*ビットマップ*<br/>
オブジェクトへのポインター。

*pブラシ*<br/>
CBrush オブジェクトへのポインター。

*Hicon*<br/>
アイコンにへのハンドル。

*lpszText*<br/>
テキストへのポインター。

*テキスト*<br/>
アクセラレータニーモニックを含む可能性のあるテキスト。 *lData*パラメーターは文字列のアドレスを指定し *、nTextLen*パラメーターは長さを指定します。 *nTextLen*が 0 の場合、文字列は null で終わるものと見なされます。

*nテキストレン*<br/>
*lpszText*が指すテキスト文字列の長さ。 *nTextLen*が 0 の場合、文字列は null で終わるものと見なされます。

*をクリックします。*<br/>
イメージのレンダリングに使用されるコールバック関数へのポインター。 *nFlags*のイメージの種類がDST_COMPLEX場合は、このパラメーターが必要です。 これはオプションであり、イメージの種類がDST_TEXT場合は NULL にすることができます。 その他のすべてのイメージタイプでは、このパラメーターは無視されます。 コールバック関数の詳細については、Windows SDK の[「DrawStateProc](/windows/win32/api/winuser/nc-winuser-drawstateproc)関数」を参照してください。

*lデータ*<br/>
イメージに関する情報を指定します。 このパラメーターの意味は、イメージの種類によって異なります。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

## <a name="cdcdrawtext"></a><a name="drawtext"></a>CDC::Dローテキスト

指定された四角形のテキストの書式を設定します。 追加の書式設定オプションを指定するには[、CDC::DrawTextEx](#drawtextex)を使用します。

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>パラメーター

*文字列*<br/>
描画する文字列へのポイント。 *nCount*が -1 の場合、文字列は null で終わる必要があります。

*nカウント*<br/>
文字列内の文字数を指定します。 *nCount*が -1 の場合 *、lpszString*は null で終わる文字列への長い`DrawText`ポインタであると見なされ、自動的に文字数を計算します。

*Lprect*<br/>
テキストを書式設定する四角形 (論理座標) を含む[RECT](/windows/win32/api/windef/ns-windef-rect)構造体または[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクトへのポインター。

*Str*<br/>
描画する指定された文字を含む[CString](../../atl-mfc-shared/reference/cstringt-class.md)オブジェクト。

*nフォーマット*<br/>
テキストの書式設定方法を指定します。 これは、Windows SDK の[描画テキスト](/windows/win32/api/winuser/nf-winuser-drawtext)で*uFormat*パラメーターに記述されている値の任意の組み合わせにすることができます。 (ビットごとの OR 演算子を使用して結合):

> [!NOTE]
> *uFormat*フラグの組み合わせによっては、渡された文字列が変更される場合があります。 DT_END_ELLIPSISまたはDT_PATH_ELLIPSISでDT_MODIFYSTRINGを使用すると、文字列が変更され、オーバーライド内のアサーションが発生`CString`する場合があります。 DT_CALCRECT値、DT_EXTERNALLEADING値、DT_INTERNAL値、DT_NOCLIP値、およびDT_NOPREFIXは、DT_TABSTOP値と共に使用できません。

### <a name="return-value"></a>戻り値

関数が正常に実行された場合のテキストの高さ。

### <a name="remarks"></a>解説

タブを適切なスペースに展開し、指定された四角形の左、右、または中央にテキストを配置し、指定された四角形内に収まる行にテキストを分割して、テキストを書式設定します。 書式の種類は*nFormat で指定します*。

このメンバー関数は、デバイス コンテキストで選択したフォント、テキストの色、および背景色を使用してテキストを描画します。 DT_NOCLIP形式を使用しない限り`DrawText`、テキストが指定された長方形の外側に表示されないように、テキストをクリップします。 DT_SINGLELINE書式が指定されていない限り、すべての書式設定は複数行を持つものとします。

選択したフォントが指定された四角形に対して大きすぎる`DrawText`場合、メンバー関数は小さいフォントの代わりに使用しません。

DT_CALCRECTフラグを指定すると *、lpRect*で指定された四角形が更新され、テキストの描画に必要な幅と高さが反映されます。

TA_UPDATECPテキスト配置フラグが設定されている場合[(CDC::SetTextAlign](#settextalign)を参照`DrawText`)、指定された四角形の左ではなく、現在の位置から開始するテキストが表示されます。 `DrawText`TA_UPDATECPフラグが設定されている場合はテキストを折り返しません (つまり、DT_WORDBREAK フラグは無効になります)。

テキストの色は[、CDC:::SetTextColor](#settextcolor)によって設定できます。

## <a name="cdcdrawtextex"></a><a name="drawtextex"></a>CDC::Dローテキスト

指定された四角形のテキストを書式設定します。

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>パラメーター

*文字列*<br/>
描画する文字列へのポイント。 *nCount*が -1 の場合、文字列は null で終わる必要があります。

*nカウント*<br/>
文字列内の文字数を指定します。 *nCount*が -1 の場合 *、lpszString*は null で終わる文字列への長い`DrawText`ポインタであると見なされ、自動的に文字数を計算します。

*Lprect*<br/>
テキストを書式設定する四角形 (論理座標) を含む[RECT](/windows/win32/api/windef/ns-windef-rect)構造体または[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクトへのポインター。

*Str*<br/>
描画する指定された文字を含む[CString](../../atl-mfc-shared/reference/cstringt-class.md)オブジェクト。

*nフォーマット*<br/>
テキストの書式設定方法を指定します。 これは、Windows SDK の[描画テキスト](/windows/win32/api/winuser/nf-winuser-drawtext)で*uFormat*パラメーターに記述されている値の任意の組み合わせにすることができます。 (ビットごとの**OR**演算子を使用して結合します):

> [!NOTE]
> *uFormat*フラグの組み合わせによっては、渡された文字列が変更される場合があります。 DT_END_ELLIPSISまたはDT_PATH_ELLIPSISでDT_MODIFYSTRINGを使用すると、文字列が変更され、オーバーライド内のアサーションが発生`CString`する場合があります。 DT_CALCRECT値、DT_EXTERNALLEADING値、DT_INTERNAL値、DT_NOCLIP値、およびDT_NOPREFIXは、DT_TABSTOP値と共に使用できません。

*lpDTパラム*<br/>
追加のフォーマットオプションを指定する[DRAWTEXTPARAMS](/windows/win32/api/winuser/ns-winuser-drawtextparams)構造体へのポインター。 このパラメーターは NULL にすることができます。

### <a name="remarks"></a>解説

タブを適切なスペースに展開し、指定された四角形の左、右、または中央にテキストを配置し、指定された四角形内に収まる行にテキストを分割して、テキストを書式設定します。 書式の種類は *、nFormat*および*lpDTParams*で指定されます。 詳細については、Windows SDK の[「CDC::DrawText](#drawtext)および[DrawTextEx」](/windows/win32/api/winuser/nf-winuser-drawtextexw)を参照してください。

テキストの色は[、CDC:::SetTextColor](#settextcolor)によって設定できます。

## <a name="cdcellipse"></a><a name="ellipse"></a>CDC::楕円

楕円を描きます。

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
楕円の外接する四角形の左上隅の論理 x 座標を指定します。

*y1*<br/>
楕円の外接する四角形の左上隅の論理 y 座標を指定します。

*x2*<br/>
楕円の外接する四角形の右下隅の論理 x 座標を指定します。

*y2*<br/>
楕円の外接する四角形の右下隅の論理 y 座標を指定します。

*Lprect*<br/>
楕円の外接する四角形を指定します。 このパラメータに[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクトを渡すこともできます。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

楕円の中心は *、x1*、 y1 、 *x2*、および*y2* *y2*、または*lpRect*で指定された外接する四角形の中心です。 楕円は現在のペンで描画され、その内部は現在のブラシで塗りつぶされます。

この関数によって描画される図形は、右辺と下の座標まで拡張されますが、含まれていません。 つまり、図の高さは*y2* - *y1、* 図形の幅は*x2* - *x1*です。

外接する四角形の幅または高さが 0 の場合、楕円は描画されません。

## <a name="cdcenddoc"></a><a name="enddoc"></a>CDC::エンドドック

[StartDoc](#startdoc)メンバー関数の呼び出しによって開始された印刷ジョブを終了します。

```
int EndDoc();
```

### <a name="return-value"></a>戻り値

関数が成功した場合は 0 以上、エラーが発生した場合は負の値。

### <a name="remarks"></a>解説

このメンバー関数は ENDDOC プリンター・エスケープを置き換え、印刷ジョブが正常に終了した直後に呼び出す必要があります。

アプリケーションで印刷エラーまたは印刷操作の取り消しが発生した場合は、 `EndDoc` [AbortDoc](#abortdoc)を使用して操作を終了しないでください。 GDI は、エラー値を返す前に、操作を自動的に終了します。

この関数は、メタファイル内で使用しないでください。

### <a name="example"></a>例

  [CDC::StartDoc](#startdoc)の例を参照してください。

## <a name="cdcendpage"></a><a name="endpage"></a>CDC::エンドページ

アプリケーションがページへの書き込みを完了したことをデバイスに通知します。

```
int EndPage();
```

### <a name="return-value"></a>戻り値

関数が成功した場合は 0 以上、エラーが発生した場合は負の値。

### <a name="remarks"></a>解説

このメンバー関数は、通常、デバイス ドライバーに新しいページへの進み方向を指示するために使用されます。

このメンバー関数は、NEWFRAME プリンター・エスケープを置き換えます。 NEWFRAME とは異なり、この関数はページを印刷した後に常に呼び出されます。

### <a name="example"></a>例

  [CDC::StartDoc](#startdoc)の例を参照してください。

## <a name="cdcendpath"></a><a name="endpath"></a>CDC::エンドパス

パス ブラケットを閉じ、ブラケットで定義されたパスをデバイス コンテキストに選択します。

```
BOOL EndPath();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="example"></a>例

  [CDC::BeginPath](#beginpath)の例を参照してください。

## <a name="cdcenumobjects"></a><a name="enumobjects"></a>CDC::列挙オブジェクト

デバイス コンテキストで使用できるペンとブラシを列挙します。

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>パラメーター

*オブジェクトタイプ*<br/>
オブジェクトの種類を指定します。 値はOBJ_BRUSHまたはOBJ_PENできます。

*lpfn*<br/>
アプリケーションが指定したコールバック関数のプロシージャ インスタンス アドレスです。 以下の「解説」を参照してください。

*lpData*<br/>
アプリケーションが指定したデータへのポイント。 データは、オブジェクト情報とともにコールバック関数に渡されます。

### <a name="return-value"></a>戻り値

[コールバック関数](callback-functions-used-by-mfc.md#enum_objects)によって返される最後の値を指定します。 その意味はユーザー定義です。

### <a name="remarks"></a>解説

特定の型のオブジェクトごとに、渡すコールバック関数がそのオブジェクトの情報を使用して呼び出されます。 オブジェクトがなくなったり、コールバック関数が 0 を返すまで、システムはコールバック関数を呼び出します。

Visual C++ の新機能を使用すると、通常の関数をに渡される関数として`EnumObjects`使用できます。 渡される`EnumObjects`アドレスは **、EXPORT**と Pascal 呼び出し規約でエクスポートされた関数へのポインターです。 プロテクト モード アプリケーションでは、この関数を作成する必要はありません、 関数を使用して、関数を作成する必要はありません。

また、アプリケーションのモジュール定義ファイル内の**EXPORTS**ステートメントで関数名をエクスポートする必要はありません。 代わりに **、EXPORT**関数修飾子を使用できます。

**コールバックエクスポート**関数 **(LPSTR** **、LPSTR)。**

コンパイラが名前でエイリアスを使用せずにエクスポートするための適切なエクスポート レコードを生成するようにします。 これはほとんどのニーズに適しています。 序数による関数のエクスポートやエクスポートの別名変更など、特殊なケースがある場合は、モジュール定義ファイルで**EXPORTS**ステートメントを使用する必要があります。

Microsoft Foundation プログラムをコンパイルする場合は、通常、/GA および /GEs コンパイラ オプションを使用します。 /Gw コンパイラ オプションは、Microsoft Foundation クラスでは使用されません。 (Windows 関数`MakeProcInstance`を使用する場合は、返された関数ポインターを FARPROC からこの API で必要な型に明示的にキャストする必要があります。コールバック登録インターフェイスはタイプ セーフになりました (特定のコールバックに対して適切な種類の関数を指す関数ポインタを渡す必要があります)。

また、すべてのコールバック関数は、コールバック境界を越えて例外をスローすることはできないので、Windows に戻る前に Microsoft Foundation の例外をトラップする必要があることに注意してください。 例外の詳細については、記事「[例外](../../mfc/exception-handling-in-mfc.md)」を参照してください。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

## <a name="cdcescape"></a><a name="escape"></a>CDC::エスケープ

このメンバー関数は、Win32 プログラミングでは実質的に廃止されています。

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>パラメーター

*nエスケープ*<br/>
実行するエスケープ関数を指定します。

エスケープ関数の完全な一覧については、Windows SDK の[エスケープ](/windows/win32/api/wingdi/nf-wingdi-escape)を参照してください。

*nカウント*<br/>
*lpszInData*によって指されるデータのバイト数を指定します。

*データ*<br/>
このエスケープに必要な入力データ構造を指します。

*データを取得します。*<br/>
このエスケープから出力を受け取る構造体を指します。 データが返されない場合 *、lpOutData*パラメーターは NULL です。

*入力サイズ*<br/>
*lpszInputData*パラメーターによって指されるデータのバイト数を指定します。

*データを入力します。*<br/>
指定されたエスケープに必要な入力構造体を指します。

*サイズを指定します。*<br/>
*lpszOutputData*パラメーターによってポイントされるデータのバイト数を指定します。

*データ*<br/>
このエスケープから出力を受け取る構造体を指します。 データが返されない場合、このパラメーターは NULL にする必要があります。

### <a name="return-value"></a>戻り値

関数が正常に実行された場合は、実装のみをチェックする QUERYESCSUPPORT エスケープを除いて、正の値が返されます。 エスケープが実装されていない場合は、ゼロが返されます。 エラーが発生した場合は負の値が返されます。 一般的なエラー値は次のとおりです。

- SP_ERROR一般エラーです。

- SP_OUTOFDISKスプールに使用できるディスク領域が不足しており、これ以上使用可能な領域はありません。

- SP_OUTOFMEMORY スプールに使用できるメモリが不足しています。

- SP_USERABORT ユーザーは印刷マネージャーを使用してジョブを終了しました。

### <a name="remarks"></a>解説

元のプリンターエスケープのうち、Win32 アプリケーションでは QUERYESCSUPPORT のみがサポートされています。 その他のプリンタエスケープはすべて廃止され、16 ビット アプリケーションとの互換性を保つためにのみサポートされています。

Win32 プログラミングでは、`CDC`対応するプリンターエスケープに取って代わる 6 つのメンバー関数が提供されるようになりました。

- [CDC::アボートドック](#abortdoc)

- [CDC::エンドドック](#enddoc)

- [CDC::エンドページ](#endpage)

- [CDC::セットアボート・プロセス](#setabortproc)

- [CDC::スタートドック](#startdoc)

- [CDC::スタートページ](#startpage)

さらに[、CDC::GetDeviceCaps](#getdevicecaps)は、他のプリンターエスケープに優先する Win32 インデックスをサポートしています。 詳細については、Windows SDK の[「デバイスキャップの取得](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps)」を参照してください。

このメンバー関数を使用すると、アプリケーションは GDI を通じて直接使用できない特定のデバイスの機能にアクセスできます。

アプリケーションで定義済みのエスケープ値を使用する場合は、最初のバージョンを使用します。 アプリケーションでプライベートエスケープ値を定義する場合は、2 番目のバージョンを使用します。 2 番目のバージョンの詳細については、Windows SDK の[「ExtEscape」](/windows/win32/api/wingdi/nf-wingdi-extescape)を参照してください。

## <a name="cdcexcludecliprect"></a><a name="excludecliprect"></a>CDC::クリップレックを除外

既存のクリッピング領域から指定された四角形を引いた新しいクリッピング領域を作成します。

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
四角形の左上隅の論理 x 座標を指定します。

*y1*<br/>
四角形の左上隅の論理 y 座標を指定します。

*x2*<br/>
四角形の右下隅の論理 x 座標を指定します。

*y2*<br/>
四角形の右下隅の論理 y 座標を指定します。

*Lprect*<br/>
四角形を指定します。 `CRect`オブジェクトにすることもできます。

### <a name="return-value"></a>戻り値

新しいクリップ領域の種類を指定します。 次のいずれかの値を指定できます。

- 複合領域 領域に重複する境界線があります。

- エラー 領域は作成されません。

- 領域が空です。

- シンプル領域 領域に重複する境界線はありません。

### <a name="remarks"></a>解説

*x2* - *x1*の絶対値で指定される四角形の幅は、32,767 単位以下にする必要があります。 この制限は、長方形の高さにも適用されます。

## <a name="cdcexcludeupdatergn"></a><a name="excludeupdatergn"></a>CDC::除外更新プログラム

ウィンドウ内の更新された領域を、オブジェクトに関連付けられたクリップ領域から除外することにより、ウィンドウの無効な領域内で`CDC`描画を行わないようにします。

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>パラメーター

*Pwnd*<br/>
ウィンドウを更新するウィンドウ オブジェクトへのポイント。

### <a name="return-value"></a>戻り値

除外される領域の種類。 次のいずれかの値を指定できます。

- 複合領域 領域に重複する境界線があります。

- エラー 領域は作成されません。

- 領域が空です。

- シンプル領域 領域に重複する境界線はありません。

## <a name="cdcextfloodfill"></a><a name="extfloodfill"></a>CDC::スプラッドフィル

表示サーフェスの領域を現在のブラシで塗りつぶします。

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
塗りつぶしが始まるポイントの論理 x 座標を指定します。

*Y*<br/>
塗りつぶしが始まるポイントの論理 y 座標を指定します。

*Crcolor*<br/>
塗りつぶす境界または領域の色を指定します。 *crColor*の解釈は*nFillType*の値によって異なります。

*nフィルタイプ*<br/>
実行する洪水の塗りつぶしの種類を指定します。 次のいずれかの値を指定する必要があります。

- [塗りつぶしの境界線] 塗りつぶし領域は *、crColor*で指定された色で囲まれます。 このスタイルは、 によって実行される`FloodFill`塗りつぶしと同じです。

- [洪水]塗りつぶし領域は *、crColor*で指定された色で定義されます。 色が見つかった場合、充填は全方向に外側に続きます。 このスタイルは、多色の境界を持つ領域を塗りつぶす場合に便利です。

### <a name="return-value"></a>戻り値

関数が成功した場合は 0 以外の値を返します。それ以外の場合、指定したポイントが*crColor*で指定された境界色を持つ場合 (FLOODFILLBORDER が要求された場合)、指定されたポイントが*crColor*で指定された色を持っていない場合 (FLOODFILLSURFACE が要求された場合)、またはポイントがクリッピング領域の外にある場合は 0。

### <a name="remarks"></a>解説

このメンバー関数は、 `FloodFill` *nFillType*で塗りつぶしの種類を指定できるため、柔軟性が高くなります。

*nFillType が*[塗りつぶしの境界線] に設定されている場合、領域は*crColor*で指定された色で完全に境界付けされていると見なされます。 関数は *、x*と*y*で指定されたポイントから始まり、色の境界まですべての方向に塗りつぶされます。

*nFillType*が FLOODFILLSURFACE に設定されている場合、関数は*x*と*y*で指定されたポイントから始まり、すべての方向に続き *、crColor*で指定された色を含むすべての隣接領域を塗りつぶします。

ラスターディスプレイ テクノロジをサポートするメモリ デバイス コンテキストとデバイスのみが`ExtFloodFill`サポートされます。 詳細については、メンバー関数を[参照](#getdevicecaps)してください。

## <a name="cdcexttextout"></a><a name="exttextout"></a>CDC::テキストアウト

現在選択されているフォントを使用して、四角形の領域内に文字列を書き込みます。

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
指定した文字列の最初の文字の文字セルの論理 x 座標を指定します。

*Y*<br/>
指定した文字列の最初の文字の文字セルの先頭の論理 y 座標を指定します。

*nオプション*<br/>
四角形の種類を指定します。 このパラメーターは、いずれか、両方、または次の値のどちらでも指定できます。

- ETO_CLIPPEDテキストが四角形にクリップされることを指定します。

- ETO_OPAQUE現在の背景色が四角形を塗りつぶします。 (現在の背景色を設定し、クエリを実行するには[、SetBkColor](#setbkcolor)と[GetBkColor](#getbkcolor)メンバー関数を使用します)。

*Lprect*<br/>
四角形のサイズを決定する[RECT](/windows/win32/api/windef/ns-windef-rect)構造体へのポインター。 このパラメーターは NULL にすることができます。 このパラメータに[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクトを渡すこともできます。

*文字列*<br/>
描画する指定された文字列へのポイント。 このパラメーターに[CString](../../atl-mfc-shared/reference/cstringt-class.md)オブジェクトを渡すこともできます。

*nカウント*<br/>
文字列の文字数を指定します。

*幅*<br/>
隣接する文字セルの原点間の距離を示す値の配列へのポイント。 例えば *、lpDxWidths*[ *i*] 論理ユニットは、文字セル*i*と文字セル*i* + 1 の起点を区切ります。 *lpDxWidths*が NULL`ExtTextOut`の場合は、文字間のデフォルトの間隔を使用します。

*Str*<br/>
描画`CString`される指定された文字を含むオブジェクト。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

矩形領域は不透明 (現在の背景色で塗りつぶされている) 場合があり、クリッピング領域にすることができます。

*nOptions が*0 で *、lpRect*が NULL の場合、関数は四角形の領域を使用せずにデバイス コンテキストにテキストを書き込みます。 既定では、関数は現在位置を使用することも、更新することもありません。 アプリケーションが`ExtTextOut`呼び出すときに現在の位置を更新する必要がある場合、アプリケーション`CDC`は、TA_UPDATECPに設定された*nFlags*を使用してメンバー関数[SetTextAlign](#settextalign)を呼び出すことができます。 このフラグが設定されている場合、Windows は後続の呼び出し`ExtTextOut`で*x*と*y*を無視し、代わりに現在の位置を使用します。 アプリケーションがTA_UPDATECPを使用して現在の位置を更新`ExtTextOut`する場合、現在の位置を前のテキスト行の終わり、または*lpDxWidths*が指す配列の最後の要素で指定された位置のいずれか大きい方に設定します。

## <a name="cdcfillpath"></a><a name="fillpath"></a>CDC::フィルパス

現在のパスで開いている図形をすべて閉じ、現在のブラシモードとポリゴン塗りつぶしモードを使用してパスの内部を塗りつぶします。

```
BOOL FillPath();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

内部が埋め込まれた後、パスはデバイス コンテキストから破棄されます。

## <a name="cdcfillrect"></a><a name="fillrect"></a>CDC::フィルレック

指定したブラシを使用して指定された四角形を塗りつぶします。

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>パラメーター

*Lprect*<br/>
塗りつぶす四角形の論理座標を格納する[RECT](/windows/win32/api/windef/ns-windef-rect)構造体へのポインター。 このパラメータに[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクトを渡すこともできます。

*pブラシ*<br/>
四角形を塗りつぶすために使用するブラシを識別します。

### <a name="remarks"></a>解説

関数は、左と上の境界線を含む完全な四角形を塗りつぶしますが、右と下の境界線は塗りつぶされません。

ブラシは[、CBrush](../../mfc/reference/cbrush-class.md)メンバー関数を使用して作成する必要があります、 [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush)Cブラシ`GetStockObject`のメンバー関数[CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush)[を作成します。](../../mfc/reference/cbrush-class.md#createhatchbrush)

指定された四角形を塗`FillRect`りつぶすときは、四角形の右側と下側は含まれません。 GDI は、現在のマッピング モードに関係なく、右の列と下の行まで四角形を塗りつぶしますが、含まれません。 `FillRect`は、指定された四角形`top`の`bottom` `left`、、、、および 、の`right`各メンバーの値を比較します。 以下`bottom`の場合、`top`または が 以下の`right`場合、または`left`以下の場合、四角形は描画されません。

`FillRect`は[CDC に](#fillsolidrect)似ています。ただし、`FillRect`ブラシを使用するため、単色、ディザカラー、ハッチ ブラシ、またはパターンで四角形を塗りつぶすことができます。 `FillSolidRect`は単色のみを使用します (COLORREF パラメーターで示されます)。 `FillRect`通常は、 より`FillSolidRect`遅くなります。

## <a name="cdcfillrgn"></a><a name="fillrgn"></a>CDC::フィルルグン

*pRgn*で指定された領域を*pBrush*で指定されたブラシで塗りつぶします。

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>パラメーター

*Prgn*<br/>
塗りつぶす領域へのポインター。 指定された領域の座標は、論理単位で指定されます。

*pブラシ*<br/>
領域を塗りつぶすために使用するブラシを識別します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

この`CBrush`ブラシは、 `CreateHatchBrush`、 、 `CreatePatternBrush`、`CreateSolidBrush`または によって取得されて作成される必要`GetStockObject`があります。

### <a name="example"></a>例

  [CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn)の例を参照してください。

## <a name="cdcfillsolidrect"></a><a name="fillsolidrect"></a>CDC::フィルソリッドレック

指定した四角形を指定された純色で塗りつぶします。

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>パラメーター

*Lprect*<br/>
外接する四角形を指定します (論理単位)。 [RECT](/windows/win32/api/windef/ns-windef-rect)データ構造体へのポインターまたはこのパラメーターのオブジェクトのいずれかを`CRect`渡すことができます。

*clr*四角形を塗りつぶすために使用する色を指定します。

*X*<br/>
四角形の左上隅の論理 x 座標を指定します。

*Y*<br/>
移動先の四角形の左上隅の論理 y 座標を指定します。

*Cx*<br/>
四角形の幅を指定します。

*Cy*<br/>
四角形の高さを指定します。

### <a name="remarks"></a>解説

`FillSolidRect`は[CDC:::FillRect](#fillrect)と非常によく似ています。ただし、`FillSolidRect`単色 (COLORREF パラメーターで示される)`FillRect`のみを使用しますが、ブラシを使用して、単色、ディザカラー、ハッチ ブラシ、またはパターンで四角形を塗りつぶすことができます。 `FillSolidRect`通常より高速です`FillRect`。

> [!NOTE]
> を呼び`FillSolidRect`出すと、[以前 SetBkColor](#setbkcolor)を使用して設定された背景色が*clr*で示された色に設定されます。

## <a name="cdcflattenpath"></a><a name="flattenpath"></a>CDC::フラットパス

選択したパス内のカーブを現在のデバイス コンテキストに変換し、各曲線を一連の線に変換します。

```
BOOL FlattenPath();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

## <a name="cdcfloodfill"></a><a name="floodfill"></a>CDC::洪水フィル

表示サーフェスの領域を現在のブラシで塗りつぶします。

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
塗りつぶしが始まるポイントの論理 x 座標を指定します。

*Y*<br/>
塗りつぶしが始まるポイントの論理 y 座標を指定します。

*Crcolor*<br/>
境界の色を指定します。

### <a name="return-value"></a>戻り値

関数が成功した場合は 0 以外の値を返します。それ以外の場合は 0 が返されます、塗りつぶしが完了できなかった場合、指定したポイントが*crColor*で指定された境界色を持っているか、ポイントがクリッピング領域の外側にあります。

### <a name="remarks"></a>解説

領域は *、 crColor*で指定された境界と見なされます。 関数`FloodFill`は *、x*と*y*で指定された点から始まり、色の境界まですべての方向に続きます。

メモリ デバイス コンテキストとラスターディスプレイ テクノロジをサポートするデバイスのみがメンバー`FloodFill`関数をサポートします。 RC_BITBLT機能については、メンバー関数を`GetDeviceCaps`参照してください。

この`ExtFloodFill`関数は、同様の機能を提供しますが、柔軟性は高くなります。

## <a name="cdcframerect"></a><a name="framerect"></a>CDC::フレームレック

*lpRect*で指定された四角形の周囲に境界線を描画します。

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>パラメーター

*Lprect*<br/>
矩形の左上隅と右下隅の論理座標を含む[RECT](/windows/win32/api/windef/ns-windef-rect)構造体または[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクトへのポインター。 このパラメータにオブジェクトを`CRect`渡すこともできます。

*pブラシ*<br/>
四角形のフレーミングに使用するブラシを識別します。

### <a name="remarks"></a>解説

この関数は、指定されたブラシを使用して境界線を描画します。 境界線の幅と高さは、常に 1 論理単位です。

四角形`bottom`の座標が`top`以下の場合、または が 以下`right`の場合、四`left`角形は描画されません。

描画される`FrameRect`境界線は、メンバー関数が同じ座標を`Rectangle`使用して描画する境界線と同じ位置にあります`Rectangle`(1 論理単位幅のペンを使用している場合)。 四角形の内部は によって埋め`FrameRect`られていない。

## <a name="cdcframergn"></a><a name="framergn"></a>CDC::フレームルグン

pBrush で指定されたブラシを使用して *、pRgn*で*pBrush*指定された領域の周囲に境界線を描画します。

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>パラメーター

*Prgn*<br/>
境界線で`CRgn`囲む領域を識別するオブジェクトへのポイント。 指定された領域の座標は、論理単位で指定されます。

*pブラシ*<br/>
境界線の`CBrush`描画に使用するブラシを識別するオブジェクトへのポイント。

*n幅*<br/>
デバイス単位での垂直ブラシ ストロークの境界線の幅を指定します。

*nHeight*<br/>
水平ブラシ ストロークの境界線の高さをデバイス単位で指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="example"></a>例

  [CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn)の例を参照してください。

## <a name="cdcfromhandle"></a><a name="fromhandle"></a>CDC::ハンドルから

デバイス コンテキストへのハンドル`CDC`が与えられた場合、オブジェクトへのポインターを返します。

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>パラメーター

*Hdc*<br/>
Windows デバイス コンテキストへのハンドルを格納します。

### <a name="return-value"></a>戻り値

ポインターは一時的なポインターである可能性があり、すぐに使用する以外に格納しないでください。

### <a name="remarks"></a>解説

`CDC` オブジェクトがハンドルに関連付けられていない場合は、一時的な `CDC` オブジェクトが生成され、関連付けられます。

### <a name="example"></a>例

  [次](../../mfc/reference/cprintdialog-class.md#getprinterdc)の例を参照してください。

## <a name="cdcgetarcdirection"></a><a name="getarcdirection"></a>CDC::ゲットアークディレクション

デバイス コンテキストの現在の円弧方向を返します。

```
int GetArcDirection() const;
```

### <a name="return-value"></a>戻り値

正常に実行された場合は、現在の円弧の方向を指定します。 有効な戻り値を次に示します。

- AD_COUNTERCLOCKWISE円弧と長方形を反時計回りに描画します。

- AD_CLOCKWISE円弧と長方形を時計回りに描画します。

エラーが発生した場合、戻り値は 0 です。

### <a name="remarks"></a>解説

円弧関数と四角形関数では、円弧の方向を使用します。

## <a name="cdcgetaspectratiofilter"></a><a name="getaspectratiofilter"></a>CDC::アスペクト比フィルター

現在の縦横比フィルターの設定を取得します。

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>戻り値

現在`CSize`の縦横比フィルターで使用されるアスペクト比を表すオブジェクト。

### <a name="remarks"></a>解説

アスペクト比は、デバイスのピクセル幅と高さによって形成される比率です。 デバイスのアスペクト比に関する情報は、フォントの作成、選択、表示に使用されます。 Windows には、特定の縦横比に対応するように設計されたフォントを、利用可能なすべてのフォントから選択するための特殊なフィルタ(縦横比フィルタ)が用意されています。 フィルターは、メンバー関数で指定された縦`SetMapperFlags`横比を使用します。

## <a name="cdcgetbkcolor"></a><a name="getbkcolor"></a>CDC::ゲットブレクカラー

現在の背景色を返します。

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>戻り値

RGB カラー値。

### <a name="remarks"></a>解説

背景モードが OPAQUE の場合、システムは背景色を使用して、スタイル付きの線分のギャップ、ブラシのハッチング線の間のギャップ、および文字セルの背景を塗りつぶします。 また、カラーとモノクロのデバイス コンテキスト間でビットマップを変換する際にも、背景色が使用されます。

## <a name="cdcgetbkmode"></a><a name="getbkmode"></a>CDC::ゲットBkモード

バックグラウンド モードを返します。

```
int GetBkMode() const;
```

### <a name="return-value"></a>戻り値

現在のバックグラウンド モードで、OPAQUE または透明にすることができます。

### <a name="remarks"></a>解説

背景モードでは、テキスト、ハッチングブラシ、または実線でないペンスタイルを描画する前に、描画サーフェイス上の既存の背景色を削除するかどうかを定義します。

## <a name="cdcgetboundsrect"></a><a name="getboundsrect"></a>CDC::ゲットバウンドレクト

指定されたデバイス コンテキストの現在の累積外接する四角形を返します。

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>パラメーター

*を指定します。*<br/>
現在の外接する四角形を受け取るバッファーへのポインター。 四角形は論理座標で返されます。

*フラグ*<br/>
外接する四角形を返した後にクリアするかどうかを指定します。 このパラメーターは 0 にするか、または次の値に設定する必要があります。

- DCB_RESET外接する四角形が返された後に強制的にクリアされます。

### <a name="return-value"></a>戻り値

関数が正常に終了した場合に、外接する四角形の現在の状態を指定します。 次の値を組み合わせて使用できます。

- DCB_ACCUMULATE外接する四角形の累積が発生しています。

- DCB_RESET外接する四角形が空です。

- DCB_SET外接する四角形が空ではありません。

- DCB_ENABLE境界累積がオンです。

- DCB_DISABLE バウンディング累積がオフです。

## <a name="cdcgetbrushorg"></a><a name="getbrushorg"></a>CDC::ゲットブラシオルグ

デバイス コンテキストに対して現在選択されているブラシの原点 (デバイス単位) を取得します。

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>戻り値

[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)オブジェクトとしてのブラシの現在の原点 (デバイス単位)。

### <a name="remarks"></a>解説

初期のブラシ原点は、クライアント領域の (0,0) です。 戻り値は、デスクトップ ウィンドウの原点を基準にして、このポイントをデバイス単位で指定します。

## <a name="cdcgetcharacterplacement"></a><a name="getcharacterplacement"></a>CDC::文字配置

文字列に関するさまざまな情報を取得します。

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>パラメーター

*文字列*<br/>
処理する文字列へのポインター。

*nカウント*<br/>
文字列の長さを指定します。 ANSI バージョンの場合は BYTE カウント、Unicode 関数の場合は WORD カウントです。 詳細については、「[文字配置を取得する](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)」を参照してください。

*nマックスエクステント*<br/>
処理する文字列の最大エクステントを論理単位で指定します。 このエクステントを超えて処理された文字列は無視されます。 並べ替えやグリフの配列に必要な演算は、範囲に含まれている文字だけに適用されます。 このパラメーターは *、dwFlags*パラメーターで GCP_MAXEXTENT値が指定されている場合にのみ使用されます。 入力文字列を処理するときは、エクステントの合計が最大値を超えない限り、各文字と文字のエクステントが出力、エクステント、および他の配列に追加されます。 制限に達すると、処理は停止します。

*lpResults*<br/>
関数の結果を受け取る[GCP_Results](/windows/win32/api/wingdi/ns-wingdi-gcp_resultsw)構造体へのポインター。

*dwFlags*<br/>
必要な配列に挿入される文字列の処理方法を指定します。 このパラメーターには[、GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)トピックの*dwFlags*セクションに示されている値の 1 つ以上を指定できます。

*Str*<br/>
処理する[CString](../../atl-mfc-shared/reference/cstringt-class.md)オブジェクトへのポインター。

### <a name="return-value"></a>戻り値

関数が正常に終了した場合は、文字列の幅と高さを論理単位で返します。

関数が失敗した場合は、0 を返します。

### <a name="remarks"></a>解説

このメンバー関数は、Windows SDK で説明されているように、関数[の機能](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)をエミュレートします。

## <a name="cdcgetcharabcwidths"></a><a name="getcharabcwidths"></a>CDC::取得文字ABC幅

現在の TrueType フォントから、指定した範囲内の連続する文字の幅を取得します。

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>パラメーター

*nファーストチャー*<br/>
文字幅が返される現在のフォントの文字範囲の最初の文字を指定します。

*ラストチャー*<br/>
文字幅が返される現在のフォントの文字範囲の最後の文字を指定します。

*lpabc*<br/>
関数が返されるときに文字幅を受け取る[ABC](/windows/win32/api/wingdi/ns-wingdi-abc)構造体の配列を指します。 この配列には *、nFirstChar* `ABC`および*nLastChar*パラメーターで指定された範囲内の文字と同じ数の構造体が含まれている必要があります。

*lpABCF*<br/>
関数が戻るときに文字幅を受け取る[、ABCFLOAT](/windows/win32/api/wingdi/ns-wingdi-abcfloat)構造体の配列を持つアプリケーション提供のバッファーを指します。 この関数によって返される幅は IEEE 浮動小数点形式です。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

幅は論理単位で返されます。 この関数は TrueType フォントでのみ成功します。

TrueType ラスタライザは、特定のポイント サイズが選択された後に"ABC"文字間隔を提供します。 「A」の間隔は、グリフを配置する前に現在位置に追加される距離です。 "B" の間隔は、グリフの黒い部分の幅です。 "C" の間隔は、グリフの右側の空白を考慮して現在の位置に追加されます。 アドバンス幅の合計はA + B + Cによって与えられます。

メンバー関数`GetCharABCWidths`が文字の負の "A" または "C" の幅を取得すると、その文字にはアンダーハングまたはオーバーハングが含まれます。

ABC の幅をフォントデザイン単位に変換するには、アプリケーションは、高さ[(LOGFONT](/windows/win32/api/wingdi/ns-wingdi-logfontw)構造体`ntmSizeEM`の`lfHeight`メンバーで指定されている) が[NEWTEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-newtextmetricw)構造体のメンバーに格納されている値と等しいフォントを作成する必要があります。 (メンバーの`ntmSizeEM`値は、[列挙フォントのWindows](/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw)関数を呼び出すことによって取得できます。

既定の文字の ABC の幅は、現在選択されているフォントの範囲外の文字に使用されます。

TrueType 以外のフォントの文字の幅を取得するには、アプリケーションで[GetCharWidth](/windows/win32/api/wingdi/nf-wingdi-getcharwidthw) Windows 関数を使用する必要があります。

## <a name="cdcgetcharabcwidthsi"></a><a name="getcharabcwidthsi"></a>CDC::取得チャルアブサシ

現在の TrueType フォントから、指定された範囲の連続するグリフ インデックスの幅を論理単位で取得します。

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>パラメーター

*ギファースト*<br/>
現在のフォントから連続するグリフ インデックスのグループ内の最初のグリフ インデックスを指定します。 このパラメーターは *、pgi*パラメーターが NULL の場合にのみ使用されます。

*Cgi*<br/>
グリフ インデックスの数を指定します。

*Pgi*<br/>
グリフ インデックスを含む配列へのポインター。 値が NULL の場合は、代わりに*giFirst*パラメーターが使用されます。 *cgi*パラメーターは、この配列内のグリフインデックスの数を指定します。

*lpabc*<br/>
文字幅を受け取る[ABC](/windows/win32/api/wingdi/ns-wingdi-abc)構造体の配列へのポインター。 この配列には *、cgi*パラメータ`ABC`で指定されたグリフインデックスと同じ数の構造体が含まれている必要があります。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

このメンバー関数は、Windows SDK で説明されているように、関数[GetCharABCWidthsI](/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsi)の機能をエミュレートします。

## <a name="cdcgetcharwidth"></a><a name="getcharwidth"></a>CDC::取得文字幅

入力デバイス コンテキストを使用して`m_hAttribDC`、現在のフォントから連続した文字グループ内の個々の文字の幅を取得します。

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>パラメーター

*nファーストチャー*<br/>
現在のフォントの連続する文字グループの最初の文字を指定します。

*ラストチャー*<br/>
現在のフォントの連続する文字グループの最後の文字を指定します。

*バッファバッファ*<br/>
現在のフォントの連続する文字グループの幅の値を受け取るバッファーへのポイント。

*バッファバッファ*<br/>
文字幅を受け取るバッファーへのポイント。 返される幅は 32 ビット IEEE 浮動小数点形式です。 (幅は文字の基本線に沿って計測されます。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

たとえば *、nFirstChar*が文字 'a' を識別し *、nLastChar*が文字 'z' を識別する場合、関数はすべての小文字の幅を取得します。

この関数は *、lpBuffer*が指すバッファに値を格納します。 このバッファーは、すべての幅を保持するのに十分な大きさである必要があります。 つまり、指定された例には少なくとも 26 個のエントリが必要です。

連続する文字グループ内の文字が特定のフォントに存在しない場合は、デフォルトの文字の幅の値が割り当てられます。

## <a name="cdcgetcharwidthi"></a><a name="getcharwidthi"></a>CDC::ゲットチャル幅I

現在のフォントから指定された範囲内の連続するグリフ インデックスの幅を論理座標で取得します。

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>パラメーター

*ギファースト*<br/>
現在のフォントから連続するグリフ インデックスのグループ内の最初のグリフ インデックスを指定します。 このパラメーターは *、pgi*パラメーターが NULL の場合にのみ使用されます。

*Cgi*<br/>
グリフ インデックスの数を指定します。

*Pgi*<br/>
グリフ インデックスを含む配列へのポインター。 値が NULL の場合は、代わりに*giFirst*パラメーターが使用されます。 *cgi*パラメーターは、この配列内のグリフインデックスの数を指定します。

*バッファバッファ*<br/>
幅を受け取るバッファーへのポインター。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

このメンバー関数は、Windows SDK で説明されているように、関数[GetCharWidthI](/windows/win32/api/wingdi/nf-wingdi-getcharwidthi)の機能をエミュレートします。

## <a name="cdcgetclipbox"></a><a name="getclipbox"></a>CDC::ゲットクリップボックス

現在のクリップ境界の周りの最も狭い境界の四角形の寸法を取得します。

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>パラメーター

*Lprect*<br/>
矩形の寸法を受け取る[RECT](/windows/win32/api/windef/ns-windef-rect)構造体または[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクトへのポインター。

### <a name="return-value"></a>戻り値

クリッピング領域のタイプ。 次のいずれかの値を指定できます。

- コンプレックス領域クリッピング領域に境界線が重なっています。

- エラー デバイス コンテキストが無効です。

- NULLREGION クリッピング領域が空です。

- シンプル領域クリッピング領域には、重なり合う境界線はありません。

### <a name="remarks"></a>解説

サイズは *、 lpRect*が指すバッファにコピーされます。

## <a name="cdcgetcoloradjustment"></a><a name="getcoloradjustment"></a>CDC::色調整

デバイス コンテキストの色調整値を取得します。

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>パラメーター

*調整する*<br/>
色調整の値を受け取る[色調整](/windows/win32/api/wingdi/ns-wingdi-coloradjustment)データ構造体へのポイント。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

## <a name="cdcgetcurrentbitmap"></a><a name="getcurrentbitmap"></a>CDC::現在のビットマップを取得します。

現在選択`CBitmap`されているオブジェクトへのポインターを返します。

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>戻り値

成功した場合`CBitmap`はオブジェクトへのポインター。それ以外の場合は NULL。

### <a name="remarks"></a>解説

このメンバー関数は、一時オブジェクトを返す場合があります。

## <a name="cdcgetcurrentbrush"></a><a name="getcurrentbrush"></a>CDC::ゲットカレントブラシ

現在選択`CBrush`されているオブジェクトへのポインターを返します。

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>戻り値

成功した場合`CBrush`はオブジェクトへのポインター。それ以外の場合は NULL。

### <a name="remarks"></a>解説

このメンバー関数は、一時オブジェクトを返す場合があります。

## <a name="cdcgetcurrentfont"></a><a name="getcurrentfont"></a>CDC::現在のフォントを取得します。

現在選択`CFont`されているオブジェクトへのポインターを返します。

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>戻り値

成功した場合`CFont`はオブジェクトへのポインター。それ以外の場合は NULL。

### <a name="remarks"></a>解説

このメンバー関数は、一時オブジェクトを返す場合があります。

## <a name="cdcgetcurrentpalette"></a><a name="getcurrentpalette"></a>CDC::現在のパレットを取得します。

現在選択`CPalette`されているオブジェクトへのポインターを返します。

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>戻り値

成功した場合`CPalette`はオブジェクトへのポインター。それ以外の場合は NULL。

### <a name="remarks"></a>解説

このメンバー関数は、一時オブジェクトを返す場合があります。

## <a name="cdcgetcurrentpen"></a><a name="getcurrentpen"></a>CDC::ゲットカレントペン

現在選択`CPen`されているオブジェクトへのポインターを返します。

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>戻り値

成功した場合`CPen`はオブジェクトへのポインター。それ以外の場合は NULL。

### <a name="remarks"></a>解説

このメンバー関数は、一時オブジェクトを返す場合があります。

## <a name="cdcgetcurrentposition"></a><a name="getcurrentposition"></a>CDC::現在の位置を取得します。

現在の位置を取得します (論理座標)。

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>戻り値

オブジェクトとしての現在の`CPoint`位置。

### <a name="remarks"></a>解説

現在の位置は、メンバー関数で`MoveTo`設定できます。

## <a name="cdcgetdcbrushcolor"></a><a name="getdcbrushcolor"></a>CDC::ゲットDCブラシカラー

現在のブラシの色を取得します。

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>戻り値

関数が成功した場合、戻り値は現在のブラシカラーの[COLORREF](/windows/win32/gdi/colorref)値です。

関数が失敗した場合、戻り値は CLR_INVALID です。

### <a name="remarks"></a>解説

このメンバー関数は、Windows SDK で説明されているように、関数[GetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-getdcbrushcolor)の機能をエミュレートします。

## <a name="cdcgetdcpencolor"></a><a name="getdcpencolor"></a>CDC::ゲットDCペンカラー

現在のペンの色を取得します。

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>戻り値

関数が成功した場合、戻り値は現在のペンの色の[COLORREF](/windows/win32/gdi/colorref)値です。

関数が失敗した場合、戻り値は CLR_INVALID です。

### <a name="remarks"></a>解説

このメンバー関数は、Windows SDK で説明されているように、Win32 関数[GetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-getdcpencolor)を使用します。

## <a name="cdcgetdevicecaps"></a><a name="getdevicecaps"></a>CDC::デバイスキャップ

ディスプレイ デバイスに関するデバイス固有のさまざまな情報を取得します。

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>パラメーター

*nIndex*<br/>
返される情報の種類を指定します。 値の一覧については、Windows SDK の[GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps)を参照してください。

### <a name="return-value"></a>戻り値

関数が正常に実行された場合の、要求された機能の値。

### <a name="example"></a>例

  [次](../../mfc/reference/cprintdialog-class.md#getdefaults)の例を参照してください。

## <a name="cdcgetfontdata"></a><a name="getfontdata"></a>を取得します。

スケーラブルフォント ファイルからフォント メトリック情報を取得します。

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>パラメーター

*dwテーブル*<br/>
返されるメトリック テーブルの名前を指定します。 このパラメーターは、マイクロソフト社が公開する TrueType フォント ファイル仕様に記載されているメトリック テーブルの 1 つです。 このパラメーターが 0 の場合、フォント・ファイルの先頭から情報が取得されます。

*オフセット*<br/>
情報の取得を開始するテーブルの先頭からのオフセットを指定します。 このパラメーターが 0 の場合 *、dwTable*パラメーターで指定された表の先頭から情報が取得されます。 この値がテーブルのサイズ以上の場合は、0`GetFontData`を返します。

*lpData*<br/>
フォント情報を受け取るバッファーへのポイント。 この値が NULL の場合、この関数は*dwTable*パラメーターで指定されたフォント データに必要なバッファーのサイズを返します。

*cbData*<br/>
取得する情報の長さをバイト単位で指定します。 このパラメーターが 0`GetFontData`の場合は *、dwTable*パラメーターで指定されたデータのサイズを返します。

### <a name="return-value"></a>戻り値

関数が正常に実行された場合に *、lpData*が指すバッファーに戻されるバイト数を指定します。それ以外の場合は -1。

### <a name="remarks"></a>解説

取得する情報は、フォント ファイルのオフセットと返す情報の長さを指定することによって識別されます。

アプリケーションは、ドキュメントと共`GetFontData`に TrueType フォントを保存するために、メンバー関数を使用することがあります。 これを行うには、アプリケーションは、フォントを埋め込むことができるかどうかを決定し *、dwTable* *、dwOffset*、*および cbData*パラメーターに 0 を指定して、フォント ファイル全体を取得します。

アプリケーションは[、OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw)構造体のメンバーをチェック`otmfsType`することによって、フォントを埋め込むことができるかどうかを判断できます。 のビット 1`otmfsType`が設定されている場合、フォントの埋め込みは許可されません。 ビット 1 がクリアされている場合、フォントを埋め込むことができます。 ビット 2 が設定されている場合、埋め込みは読み取り専用です。

アプリケーションがこの関数を使用して、非 TrueType フォントの情報を取得しようとすると、メンバー関数`GetFontData`は -1 を返します。

## <a name="cdcgetfontlanguageinfo"></a><a name="getfontlanguageinfo"></a>を取得します。

指定した表示コンテキストで現在選択されているフォントに関する情報を返します。

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>戻り値

戻り値は、現在選択されているフォントの特性を識別します。 使用可能な値の完全な一覧については、「[フォント言語情報の取得](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo)」を参照してください。

### <a name="remarks"></a>解説

このメンバー関数は、Windows SDK で説明されているように、関数[の機能](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo)をエミュレートします。

## <a name="cdcgetglyphoutline"></a><a name="getglyphoutline"></a>CDC::グリフアウトライン

現在のフォントのアウトライン文字のアウトライン 曲線またはビットマップを取得します。

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>パラメーター

*Nchar*<br/>
情報を返す文字を指定します。

*nフォーマット*<br/>
関数が情報を返す形式を指定します。 次のいずれかの値、または 0 を指定できます。

|[値]|意味|
|-----------|-------------|
|GGO_BITMAP|グリフ ビットマップを返します。 関数が戻ると *、lpBuffer*が指すバッファーには、行がダブルワード境界で始まる 1 ビット/ピクセルビットマップが含まれます。|
|GGO_NATIVE|ラスタライザーのネイティブ形式の曲線データポイントを、デバイス単位を使用して返します。 この値を指定すると *、lpmat2*で指定された変換は無視されます。|

*nFormat*の値が 0 の場合、関数は[GLYPHMETRICS](/windows/win32/api/wingdi/ns-wingdi-glyphmetrics)構造体を埋めますが、グリフ アウトライン データは返しません。

*lpgm*<br/>
文字セル内でのグリフの配置を記述する GLYPHMETRICS 構造体へのポイント。

*cbバッファ*<br/>
関数がアウトライン文字に関する情報をコピーするバッファーのサイズを指定します。 この値が 0 で *、nFormat*パラメーターがGGO_BITMAPまたはGGO_NATIVE値である場合、関数はバッファーの必要なサイズを返します。

*バッファバッファ*<br/>
関数がアウトライン文字に関する情報をコピーするバッファーへのポイント。 *nFormat*がGGO_NATIVE値を指定する場合、情報は TTPOLYGON ヘッダーおよび TTPOLY カーブ構造体の形式でコピーされます。 この値が NULL で *、nFormat*がGGO_BITMAPまたはGGO_NATIVE値の場合、関数はバッファーの必要なサイズを返します。

*lpmat2*<br/>
文字の変換行列を含む[MAT2](/windows/win32/api/wingdi/ns-wingdi-mat2)構造体へのポイント。 *nFormat*にGGO_NATIVE値が指定されている場合でも、このパラメーターを NULL にすることはできません。

### <a name="return-value"></a>戻り値

取得した情報に必要なバッファのサイズ (バイト単位) *(cbBuffer*が 0 または*lpBuffer*が NULL の場合)。 それ以外の場合は、関数が成功した場合は正の値、エラーがある場合は -1 です。

### <a name="remarks"></a>解説

アプリケーションは *、lpmat2*が指す構造体に 2 対 2 の変換行列を指定することにより、ビットマップ形式で取得した文字を回転できます。

グリフアウトラインは一連の輪郭として返されます。 各コンターは[、TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader)構造体によって定義され、`TTPOLYCURVE`その後に、それを記述するために必要な数の構造体が続きます。 すべてのポイントは[POINTFX](/windows/win32/api/wingdi/ns-wingdi-pointfx)構造体として返され、相対移動ではなく絶対位置を表します。 [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader)構造体`pfxStart`のメンバーによって指定された開始点は、輪郭のアウトラインが始まるポイントです。 後に続く[TTPOLY カーブ](/windows/win32/api/wingdi/ns-wingdi-ttpolycurve)構造は、ポリライン レコードまたはスプライン レコードのいずれかです。 ポリライン レコードは一連のポイントです。点の間に描かれた線は、文字の輪郭を表します。 スプライン レコードは、TrueType (つまり、2 次 b スプライン) で使用される 2 次曲線を表します。

## <a name="cdcgetgraphicsmode"></a><a name="getgraphicsmode"></a>CDC::グラフィックモードを取得します。

指定したデバイス コンテキストの現在のグラフィックス モードを取得します。

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>戻り値

正常に実行された場合に現在のグラフィックス モードを返します。 このメソッドが返すことができる値の一覧については、「 [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode)」を参照してください。

失敗した場合は 0 を返します。

拡張エラー情報を取得するには[、GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)を呼び出します。

### <a name="remarks"></a>解説

このメソッドは、Windows GDI 関数[を](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode)ラップします。

## <a name="cdcgethalftonebrush"></a><a name="gethalftonebrush"></a>CDC::ゲットハーフトーンブラシ

ハーフトーン ブラシを取得するには、このメンバー関数を呼び出します。

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>戻り値

成功した場合は`CBrush`オブジェクトへのポインター。それ以外の場合は NULL。

### <a name="remarks"></a>解説

ハーフトーン ブラシは、ディザリング パターンを作成するために、前景色と背景色を交互に描画するピクセルを示します。 次に、ハーフトーン ブラシで作成されたディザ パターンの例を示します。

![ディザリングされたペンのストロークの詳細](../../mfc/reference/media/vc318s1.gif "ディザリングされたペンのストロークの詳細")

## <a name="cdcgetkerningpairs"></a><a name="getkerningpairs"></a>CDC::ゲトケニングペア

指定したデバイス コンテキストで現在選択されているフォントの文字カーニング ペアを取得します。

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>パラメーター

*nペア*<br/>
*lpkrnpair*が指す[KERNINGPAIR](/windows/win32/api/wingdi/ns-wingdi-kerningpair)構造体の数を指定します。 この関数は*nPairs*で指定された数を超えるカーニングペアをコピーしません。

*プルクルンペア*<br/>
関数が返されるときにカー`KERNINGPAIR`ニングペアを受け取る構造体の配列を指します。 この配列には *、少なくとも nPairs*で指定された数の構造体が含まれている必要があります。 このパラメーターが NULL の場合、この関数はフォントのカーニングペアの合計数を返します。

### <a name="return-value"></a>戻り値

関数が正常に実行された場合に、取得したカーニングペアの数またはフォント内のカーニングペアの総数を指定します。 関数が失敗した場合、またはフォントのカーニングペアがない場合は、ゼロが返されます。

## <a name="cdcgetlayout"></a><a name="getlayout"></a>CDC::ゲットレイアウト

プリンターやメタファイルなどのデバイス コンテキストのテキストとグラフィックスのレイアウトを確認します。

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>戻り値

正常に実行された場合は、現在のデバイス コンテキストのレイアウト フラグ。 それ以外の場合は、GDI_ERROR。 拡張エラー情報については[、GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)を呼び出します。 レイアウト フラグの一覧については[、「CDC::SetLayout](#setlayout)」を参照してください。

### <a name="remarks"></a>解説

既定のレイアウトは左から右です。

## <a name="cdcgetmapmode"></a><a name="getmapmode"></a>CDC::ゲットマップモード

現在のマッピング モードを取得します。

```
int GetMapMode() const;
```

### <a name="return-value"></a>戻り値

マッピング モード。

### <a name="remarks"></a>解説

マッピング モードの説明については、メンバー関数を`SetMapMode`参照してください。

> [!NOTE]
> [SetLayout](#setlayout)を呼び出して DC を右から左へのレイアウト`SetLayout`に変更すると、マッピング モードが自動的にMM_ISOTROPICに変更されます。 その結果、以降の呼び`GetMapMode`出しはMM_ISOTROPIC返します。

## <a name="cdcgetmiterlimit"></a><a name="getmiterlimit"></a>CDC::ゲットマイターリミット

デバイス コンテキストのマイター制限を返します。

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

マイターリミットは、マイタ結合がある幾何学線を描画するときに使用されます。

## <a name="cdcgetnearestcolor"></a><a name="getnearestcolor"></a>CDC::最も近い色を取得します。

指定した論理色に最も適した純色を返します。

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>パラメーター

*Crcolor*<br/>
一致する色を指定します。

### <a name="return-value"></a>戻り値

デバイスが表すことができる*crColor*値に最も近い単色を定義する RGB (赤、緑、青) の色の値。

### <a name="remarks"></a>解説

指定されたデバイスは、この色を表すことができる必要があります。

## <a name="cdcgetoutlinetextmetrics"></a><a name="getoutlinetextmetrics"></a>テキスト メトリックスを取得します。

TrueType フォントのメトリック情報を取得します。

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>パラメーター

*lpotm*<br/>
[アウトラインテキストの](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw)構造体の配列へのポイント。 このパラメーターが NULL の場合、関数は、取得したメトリック・データに必要なバッファーのサイズを戻します。

*cbData*<br/>
情報が返されるバッファーのサイズをバイト単位で指定します。

*lpotm*<br/>
構造体への`OUTLINETEXTMETRIC`ポイント。 このパラメーターが NULL の場合、関数は、取得したメトリック情報に必要なバッファーのサイズを返します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

[アウトラインテキストメトリクス](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw)構造には、[テキストメトリック](/windows/win32/api/wingdi/ns-wingdi-textmetricw)構造を含む TrueType 形式で提供されるフォントメトリック情報のほとんどが含まれています。 `OUTLINETEXTMETRIC`構造体の最後の 4 つのメンバーは、文字列へのポインターです。 アプリケーションは、他のメンバーに必要な領域に加えて、これらの文字列用の領域を割り当てる必要があります。 システムが指定した文字列のサイズ制限がないため、メモリを割り当てる最も簡単な方法は、関数の最初の呼び出しで*lpotm*に NULL を指定`GetOutlineTextMetrics`して必要なサイズを取得することです。

## <a name="cdcgetoutputcharwidth"></a><a name="getoutputcharwidth"></a>CDC::出力文字幅

出力デバイス コンテキスト を`m_hDC`使用して、現在のフォントから連続する文字グループ内の個々の文字の幅を取得します。

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>パラメーター

*nファーストチャー*<br/>
現在のフォントの連続する文字グループの最初の文字を指定します。

*ラストチャー*<br/>
現在のフォントの連続する文字グループの最後の文字を指定します。

*バッファバッファ*<br/>
現在のフォントの連続する文字グループの幅の値を受け取るバッファーへのポイント。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

たとえば *、nFirstChar*が文字 'a' を識別し *、nLastChar*が文字 'z' を識別する場合、関数はすべての小文字の幅を取得します。

この関数は *、lpBuffer*が指すバッファに値を格納します。 このバッファーは、すべての幅を保持するのに十分な大きさである必要があります。つまり、指定された例には少なくとも 26 個のエントリが必要です。

連続する文字グループ内の文字が特定のフォントに存在しない場合は、デフォルトの文字の幅の値が割り当てられます。

## <a name="cdcgetoutputtabbedtextextent"></a><a name="getoutputtabbedtextextent"></a>テキスト範囲を取得します。

出力デバイス コンテキスト[を使用](#m_hdc)して、文字列の幅と高さを計算m_hDC、このメンバー関数を呼び出します。

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>パラメーター

*文字列*<br/>
計測する文字列を指します。 このパラメーターに[CString](../../atl-mfc-shared/reference/cstringt-class.md)オブジェクトを渡すこともできます。

*nカウント*<br/>
*lpszString*[が指す文字列の長さを](/windows/win32/gdi/specifying-length-of-text-output-string)指定します。

*nタブポジション*<br/>
*lpnTabStopPositions*が指す配列内のタブストップ位置の数を指定します。

*位置を指定します。*<br/>
タブストップ位置を論理単位で格納する整数の配列へのポイント。 タブ位置は昇順に並べ替える必要があります。最小の x 値は、配列の最初の項目である必要があります。 戻るタブは使用できません。

*Str*<br/>
測定`CString`対象の指定された文字を含むオブジェクト。

### <a name="return-value"></a>戻り値

[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクトの文字列のサイズ (論理単位)。

### <a name="remarks"></a>解説

文字列に 1 つ以上のタブ文字が含まれている場合、文字列の幅は *、lpnTabStopPositions*で指定されたタブ ストップに基づいて行われます。 この関数は、現在選択されているフォントを使用して、文字列のサイズを計算します。

現在のクリッピング領域は、`GetOutputTabbedTextExtent`関数によって返される幅と高さをオフセットしません。

一部のデバイスでは、通常のセル配列に文字を配置しないため (つまり、文字をカーニングするため)、文字列内の文字の範囲の合計が文字列の範囲と等しくない場合があります。

*nTabPositions*が 0 で *、lpnTab ストップポジション*が NULL の場合、タブは 8 つの平均文字幅に拡張されます。 *nTabPositions が*1 の場合、タブストップは *、lpnTabStopPositions*が指す配列の最初の値で指定された距離で区切られます。 *lpnTabStopPositions*が複数の値を指している場合、配列内の各値に対してタブ位置が設定*されます。*

## <a name="cdcgetoutputtextextent"></a><a name="getoutputtextextent"></a>テキスト範囲を取得します。

出力デバイス コンテキストを使用して[、m_hDC 現在](#m_hdc)のフォントを使用してテキストの行の幅と高さを計算するには、このメンバー関数を呼び出します。

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>パラメーター

*文字列*<br/>
文字列を指します。 このパラメーターに[CString](../../atl-mfc-shared/reference/cstringt-class.md)オブジェクトを渡すこともできます。

*nカウント*<br/>
*lpszString*[が指す文字列の長さを](/windows/win32/gdi/specifying-length-of-text-output-string)指定します。

*Str*<br/>
測定`CString`対象の指定された文字を含むオブジェクト。

### <a name="return-value"></a>戻り値

[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクトに返される文字列のサイズ (論理単位)。

### <a name="remarks"></a>解説

現在のクリッピング領域は、 によって返される`GetOutputTextExtent`幅と高さには影響しません。

一部のデバイスでは、通常のセル配列に文字を配置しないため (つまり、カーニングが実行されます)、文字列内の文字の範囲の合計が文字列の範囲と等しくない場合があります。

## <a name="cdcgetoutputtextmetrics"></a><a name="getoutputtextmetrics"></a>テキスト メトリックスを取得します。

出力デバイス コンテキスト を使用して`m_hDC`、現在のフォントのメトリックを取得します。

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>パラメーター

*lp メトリックス*<br/>
メトリックを受け取る[TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw)構造体へのポイント。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

## <a name="cdcgetpath"></a><a name="getpath"></a>CDC::ゲットパス

デバイス コンテキスト内で選択されたパスにある、線の端点と曲線の制御点を定義する座標を取得します。

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>パラメーター

*Lppoints*<br/>
[線](/windows/win32/api/windef/ns-windef-point)の終点と曲線の制御点が`CPoint`配置される POINT データ構造またはオブジェクトの配列を指します。

*Lptypes*<br/>
頂点の型が配置されるバイト配列へのポインタ。 値は、次のいずれかです。

- PT_MOVETO *lpPoints*の対応する点が不整合な図形を開始することを指定します。

- PT_LINETO *lpPoints*の前の点と対応する点が線の端点であることを指定します。

- PT_BEZIERTO *lpPoints*の対応する点が、Bzier 曲線のコントロール ポイントまたは終了点であることを指定します。

PT_BEZIERTO型は常に 3 つのセットで発生します。 パスの直前の点は、Bzier 曲線の始点を定義します。 最初の2つのPT_BEZIERTO点はコントロールポイントで、3番目のPT_BEZIERTO点は終点です(ハードコーディングされている場合)。

   PT_LINETO型またはPT_BEZIERTO型を次のフラグと組み合わせて (ビットごとの**OR**を使用して) 、対応する点が図の最後の点であり、図形を閉じる必要があることを示します。

- PT_CLOSEFIGURE対応する線または曲線が描画された後に、図形が自動的に閉じられます。 図形は、線分または曲線の終点から、最後のPT_MOVETOに対応する点に線を描画することによって閉じられます。

*nカウント*<br/>
*lpPoints*配列に配置できる[POINT](/windows/win32/api/windef/ns-windef-point)データ構造の総数を指定します。 この値は *、lpTypes*配列に格納できるバイト数と同じでなければなりません。

### <a name="return-value"></a>戻り値

*nCount*パラメーターが 0 以外の場合は、列挙されたポイントの数。 *nCount*が 0 の場合、パス内のポイントの合計数`GetPath`(およびバッファーに何も書き込みません)。 *nCount*が 0 以外の場合、パス内のポイント数よりも小さい場合、戻り値は -1 になります。

### <a name="remarks"></a>解説

デバイス コンテキストには、閉じたパスが含まれている必要があります。 パスのポイントは論理座標で返されます。 ポイントはデバイス座標でパスに格納されるため`GetPath`、現在の変換の逆を使用して、ポイントをデバイス座標から論理座標に変更します。 メンバー`FlattenPath`関数は、 の前`GetPath`に呼び出して、パス内のすべての曲線を線分に変換できます。

### <a name="example"></a>例

  [CDC::BeginPath](#beginpath)の例を参照してください。

## <a name="cdcgetpixel"></a><a name="getpixel"></a>CDC::ゲットピクセル

*x*および*y*で指定されたポイントのピクセルの RGB カラー値を取得します。

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>パラメーター

*X*<br/>
検査する点の論理 x 座標を指定します。

*Y*<br/>
検査する点の論理 y 座標を指定します。

*ポイント*<br/>
検査する点の論理 x 座標と y 座標を指定します。

### <a name="return-value"></a>戻り値

どちらのバージョンの関数でも、指定した点の色の RGB カラー値。 座標がクリッピング領域内の点を指定しない場合は-1 になります。

### <a name="remarks"></a>解説

ポイントは、クリッピング領域内になければなりません。 ポイントがクリッピング領域にない場合、関数は効果を持たず、-1 を返します。

一部のデバイスでは、`GetPixel` 関数がサポートされていません。 詳細については[、GetDeviceCaps](#getdevicecaps)メンバー関数の下のRC_BITBLT ラスターケーパビリティを参照してください。

メンバー`GetPixel`関数には 2 つの形式があります。 最初の座標値は 2 つの座標値を取ります。2 番目のオブジェクトは[、POINT](/windows/win32/api/windef/ns-windef-point)構造体または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)オブジェクトを使用します。

## <a name="cdcgetpolyfillmode"></a><a name="getpolyfillmode"></a>CDC::ゲットポリフィルモード

現在のポリゴン塗りつぶしモードを取得します。

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>戻り値

関数が正常に実行された場合は、現在のポリゴン塗り潰しモード (ALTERNATE または WINDING) です。

### <a name="remarks"></a>解説

ポリゴン塗`SetPolyFillMode`りつぶしモードの説明については、メンバー関数を参照してください。

## <a name="cdcgetrop2"></a><a name="getrop2"></a>CDC::ゲットロップ2

現在の描画モードを取得します。

```
int GetROP2() const;
```

### <a name="return-value"></a>戻り値

描画モード。 描画モード値のリストについては、メンバー関数を`SetROP2`参照してください。

### <a name="remarks"></a>解説

描画モードは、ペンの色と塗りつぶされたオブジェクトの内部を、表示サーフェス上の既に表示されている色と組み合わせる方法を指定します。

## <a name="cdcgetsafehdc"></a><a name="getsafehdc"></a>CDC::ゲットセーフハドック

出力デバイス[コンテキストm_hDC取得](#m_hdc)するには、このメンバー関数を呼び出します。

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>戻り値

デバイス コンテキスト ハンドル。

### <a name="remarks"></a>解説

このメンバー関数は、null ポインターでも機能します。

## <a name="cdcgetstretchbltmode"></a><a name="getstretchbltmode"></a>CDC::ゲットストレッチブルトモード

現在のビットマップ伸縮モードを取得します。

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>戻り値

関数が正常に実行された場合、現在のビットマップ伸縮モード (STRETCH_ANDSCANS、STRETCH_DELETESCANS、またはSTRETCH_ORSCANS) を返す値を指定します。

### <a name="remarks"></a>解説

ビットマップストレッチ モードは、メンバー関数によって拡大または圧縮されたビットマップから情報を削除する方法を`StretchBlt`定義します。

STRETCH_ANDSCANSモードとSTRETCH_ORSCANSモードは、通常、モノクロビットマップで前景ピクセルを保持するために使用されます。 通常、STRETCH_DELETESCANS モードはカラー ビットマップのカラーを保持するために使用されます。

## <a name="cdcgettabbedtextextent"></a><a name="gettabbedtextextent"></a>テキスト範囲を取得します。

属性のデバイス[コンテキストを使用](#m_hattribdc)して、文字列の幅と高さを計算m_hAttribDC、このメンバー関数を呼び出します。

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>パラメーター

*文字列*<br/>
文字列へのポイント。 このパラメーターに[CString](../../atl-mfc-shared/reference/cstringt-class.md)オブジェクトを渡すこともできます。

*nカウント*<br/>
*lpszString*[が指す文字列の長さを](/windows/win32/gdi/specifying-length-of-text-output-string)指定します。

*nタブポジション*<br/>
*lpnTabStopPositions*が指す配列内のタブストップ位置の数を指定します。

*位置を指定します。*<br/>
タブストップ位置を論理単位で格納する整数の配列へのポイント。 タブ位置は昇順に並べ替える必要があります。最小の x 値は、配列の最初の項目である必要があります。 戻るタブは使用できません。

*Str*<br/>
描画`CString`される指定された文字を含むオブジェクト。

### <a name="return-value"></a>戻り値

[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクトの文字列のサイズ (論理単位)。

### <a name="remarks"></a>解説

文字列に 1 つ以上のタブ文字が含まれている場合、文字列の幅は *、lpnTabStopPositions*で指定されたタブ ストップに基づいて行われます。 この関数は、現在選択されているフォントを使用して、文字列のサイズを計算します。

現在のクリッピング領域は、`GetTabbedTextExtent`関数によって返される幅と高さをオフセットしません。

一部のデバイスでは、通常のセル配列に文字を配置しないため (つまり、文字をカーニングするため)、文字列内の文字の範囲の合計が文字列の範囲と等しくない場合があります。

*nTabPositions が*0 で *、lpnTab ストップポジション*が NULL の場合、タブは平均文字幅の 8 倍に拡張されます。 *nTabPositions が*1 の場合、タブストップは *、lpnTabStopPositions*が指す配列の最初の値で指定された距離で区切られます。 *lpnTabStopPositions*が複数の値を指している場合、配列内の各値に対してタブ位置が設定*されます。*

## <a name="cdcgettextalign"></a><a name="gettextalign"></a>CDC::テキスト整列

デバイス コンテキストのテキスト配置フラグの状態を取得します。

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>戻り値

テキスト配置フラグの状態。 戻り値は、次の値のいずれかまたは複数です。

- TA_BASELINE X 軸の配置と外接する四角形内で選択したフォントのベースラインを指定します。

- TA_BOTTOM X 軸と外接する四角形の底の配置を指定します。

- TA_CENTER y 軸と外接する四角形の中心の配置を指定します。

- TA_LEFT外接する四角形の y 軸と左側の配置を指定します。

- TA_NOUPDATECP 現在の位置が更新されないことを指定します。

- TA_RIGHT y 軸と外接する四角形の右側の配置を指定します。

- TA_TOP X 軸と外接する四角形の上端の配置を指定します。

- TA_UPDATECP 現在の位置が更新されます。

### <a name="remarks"></a>解説

テキスト配置フラグは、 および`TextOut``ExtTextOut`メンバー関数が文字列の開始点に関連して文字列を整列する方法を決定します。 テキスト配置フラグは、必ずしも単一ビット フラグではなく、0 に等しい場合もあります。 フラグが設定されているかどうかをテストするには、アプリケーションで次の手順を実行する必要があります。

1. フラグと関連フラグにビットごとの OR 演算子を適用します。

   - TA_LEFT、TA_CENTER、TA_RIGHT

   - TA_BASELINE、TA_BOTTOM、TA_TOP

   - TA_NOUPDATECPとTA_UPDATECP

1. ビットごとの AND 演算子を結果に適用し、戻り値`GetTextAlign`を .

1. この結果とフラグが等しいかテストします。

## <a name="cdcgettextcharacterextra"></a><a name="gettextcharacterextra"></a>テキスト文字の追加

文字間の間隔の量の現在の設定を取得します。

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>戻り値

文字間の間隔の量。

### <a name="remarks"></a>解説

GDI は、デバイス コンテキストにテキスト行を書き込むときに、区切り文字を含む各文字にこの間隔を追加します。

文字間間隔のデフォルト値は 0 です。

## <a name="cdcgettextcolor"></a><a name="gettextcolor"></a>テキストの色を取得します。

現在のテキストの色を取得します。

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>戻り値

RGB カラー値としての現在のテキストの色。

### <a name="remarks"></a>解説

テキストの色は、GDI テキスト出力メンバー関数[TextOut](#textout) [、ExtTextOut](#exttextout)、および[TabbedTextOut](#tabbedtextout)を使用して描画される文字の前景色です。

## <a name="cdcgettextextent"></a><a name="gettextextent"></a>CDC::テキスト範囲を取得します。

現在のフォントを使用して、テキスト行の幅と高さを計算して、ディメンションを決定します。

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>パラメーター

*文字列*<br/>
文字列を指します。 このパラメーターに[CString](../../atl-mfc-shared/reference/cstringt-class.md)オブジェクトを渡すこともできます。

*nカウント*<br/>
文字列の文字数を指定します。

*Str*<br/>
指定`CString`した文字を含むオブジェクト。

### <a name="return-value"></a>戻り値

[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクトの文字列のサイズ (論理単位)。

### <a name="remarks"></a>解説

情報は、属性デバイス コンテキスト[m_hAttribDC](#m_hattribdc)から取得されます。

既定では、`GetTextExtent`寸法を取得するテキストが水平線に沿って設定されていると仮定します (つまり、エスケープメントは 0 です)。 ゼロ以外のエスケープメントを指定するフォントを作成する場合は、文字列のサイズを取得するために、テキストの角度を明示的に変換する必要があります。

現在のクリッピング領域は、 によって返される`GetTextExtent`幅と高さには影響しません。

一部のデバイスでは、通常のセル配列に文字を配置しないため (つまり、カーニングが実行されます)、文字列内の文字の範囲の合計が文字列の範囲と等しくない場合があります。

## <a name="cdcgettextextentexpointi"></a><a name="gettextextentexpointi"></a>CDC::テキストエクステントエクスポイント

指定した文字列内の指定したスペース内に収まる文字数を取得し、配列にそれらの文字の各文字のテキスト範囲を設定します。

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>パラメーター

*pgiIn*<br/>
エクステントを取得するグリフ インデックスの配列へのポインター。

*Cgi*<br/>
*pgiIn*が指す配列内のグリフの数を指定します。

*nマックスエクステント*<br/>
書式設定された文字列の最大許容幅を論理単位で指定します。

*lpnフィット*<br/>
*nMaxExtent*で指定されたスペースに収まる最大文字数を受け取る整数へのポインター。 *lpnFit*が NULL の場合 *、nMaxExtent*は無視されます。

*アルプDx*<br/>
グリフの部分的なエクステントを受け取る整数の配列へのポインター。 配列内の各要素は、グリフ インデックス配列の先頭と*nMaxExtent*で指定されたスペースに収まるグリフの 1 つの間の距離を論理単位で示します。 この配列には *、cgi*で指定されるグリフインデックスと同じ数の要素が必要ですが、関数は *、lpnFit*で指定されている数のグリフインデックスの範囲を配列に格納します。 *lpnDx*が NULL の場合、関数は文字列の部分的な幅を計算しません。

*lp サイズ*<br/>
グリフ インデックス配列の次元を論理単位で受け取る[SIZE](/windows/win32/api/windef/ns-windef-size)構造体へのポインタ。 この値を NULL にすることはできません。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

このメンバー関数は、Windows SDK で説明されているように、関数[の](/windows/win32/api/wingdi/nf-wingdi-gettextextentexpointi)機能をエミュレートします。

## <a name="cdcgettextextentpointi"></a><a name="gettextextentpointi"></a>CDC::テキストエクステントポイント

指定したグリフ インデックスの配列の幅と高さを取得します。

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>パラメーター

*pgiIn*<br/>
エクステントを取得するグリフ インデックスの配列へのポインター。

*Cgi*<br/>
*pgiIn*が指す配列内のグリフの数を指定します。

*lp サイズ*<br/>
グリフ インデックス配列の次元を論理単位で受け取る[SIZE](/windows/win32/api/windef/ns-windef-size)構造体へのポインタ。 この値を NULL にすることはできません。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

このメンバー関数は、Windows SDK で説明されているように、関数[の機能](/windows/win32/api/wingdi/nf-wingdi-gettextextentpointi)をエミュレートします。

## <a name="cdcgettextface"></a><a name="gettextface"></a>CDC::テキストフェイス

現在のフォントの書体名をバッファーにコピーします。

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>パラメーター

*nカウント*<br/>
バッファーのサイズをバイト単位で指定します。 タイプフェイス名がこのパラメーターで指定されたバイト数より長い場合、名前は切り捨てられます。

*名前*<br/>
タイプフェイス名のバッファーへのポイント。

*文字列*<br/>
[CString](../../atl-mfc-shared/reference/cstringt-class.md)オブジェクトへの参照。

### <a name="return-value"></a>戻り値

バッファーにコピーされたバイト数 (終端の NULL 文字を含まない)。 エラーが発生した場合は 0 です。

### <a name="remarks"></a>解説

書体名は、NULL で終わる文字列としてコピーされます。

## <a name="cdcgettextmetrics"></a><a name="gettextmetrics"></a>CDC::テキストメトリックス

属性デバイス コンテキストを使用して、現在のフォントのメトリックを取得します。

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>パラメーター

*lp メトリックス*<br/>
メトリックを受け取る[TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw)構造体へのポイント。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

## <a name="cdcgetviewportext"></a><a name="getviewportext"></a>CDC::ゲットビューポートエクスタブ

デバイス コンテキストのビューポートの x および y の範囲を取得します。

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>戻り値

`CSize`オブジェクトとしての x および y のエクステント (デバイス単位)。

## <a name="cdcgetviewportorg"></a><a name="getviewportorg"></a>CDC::ゲットビューポートオルグ

デバイス コンテキストに関連付けられているビューポートの原点の x 座標と y 座標を取得します。

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>戻り値

ビューポートの原点 (デバイス座標) をオブジェクトとして`CPoint`指定します。

## <a name="cdcgetwindow"></a><a name="getwindow"></a>CDC::ウィンドウを取得します。

表示デバイス コンテキストに関連付けられているウィンドウを返します。

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>戻り値

成功した場合`CWnd`はオブジェクトへのポインター。それ以外の場合は NULL。

### <a name="remarks"></a>解説

これは高度な機能です。 たとえば、このメンバー関数は、印刷時や印刷プレビュー時にビュー ウィンドウを返さない場合があります。 出力に関連付けられたウィンドウを常に返します。 指定された DC を使用する出力関数は、このウィンドウに描画します。

## <a name="cdcgetwindowext"></a><a name="getwindowext"></a>CDC::ゲットウィンドウエクスク

デバイス コンテキストに関連付けられているウィンドウの x および y の範囲を取得します。

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>戻り値

x および y の範囲 (論理単位) を`CSize`オブジェクトとして指定します。

## <a name="cdcgetwindoworg"></a><a name="getwindoworg"></a>CDC::ゲットウィンドウオルグ

デバイス コンテキストに関連付けられているウィンドウの原点の x 座標と y 座標を取得します。

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>戻り値

`CPoint`オブジェクトとしてのウィンドウの原点 (論理座標)。

## <a name="cdcgetworldtransform"></a><a name="getworldtransform"></a>CDC::ゲットワールドトランスフォーム

ページ空間変換への現在のワールド空間を取得します。

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>パラメーター

*rXフォーム*<br/>
ページ空間変換への現在のワールド空間変換を受け取る[XFORM](/windows/win32/api/wingdi/ns-wingdi-xform)構造体への参照。

### <a name="return-value"></a>戻り値

成功した場合に 0 以外の値を返します。

失敗した場合は 0 を返します。

拡張エラー情報を取得するには[、GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)を呼び出します。

### <a name="remarks"></a>解説

このメソッドは、Windows GDI 関数[を](/windows/win32/api/wingdi/nf-wingdi-getworldtransform)ラップします。

## <a name="cdcgradientfill"></a><a name="gradientfill"></a>CDC::グラデーション塗りつぶし

四角形と三角形の構造体を、一方の側から他方の側に滑らかにフェードする色で塗りつぶします。

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>パラメーター

*頂点*<br/>
三角形の頂点を定義する[TRIVERTEX](/windows/win32/api/wingdi/ns-wingdi-trivertex)構造体の配列へのポインター。

*n頂点*<br/>
頂点の数。

*pメッシュ*<br/>
三角形モードの[GRADIENT_TRIANGLE](/windows/win32/api/wingdi/ns-wingdi-gradient_triangle)構造体の配列、または四角形モードの[GRADIENT_RECT](/windows/win32/api/wingdi/ns-wingdi-gradient_rect)構造体の配列。

*メッシュエレメンツ*<br/>
*pMesh*内の要素 (三角形または四角形) の数。

*dw モード*<br/>
グラデーション塗りつぶしモードを指定します。 使用可能な値の一覧については、「Windows SDK[のグラデーション塗りつぶし](/windows/win32/api/wingdi/nf-wingdi-gradientfill)」を参照してください。

### <a name="return-value"></a>戻り値

成功した場合は TRUE、それ以外の場合は FALSE。

### <a name="remarks"></a>解説

詳細については、Windows `GradientFill` SDK を参照してください。

## <a name="cdcgraystring"></a><a name="graystring"></a>CDC::グレイストリング

メモリ ビットマップにテキストを書き込み、ビットマップを暗くし、ビットマップをディスプレイにコピーして、指定した位置に淡色 (灰色) のテキストを描画します。

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>パラメーター

*pブラシ*<br/>
調光 (グレー) に使用するブラシを識別します。

*出力*<br/>
文字列を描画するアプリケーションが指定したコールバック関数のプロシージャ インスタンス アドレスを指定します。 詳細については、 Windows `OutputFunc` [コールバック関数](callback-functions-used-by-mfc.md#graystring)の説明を参照してください。 このパラメーターが NULL の場合、システムは`TextOut`Windows 関数を使用して文字列を描画し *、lpData*は出力される文字列への長いポインターであると見なされます。

*lpData*<br/>
出力関数に渡されるデータへの far ポインターを指定します。 *lpfnOutput*が NULL の場合 *、lpData*は出力される文字列への長いポインターでなければなりません。

*nカウント*<br/>
出力する文字数を指定します。 このパラメーターが 0`GrayString`の場合は、文字列の長さを計算します *(lpData*が文字列へのポインターであると仮定します)。 *nCount*が 1 で *、lpfnOutput*が指す関数が 0 を返す場合、イメージは表示されますが、淡色表示されません。

*X*<br/>
文字列を囲む四角形の開始位置の論理 x 座標を指定します。

*Y*<br/>
文字列を囲む四角形の開始位置の論理 y 座標を指定します。

*n幅*<br/>
文字列を囲む四角形の幅を論理単位で指定します。 *nWidth が*0`GrayString`の場合は *、lpData*が文字列へのポインターであると仮定して、領域の幅を計算します。

*nHeight*<br/>
文字列を囲む四角形の高さを論理単位で指定します。 *nHeight が*0`GrayString`の場合は *、lpData*が文字列へのポインターであると仮定して、領域の高さを計算します。

### <a name="return-value"></a>戻り値

文字列が描画される場合は 0 以外、`TextOut`関数またはアプリケーション提供の出力関数のいずれかが 0 を返した場合、またはメモリ不足のため調光するメモリ ビットマップを作成できない場合は 0 以外の値を返します。

### <a name="remarks"></a>解説

この関数は、選択したブラシと背景に関係なく、テキストを暗くします。 メンバー`GrayString`関数は、現在選択されているフォントを使用します。 この関数を使用する前に、MM_TEXTマッピングモードを選択する必要があります。

アプリケーションは、メンバー関数を呼び出すことなく、淡いグレーカラーをサポートするデバイス上で淡`GrayString`色 (灰色) の文字列を描画できます。 システム カラー COLOR_GRAYTEXTは、無効なテキストを描画するために使用される、実線グレーのシステム カラーです。 アプリケーションは、Windows`GetSysColor`関数を呼び出して、COLOR_GRAYTEXTの色の値を取得できます。 色が 0 (黒) 以外の場合、アプリケーションは`SetTextColor`メンバー関数を呼び出してテキストの色を色の値に設定し、文字列を直接描画できます。 取得した色が黒の場合、アプリケーションはテキストを`GrayString`淡色 (灰色) に呼び出す必要があります。

*lpfnOutput*が NULL の場合、GDI は Windows[テキストアウト](/windows/win32/api/wingdi/nf-wingdi-textoutw)関数を使用し *、lpData*は出力される文字への遠いポインターであると見なされます。 `TextOut`出力される文字がメンバー関数で処理できない場合 (たとえば、文字列がビットマップとして格納されている場合)、アプリケーションは独自の出力関数を指定する必要があります。

また、すべてのコールバック関数は、コールバック境界を越えて例外をスローすることはできないので、Windows に戻る前に Microsoft Foundation の例外をトラップする必要があることに注意してください。 例外の詳細については、記事「[例外](../../mfc/exception-handling-in-mfc.md)」を参照してください。

渡されるコールバック関数は`GrayString`呼び出`__stdcall`し規約を使用する必要があり`__declspec`、 でエクスポートする必要があります。

フレームワークがプレビュー モードの場合、`GrayString`メンバー関数の呼び`TextOut`出しは呼び出しに変換され、コールバック関数は呼び出されません。

## <a name="cdchimetrictodp"></a><a name="himetrictodp"></a>CDC::ヒメトリクトデ

HIMETRIC サイズを OLE からピクセルに変換する場合に、この関数を使用します。

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>パラメーター

*lp サイズ*<br/>
[SIZE](/windows/win32/api/windef/ns-windef-size)構造体または[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクトへのポイント。

### <a name="remarks"></a>解説

デバイス コンテキスト オブジェクトのマッピング モードがMM_LOENGLISH、MM_HIENGLISH、MM_LOMETRIC、またはMM_HIMETRIC場合、変換は物理インチ単位のピクセル数に基づきます。 マッピング モードが他の非制約モード (MM_TEXTなど) の場合、変換は論理インチのピクセル数に基づいて行われます。

## <a name="cdchimetrictolp"></a><a name="himetrictolp"></a>CDC::ヒメトリクトルプ

HIMETRIC 単位を論理単位に変換します。

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>パラメーター

*lp サイズ*<br/>
[SIZE](/windows/win32/api/windef/ns-windef-size)構造体または[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクトへのポイント。

### <a name="remarks"></a>解説

この関数は、OLE から HIMETRIC サイズを取得し、アプリケーションの自然マッピング モードに変換する場合に使用します。

変換は、まず HIMETRIC 単位をピクセルに変換し、デバイス コンテキストの現在のマッピング単位を使用してこれらの単位を論理単位に変換することによって行われます。 デバイスのウィンドウとビューポートの範囲が結果に影響を与えます。

## <a name="cdcintersectcliprect"></a><a name="intersectcliprect"></a>CDC::交差クリップレック

現在の領域と *、x1* *、y1 、x2*、*および y2*で指定された*x2*四角形の交点を形成して、新しいクリッピング領域を作成します。

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
四角形の左上隅の論理 x 座標を指定します。

*y1*<br/>
四角形の左上隅の論理 y 座標を指定します。

*x2*<br/>
四角形の右下隅の論理 x 座標を指定します。

*y2*<br/>
四角形の右下隅の論理 y 座標を指定します。

*Lprect*<br/>
四角形を指定します。 このパラメーターの`CRect`構造体にオブジェクトまたはポインターを`RECT`渡すことができます。

### <a name="return-value"></a>戻り値

新しいクリッピング領域のタイプ。 次のいずれかの値を指定できます。

- [コンプレックス領域] 新しいクリップ領域の境界線が重なっています。

- エラー デバイス コンテキストが無効です。

- 新しいクリッピング領域が空です。

- シンプル領域 新しいクリップ領域には、重なり合う境界線はありません。

### <a name="remarks"></a>解説

GDI は、新しい境界内に収まるように、後続のすべての出力をクリップします。 幅と高さは 32,767 を超えてはなりません。

## <a name="cdcinvertrect"></a><a name="invertrect"></a>CDC::反転レック

指定された四角形の内容を反転します。

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>パラメーター

*Lprect*<br/>
反転する`RECT`四角形の論理座標を含むを指します。 このパラメータにオブジェクトを`CRect`渡すこともできます。

### <a name="remarks"></a>解説

反転は、論理 NOT 演算であり、各ピクセルのビットを反転します。 モノクロディスプレイでは、この関数は白いピクセルを黒と黒のピクセルに白にします。 カラーディスプレイでは、反転はディスプレイの色の生成方法によって異なります。 同`InvertRect`じ四角形を使用して 2 回呼び出すと、表示が以前の色に戻ります。

四角形が空の場合は、何も描画されません。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

## <a name="cdcinvertrgn"></a><a name="invertrgn"></a>CDC:インヴァートルグン

*pRgn*で指定された領域の色を反転します。

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>パラメーター

*Prgn*<br/>
反転する領域を識別します。 領域の座標は論理単位で指定されます。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

モノクロディスプレイでは、この関数は白いピクセルを黒と黒のピクセルに白にします。 カラーディスプレイでは、反転はディスプレイの色がどのように生成されるかによって異なります。

## <a name="cdcisprinting"></a><a name="isprinting"></a>CDC::イズプリント

デバイス コンテキストが印刷に使用されているかどうかを判断します。

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>戻り値

オブジェクトがプリンター `CDC` DC の場合は 0 以外。それ以外の場合は 0。

## <a name="cdclineto"></a><a name="lineto"></a>CDC::ライント

現在の位置から*x*と*y* (または*点*) で指定された点まで、直線を描画します。

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
線分の終点の論理 x 座標を指定します。

*Y*<br/>
線分の終点の論理 y 座標を指定します。

*ポイント*<br/>
線の端点を指定します。 このパラメーターには、`POINT`構造体またはオブジェクトを`CPoint`渡すことができます。

### <a name="return-value"></a>戻り値

線が描画されている場合は 0 以外の値を返します。それ以外の場合は 0。

### <a name="remarks"></a>解説

選択したペンで線が描画されます。 現在の位置は *、x* *、y、* または*点*に設定されます。

### <a name="example"></a>例

  [「CRect::センターポイント](../../atl-mfc-shared/reference/crect-class.md#centerpoint)」の例を参照してください。

## <a name="cdclptodp"></a><a name="lptodp"></a>CDC::LPtoDP

論理単位を装置単位に変換します。

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>パラメーター

*Lppoints*<br/>
ポイントの配列へのポイント。 配列内の各ポイントは[、POINT](/windows/win32/api/windef/ns-windef-point)構造または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)オブジェクトです。

*nカウント*<br/>
配列内のポイント数。

*Lprect*<br/>
[RECT](/windows/win32/api/windef/ns-windef-rect)構造体または[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクトへのポイント。 このパラメーターは、論理からデバイス単位への四角形のマッピングの一般的なケースに使用されます。

*lp サイズ*<br/>
[SIZE](/windows/win32/api/windef/ns-windef-size)構造体または[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクトへのポイント。

### <a name="remarks"></a>解説

この関数は、GDI の論理座標系からデバイス座標系に各ポイントの座標、つまりサイズの大きさをマップします。 変換は、現在のマッピング モード、およびデバイスのウィンドウとビューポートの原点と範囲の設定によって異なります。

点のx座標とy座標は、-32,768から32,767の範囲の2バイト符号付き整数です。 マッピング・モードがこれらの制限値より大きい値になる場合、システムは値をそれぞれ -32,768 および 32,767 に設定します。

## <a name="cdclptohimetric"></a><a name="lptohimetric"></a>CDC::LPtohiMETRIC

論理単位を HIMETRIC 単位に変換します。

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>パラメーター

*lp サイズ*<br/>
`SIZE`構造体またはオブジェクトへの`CSize`ポイント。

### <a name="remarks"></a>解説

アプリケーションの自然マッピング モードから変換して、OLE に HIMETRIC サイズを与える場合にこの関数を使用します。 デバイスのウィンドウとビューポートの範囲が結果に影響を与えます。

変換は、まずデバイス コンテキストの現在のマッピング単位を使用して論理単位をピクセルに変換し、次にこれらの単位を HIMETRIC 単位に変換することで実現されます。

## <a name="cdcm_hattribdc"></a><a name="m_hattribdc"></a>CDC::m_hAttribDC

この`CDC`オブジェクトの属性デバイス コンテキスト。

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>解説

既定では、このデバイス コンテキストは`m_hDC`に等しくなります。 一般に`CDC`、デバイス コンテキストから情報を要求する GDI`m_hAttribDC`呼び出しは に送信されます。 これら 2 つのデバイス コンテキストの使用方法の詳細については[、CDC](../../mfc/reference/cdc-class.md)クラスの説明を参照してください。

## <a name="cdcm_hdc"></a><a name="m_hdc"></a>CDC::m_hDC

この`CDC`オブジェクトの出力デバイス コンテキスト。

```
HDC m_hDC;
```

### <a name="remarks"></a>解説

既定では、`m_hDC`でラップ`m_hAttribDC`された他のデバイス コンテキストは`CDC`に等しくなります。 一般に`CDC`、出力を作成する GDI`m_hDC`呼び出しは、デバイス コンテキストに移動します。 初期化`m_hDC`して、`m_hAttribDC`別のデバイスを指すことができます。 これら 2 つのデバイス コンテキストの使用方法の詳細については[、CDC](../../mfc/reference/cdc-class.md)クラスの説明を参照してください。

## <a name="cdcmaskblt"></a><a name="maskblt"></a>CDC::マスクブレット

指定されたマスクとラスター操作を使用して、変換元とコピー先のビットマップのカラー データを結合します。

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
移動先の四角形の左上隅の論理 x 座標を指定します。

*Y*<br/>
移動先の四角形の左上隅の論理 y 座標を指定します。

*n幅*<br/>
コピー先の四角形と元のビットマップの幅を論理単位で指定します。

*nHeight*<br/>
コピー先の四角形と元のビットマップの高さを論理単位で指定します。

*pSrcDC*<br/>
ビットマップのコピー元のデバイス コンテキストを識別します。 *dwRop*パラメーターにソースを含まないラスター操作を指定する場合は、ゼロにする必要があります。

*xSrc*<br/>
ソース ビットマップの左上隅の論理 x 座標を指定します。

*ySrc*<br/>
ソース ビットマップの左上隅の論理 y 座標を指定します。

*Maskbitmap*<br/>
ソース デバイス コンテキストでカラー ビットマップと組み合わせたモノクロ マスク ビットマップを識別します。

*xマスク*<br/>
*maskBitmap*パラメーターで指定されたマスク ビットマップの水平方向のピクセル オフセットを指定します。

*yマスク*<br/>
*maskBitmap*パラメーターで指定されたマスク ビットマップの垂直ピクセル オフセットを指定します。

*dwRop*<br/>
ソース データとターゲット データの組み合わせを制御するために関数が使用する、前景と背景の 3 項ラスター オペレーション コードの両方を指定します。 バックグラウンド ラスターオペレーション コードは、この値の上位ワードの上位バイトに格納されます。前景ラスターオペレーションコードは、この値の上位ワードの下位バイトに格納されます。この値の下位ワードは無視され、ゼロでなければなりません。 マクロ MAKEROP4 は、前景ラスターオペレーション コードとバックグラウンド ラスター オペレーション コードの組み合わせを作成します。 この関数のコンテキストでの前景と背景の説明については、「解説」を参照してください。 一般的`BitBlt`なラスター オペレーション コードの一覧については、メンバー関数を参照してください。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

*maskBitmap*で指定されたマスクの値が 1 の場合 *、dwRop*で指定された前景ラスターオペレーション コードがその位置に適用されることを示します。 マスク内の値 0 は *、dwRop*で指定されたバックグラウンド ラスターオペレーション コードがその場所に適用されることを示します。 ラスター操作でソースが必要な場合、マスクの四角形はソースの四角形を覆う必要があります。 実行しない場合、関数は失敗します。 ラスター操作でソースが必要ない場合、マスクの四角形は、コピー先の四角形を覆う必要があります。 実行しない場合、関数は失敗します。

この関数が呼び出されたときに、変換元のデバイス コンテキストに対して回転変換またはせん断変換が有効な場合は、エラーが発生します。 ただし、他の種類の変換は許可されます。

ソース ビットマップ、パターン ビットマップ、および出力先ビットマップの色の書式が異なる場合、この関数は、パターンまたはソース形式、またはその両方を変換して、変換先の形式に一致させます。 マスク ビットマップがモノクロ ビットマップでない場合は、エラーが発生します。 拡張メタファイルが記録されている場合、ソース デバイス コンテキストが拡張メタファイル デバイス コンテキストを識別する場合、エラーが発生します (関数は 0 を返します)。 すべてのデバイスが`MaskBlt`をサポートしているわけではありません。 アプリケーションは、デバイス`GetDeviceCaps`がこの関数をサポートしているかどうかを判断するために呼び出す必要があります。 マスク ビットマップが指定されていない場合、この関数は、フォアグラウンド`BitBlt`ラスター オペレーション コードを使用して、 とまったく同じように動作します。 マスク ビットマップのピクセル オフセットは、ソース デバイス コンテキストのビットマップ内のポイント (0,0) にマップされます。 これは、マスク ビットマップに一連のマスクが含まれている場合に便利です。アプリケーションは、ピクセル オフセットと四角形のサイズを調整することで、それらの任意の 1 つをマスクブリッティング タスクに簡単に`MaskBlt`適用できます。

## <a name="cdcmodifyworldtransform"></a><a name="modifyworldtransform"></a>CDC::変換

指定したモードを使用してデバイス コンテキストのワールド変換を変更します。

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>パラメーター

*rXフォーム*<br/>
指定されたデバイス コンテキストのワールド変換を変更するために使用される[XFORM](/windows/win32/api/wingdi/ns-wingdi-xform)構造体への参照。

*iモード*<br/>
変換データが現在のワールド変換をどのように変更するかを指定します。 このパラメーターで使用できる値の一覧については[、「ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform)」を参照してください。

### <a name="return-value"></a>戻り値

成功した場合に 0 以外の値を返します。

失敗した場合は 0 を返します。

拡張エラー情報を取得するには[、GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)を呼び出します。

### <a name="remarks"></a>解説

このメソッドは、Windows GDI 関数[を](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform)ラップします。

## <a name="cdcmoveto"></a><a name="moveto"></a>CDC::移動先

現在の位置を*x*と*y* (または点) で指定した*ポイント*に移動します。

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
新しい位置の論理 x 座標を指定します。

*Y*<br/>
新しい位置の論理 y 座標を指定します。

*ポイント*<br/>
新しい位置を指定します。 このパラメーターには、`POINT`構造体またはオブジェクトを`CPoint`渡すことができます。

### <a name="return-value"></a>戻り値

オブジェクトとしての前の位置の x 座標と y`CPoint`座標。

### <a name="example"></a>例

  [「CRect::センターポイント](../../atl-mfc-shared/reference/crect-class.md#centerpoint)」の例を参照してください。

## <a name="cdcoffsetcliprgn"></a><a name="offsetcliprgn"></a>CDC::オフセットクリップルグン

デバイス コンテキストのクリップ領域を指定したオフセットで移動します。

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
左または右に移動する論理単位の数を指定します。

*Y*<br/>
上下に移動する論理単位の数を指定します。

*サイズ*<br/>
オフセットする量を指定します。

### <a name="return-value"></a>戻り値

新しいリージョンの型。 次のいずれかの値を指定できます。

- コンプレックス領域クリッピング領域に境界線が重なっています。

- エラー デバイス コンテキストが無効です。

- NULLREGION クリッピング領域が空です。

- シンプル領域クリッピング領域には、重なり合う境界線はありません。

### <a name="remarks"></a>解説

この関数は、y 軸に沿って領域*x*単位を x 軸と*y*単位に移動します。

## <a name="cdcoffsetviewportorg"></a><a name="offsetviewportorg"></a>CDC:オフセットビューポートオルガ

現在のビューポート原点の座標に対するビューポート原点の座標を変更します。

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>パラメーター

*n幅*<br/>
現在の原点の x 座標に追加するデバイス単位の数を指定します。

*nHeight*<br/>
現在の原点の y 座標に追加するデバイス単位の数を指定します。

### <a name="return-value"></a>戻り値

直前のビューポート原点 (デバイス座標) を`CPoint`オブジェクトとして指定します。

## <a name="cdcoffsetwindoworg"></a><a name="offsetwindoworg"></a>CDC::オフセットウィンドウオルグ

現在のウィンドウ原点の座標に対する相対的なウィンドウ原点の座標を変更します。

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>パラメーター

*n幅*<br/>
現在の原点の x 座標に追加する論理単位の数を指定します。

*nHeight*<br/>
現在の原点の y 座標に追加する論理単位の数を指定します。

### <a name="return-value"></a>戻り値

オブジェクトとして`CPoint`前のウィンドウの原点 (論理座標)。

## <a name="cdcoperator-hdc"></a><a name="operator_hdc"></a>CDC::オペレーターHDC

この演算子は、オブジェクトのデバイス コンテキスト ハンドル`CDC`を取得するために使用します。

```
operator HDC() const;
```

### <a name="return-value"></a>戻り値

成功した場合は、デバイス コンテキスト オブジェクトのハンドル。それ以外の場合は NULL。

### <a name="remarks"></a>解説

ハンドルを使用して、Windows API を直接呼び出すことができます。

## <a name="cdcpaintrgn"></a><a name="paintrgn"></a>CDC::PaintRgn

現在のブラシを使用して *、pRgn*で指定された領域を塗りつぶします。

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>パラメーター

*Prgn*<br/>
塗りつぶす領域を指定します。 指定された領域の座標は、論理単位で指定されます。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

## <a name="cdcpatblt"></a><a name="patblt"></a>CDC::Pアットブルト

デバイスにビット パターンを作成します。

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
パターンを受け取る四角形の左上隅の論理 x 座標を指定します。

*Y*<br/>
パターンを受け取る四角形の左上隅の論理 y 座標を指定します。

*n幅*<br/>
パターンを受け取る四角形の幅を論理単位で指定します。

*nHeight*<br/>
パターンを受け取る四角形の高さを論理単位で指定します。

*dwRop*<br/>
ラスターオペレーション コードを指定します。 ラスターオペレーション コード (LIP) は、GDI が現在のブラシ、可能なソース ビットマップ、および出力先のビットマップを含む出力操作で色を結合する方法を定義します。 このパラメーターには、次のいずれかの値を指定できます。

- PATCOPY パターンをコピー先ビットマップにコピーします。

- PATINVERT ブール XOR 演算子を使用して、ターゲット ビットマップとパターンを組み合わせます。

- DSTINVERT は、変換先ビットマップを反転します。

- [ブラックネス] すべての出力を黒に変えます。

- 白さ すべての出力を白くします。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

パターンは、選択したブラシとデバイス上に既に存在するパターンの組み合わせです。 *dwRop*で指定されたラスターオペレーション コードは、パターンを組み合わせる方法を定義します。 この関数にリストされているラスター操作は、完全な 256 の三元ラスター オペレーション コードの限定的なサブセットです。特に、ソースを参照するラスター オペレーション コードは使用できません。

すべてのデバイス コンテキストが関数を`PatBlt`サポートしているわけではありません。 デバイス コンテキストがサポート`PatBlt`されているかどうかを確認するには、RASTERCAPS インデックスを`GetDeviceCaps`使用してメンバー関数を呼び出し、RC_BITBLT フラグの戻り値を確認します。

## <a name="cdcpie"></a><a name="pie"></a>CDC::P

円の形をしたくさびを描画するには、中心と 2 つの端点が直線で結合された楕円弧を描画します。

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
外接する四角形の左上隅の x 座標を指定します (論理単位)。

*y1*<br/>
外接する四角形の左上隅の y 座標を指定します (論理単位)。

*x2*<br/>
外接する四角形の右下隅の x 座標を指定します (論理単位)。

*y2*<br/>
外接する四角形の右下隅の y 座標を指定します (論理単位)。

*x3*<br/>
円弧の始点の x 座標を指定します(論理単位)。 この点は、円弧上に正確に配置する必要はありません。

*y3*<br/>
円弧の始点の y 座標を指定します(論理単位)。 この点は、円弧上に正確に配置する必要はありません。

*x4*<br/>
円弧の終点の x 座標を指定します (論理単位)。 この点は、円弧上に正確に配置する必要はありません。

*y4*<br/>
円弧の終点の y 座標を指定します(論理単位)。 この点は、円弧上に正確に配置する必要はありません。

*Lprect*<br/>
外接する四角形を指定します。 このパラメーターの`CRect`構造体にオブジェクトまたはポインターを`RECT`渡すことができます。

*ptStart*<br/>
円弧の始点を指定します。この点は、円弧上に正確に配置する必要はありません。このパラメーターには[、POINT](/windows/win32/api/windef/ns-windef-point)構造体または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)オブジェクトのいずれかを渡すことができます。

*ptEnd*<br/>
円弧の端点を指定します。この点は、円弧上に正確に配置する必要はありません。このパラメーターには、`POINT`構造体またはオブジェクトを`CPoint`渡すことができます。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

円弧の中心は *、x1*、 *y1*、 *x2*、*および y2* (または*lpRect)* で指定される外接する四角形の中心です。 円弧の始点と終点は *、x3*、 *y3*、 *x4*、*および y4* (または*ptStart*および*ptEnd)* で指定されます。

円弧は、選択したペンで反時計回りに移動して描画されます。 各端点から円弧の中心に 2 本の線が引かれます。 パイの形をした領域は、現在のブラシで塗りつぶされます。 *x3*が*x4*に等しく *、y3*が*y4*の場合、楕円の中心から点 *(x3、* *y3)* または ( *x4*, *y4*) までの単一の線を持つ楕円が返されます。

この関数によって描画された図形は、右と下の座標まで拡張しますが、含まれていません。 つまり、図の高さは*y2* - *y1、* 図形の幅は*x2* - *x1*です。 外接する四角形の幅と高さの両方が 2 単位より大きく、32,767 単位未満である必要があります。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

## <a name="cdcplaymetafile"></a><a name="playmetafile"></a>CDC::Pレイメタファイル

指定したメタファイルの内容をデバイス コンテキストで再生します。

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>パラメーター

*hMF*<br/>
再生するメタファイルを識別します。

*hEnhメタファイル*<br/>
拡張メタファイルを識別します。

*lpBounds*<br/>
ピクチャの`RECT`表示に使用する`CRect`外接する四角形の座標を含む構造体またはオブジェクトへのポインター。 座標は論理単位で指定されます。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

メタファイルは、何度でも再生できます。

の 2`PlayMetaFile`番目のバージョンでは、指定された拡張形式のメタファイルに格納されている画像が表示されます。 アプリケーションが 2 番目のバージョン`PlayMetaFile`を呼び出すと、Windows は、拡張メタファイル ヘッダーのピクチャ フレームを使用して *、lpBounds*パラメーターで指す四角形にピクチャをマップします。 (この画像は、呼び出す`PlayMetaFile`前に出力デバイスでワールド変換を設定することによって、せんくりまたは回転することができます。四角形の端に沿ったポイントが画像に含まれます。 拡張メタファイルを再生する前に、出力デバイスでクリッピング領域を定義することで、拡張メタファイル画像をクリップできます。

拡張メタファイルにオプションのパレットが含まれている場合、アプリケーションは、2 番目のバージョンの`PlayMetaFile`を呼び出す前に出力デバイスにカラー パレットを設定することで、一貫した色を実現できます。 オプションのパレットを取得するには、Windows`GetEnhMetaFilePaletteEntries`関数を使用します。 拡張メタファイルは、2 番目の`PlayMetaFile`バージョンの 拡張メタファイルを呼び出し、新しい拡張メタファイルのデバイス コンテキストにソース拡張メタファイルを再生することで、新しく作成された拡張メタファイルに埋め込むことができます。

出力デバイス コンテキストの状態は、この関数によって保持されます。 拡張メタファイルで作成されたが削除されていないオブジェクトは、この関数によって削除されます。 この関数を停止するには、アプリケーションは、別`CancelDC`のスレッドから Windows 関数を呼び出して操作を終了します。 この場合、関数はゼロを返します。

## <a name="cdcplgblt"></a><a name="plgblt"></a>CDC::PlgBlt

ソース デバイス コンテキスト内の指定された四角形から、指定されたデバイス コンテキスト内の指定された平行四辺形への色データのビット ブロック転送を実行します。

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>パラメーター

*lpPoint*<br/>
変換先平行四辺形の 3 つのコーナーを識別する論理空間内の 3 つのポイントの配列を指します。 ソース四角形の左上隅は、この配列の最初の点、この配列の 2 番目のポイントに右上隅、3 番目の点に左下隅にマップされます。 ソース四角形の右下隅は、平行四辺形の 4 番目の暗黙的なポイントにマップされます。

*pSrcDC*<br/>
ソース デバイス コンテキストを識別します。

*xSrc*<br/>
ソース四角形の左上隅の x 座標を論理単位で指定します。

*ySrc*<br/>
ソース四角形の左上隅の y 座標を論理単位で指定します。

*n幅*<br/>
ソース四角形の幅を論理単位で指定します。

*nHeight*<br/>
ソース四角形の高さを論理単位で指定します。

*Maskbitmap*<br/>
ソースの四角形の色をマスクするために使用されるオプションのモノクロ ビットマップを識別します。

*xマスク*<br/>
モノクロ ビットマップの左上隅の x 座標を指定します。

*yマスク*<br/>
モノクロ ビットマップの左上隅の y 座標を指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

指定されたビットマスク ハンドルが有効なモノクロ ビットマップを識別する場合、関数はこのビットマップを使用して、ソースの四角形からカラー データのビットをマスクします。

平行四辺形(D)の4番目の頂点は、最初の3点(A、B、およびC)をベクトルとして処理し、D = B + C - Aを計算することによって定義されます。

ビットマスクが存在する場合、マスクの値 1 は、ソースピクセルカラーをコピー先にコピーすることを示します。 マスクの値が 0 の場合、変換先のピクセルカラーは変更されないことを示します。

マスク矩形がソースおよびターゲットの長方形よりも小さい場合、この関数はマスクパターンを複製します。

ソース デバイス コンテキストでは、スケーリング、変換、およびリフレクションの変換が許可されます。ただし、回転変換とせん断変換は行いません。 マスク ビットマップがモノクロ ビットマップでない場合は、エラーが発生します。 ターゲット デバイス コンテキストのストレッチ モードは、必要に応じてピクセルの伸縮方法を決定するために使用されます。 拡張メタファイルが記録されている場合、ソース デバイス コンテキストが拡張メタファイルデバイス コンテキストを識別する場合は、エラーが発生します。

コピー先の座標は、コピー先デバイス コンテキストに従って変換されます。コピー元の座標は、コピー元デバイス コンテキストに従って変換されます。 変換元の変換に回転またはせん断がある場合は、エラーが返されます。 変換先の四角形と変換元の四角形の色の形式`PlgBlt`が同じでない場合は、変換元の四角形を変換先の四角形に一致させます。 すべてのデバイスが`PlgBlt`をサポートしているわけではありません。 詳細については、メンバー関数のラスターフィーチャRC_BITBLTの説明を`CDC::GetDeviceCaps`参照してください。

ソースデバイスコンテキストとターゲットデバイスコンテキストが互換性のないデバイスを表`PlgBlt`している場合は、エラーを返します。

## <a name="cdcpolybezier"></a><a name="polybezier"></a>CDC::Pオリーベジエ

1 つまたは複数のベジエ スプラインを描画します。

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>パラメーター

*Lppoints*<br/>
スプラインの端点と制御点を含む[POINT](/windows/win32/api/windef/ns-windef-point)データ構造の配列へのポイント。

*nカウント*<br/>
*lpPoints*配列内のポイント数を指定します。 各 Bzier スプラインには 2 つのコントロール ポイントと端点が必要であり、初期スプラインには追加の開始点が必要なため、この値は、描画するスプラインの数の 3 倍を超える値にする必要があります。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

この関数は *、lpPoints*パラメータで指定された端点と制御点を使用して、3 次ベジエ スプラインを描画します。 最初のスプラインは、2 番目と 3 番目の点をコントロール ポイントとして使用して、最初のポイントから 4 番目のポイントまで描画されます。 シーケンス内の後続のスプラインには、前のスプラインの終点が始点として使用され、次の 2 点がコントロール ポイント、3 番目の点が終了点になります。

現在の位置は、`PolyBezier`関数によって使用も更新もされません。 図は塗りつぶされません。 この関数は、現在のペンを使用して線を描画します。

## <a name="cdcpolybezierto"></a><a name="polybezierto"></a>CDC::Pオリーベジエト

1 つまたは複数のベジエ スプラインを描画します。

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>パラメーター

*Lppoints*<br/>
エンドポイントとコントロール ポイントを含む[POINT](/windows/win32/api/windef/ns-windef-point)データ構造体の配列へのポイント。

*nカウント*<br/>
*lpPoints*配列内のポイント数を指定します。 各ベジエ スプラインには 2 つのコントロール ポイントと 1 つの終点が必要なため、この値は、描画するスプラインの数の 3 倍にする必要があります。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

この関数は *、lpPoints*パラメータで指定された制御点を使用して、3 次ベジエ スプラインを描画します。 最初のスプラインは、コントロール ポイントとして最初の 2 点を使用して、現在位置から 3 番目のポイントまで描画されます。 後続のスプラインごとに、この関数は 3 点を必要とし、前のスプラインの終点を次のスプラインの開始点として使用します。 `PolyBezierTo`現在の位置を最後のベジエ スプラインの終点に移動します。 図は塗りつぶされません。 この関数は、現在のペンを使用して線を描画します。

### <a name="example"></a>例

  [CDC::BeginPath](#beginpath)の例を参照してください。

## <a name="cdcpolydraw"></a><a name="polydraw"></a>CDC::Pオリードロー

線分セグメントとベジエ スプラインのセットを描画します。

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>パラメーター

*Lppoints*<br/>
各線分の端点、および各 Bzier スプラインの端点と制御点を含む[POINT](/windows/win32/api/windef/ns-windef-point)データ構造の配列を指します。

*Lptypes*<br/>
*lpPoints*配列内の各ポイントの使用方法を指定する配列へのポイント。 値は次のいずれかです。

- PT_MOVETOこの点が不整合な図形を開始することを指定します。 この点が新しい現在位置になります。

- PT_LINETO現在の位置からこのポイントまで線を描画し、その位置を新しい現在の位置にします。

- PT_BEZIERTOこの点が、Bzier スプラインのコントロール ポイントまたは終了点であることを指定します。

PT_BEZIERTO型は常に 3 つのセットで発生します。 現在位置は、ベジエ スプラインの開始点を定義します。 最初の 2 つのPT_BEZIERTOポイントはコントロール ポイントで、3 番目のPT_BEZIERTOポイントは終了点です。 終了点が新しい現在位置になります。 連続するPT_BEZIERTOポイントが 3 つなければ、エラーが発生します。

   ビットごとの演算子 OR を使用して、PT_LINETOまたはPT_BEZIERTO型を次の定数と組み合わせて、対応する点が図の最後の点であり、図形が閉じていることを示すことができます。

- PT_CLOSEFIGUREこのポイントのPT_LINETOまたはPT_BEZIERTOタイプが完了した後に、図形が自動的に閉じられます。 この点から、最後のPT_MOVETOまたは`MoveTo`点まで線が描画されます。

   このフラグは、ビットごとの**OR**演算子を使用して、線のPT_LINETOタイプ、またはベジエ スプラインの終了点のPT_BEZIERTOタイプと組み合わせます。 現在の位置は、終了線の終了点に設定されます。

*nカウント*<br/>
*lpPoints*配列内のポイントの合計数を*指定*します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

この関数を使用すると、 、`CDC::MoveTo``CDC::LineTo`および メンバー関数を連続して呼び出す代`CDC::PolyBezierTo`わりに、不整合な数値を描画できます。 線分とスプラインは現在のペンを使用して描画され、図形は塗りつぶされません。 `CDC::BeginPath`メンバー関数を呼び出して開始されたアクティブなパスがある`PolyDraw`場合は、パスに追加します。 *lpPoints*配列および*lpTypes*に含まれるポイントは、各ポイントが`CDC::MoveTo``CDC::LineTo`、a または 演算`CDC::BezierTo`の一部であるかどうかを示します。 ●フィギュアを閉じることもできます。 この関数は、現在の位置を更新します。

### <a name="example"></a>例

  [CDC::BeginPath](#beginpath)の例を参照してください。

## <a name="cdcpolygon"></a><a name="polygon"></a>CDC::Pり

現在のペンを使用して、線で接続された 2 つ以上のポイント (頂点) からなるポリゴンを描画します。

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>パラメーター

*Lppoints*<br/>
ポリゴンの頂点を指定するポイントの配列へのポイント。 配列内の各点は`POINT`、構造体またはオブジェクト`CPoint`です。

*nカウント*<br/>
配列内の頂点の数を指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

システムは、必要に応じて、最後の頂点から最初の頂点に線を描画することで、ポリゴンを自動的に閉じます。

現在のポリゴン塗りつぶしモードは、 および`GetPolyFillMode``SetPolyFillMode`メンバー関数を使用して取得または設定できます。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

## <a name="cdcpolyline"></a><a name="polyline"></a>CDC::Pオリン

*lpPoints*で指定された点を結ぶ線分のセットを描画します。

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>パラメーター

*Lppoints*<br/>
接続する構造体または`POINT``CPoint`オブジェクトの配列へのポイント。

*nカウント*<br/>
配列内のポイント数を指定します。 この値は少なくとも 2 でなければなりません。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

線は、現在のペンを使用して、最初の点から後続の点まで描画されます。 メンバー関数`LineTo`とは異なり`Polyline`、関数は現在の位置を使用も更新もしません。

詳細については、Windows SDK の[ポリライン](/windows/win32/api/wingdi/nf-wingdi-polyline)を参照してください。

## <a name="cdcpolylineto"></a><a name="polylineto"></a>CDC::Pオリリント

1 つまたは複数の直線を描画します。

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>パラメーター

*Lppoints*<br/>
線の頂点を含む[POINT](/windows/win32/api/windef/ns-windef-point)データ構造の配列へのポイント。

*nカウント*<br/>
配列内のポイント数を指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

現在のペンを使用して、現在位置から*lpPoints*パラメーターで指定された最初の点まで線が描画されます。 追加の線ごとに、前の行の終点から*lpPoints*で指定された次の点まで描画されます。 `PolylineTo`現在の位置を最後の行の終了点に移動します。 この関数によって描画された線分が閉じた図形を形成する場合、図は塗りつぶされません。

## <a name="cdcpolypolygon"></a><a name="polypolygon"></a>CDC::Pオリーポリゴン

現在のポリゴン塗りつぶしモードを使用して塗りつぶされる 2 つ以上のポリゴンを作成します。

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>パラメーター

*Lppoints*<br/>
ポリゴンの`POINT`頂点を定義する構造または`CPoint`オブジェクトの配列を指します。

*lpPolyカウント*<br/>
整数の配列を指し、各整数の配列を指し、各整数は *、lpPoints*配列内のポリゴンの 1 つのポイントの数を指定します。

*nカウント*<br/>
*配列*内のエントリの数。 この数値は、描画するポリゴンの数を指定します。 この値は少なくとも 2 でなければなりません。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

ポリゴンが不整合になっているか、重なり合っている可能性があります。

関数の呼び出しで指定`PolyPolygon`された各ポリゴンは閉じる必要があります。 `Polygon`メンバー関数によって作成されたポリゴンとは異なり、作成`PolyPolygon`されたポリゴンは自動的に閉じられます。

この関数は、2 つ以上のポリゴンを作成します。 単一のポリゴンを作成するには、アプリケーションでメンバー`Polygon`関数を使用する必要があります。

現在のポリゴン塗りつぶしモードは、 および`GetPolyFillMode``SetPolyFillMode`メンバー関数を使用して取得または設定できます。

## <a name="cdcpolypolyline"></a><a name="polypolyline"></a>CDC::Pりポリライン

複数の一連の接続線分を描画します。

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>パラメーター

*Lppoints*<br/>
ポリラインの頂点を含む構造体の配列へのポイント。 ポリラインは連続して指定されます。

*lpポリポイント*<br/>
対応するポリゴンの*lpPoints*配列内のポイント数を指定する変数の配列を指します。 各エントリは 2 以上である必要があります。

*nカウント*<br/>
*lpPolyPoints*配列内のカウントの合計数を指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

線分は現在のペンを使用して描画されます。 セグメントによって形成された数字は塗りつぶされません。 現在の位置は、この関数によって使用も更新もされません。

## <a name="cdcptvisible"></a><a name="ptvisible"></a>CDC::P不可

指定したポイントがデバイス コンテキストのクリッピング領域内にあるかどうかを判断します。

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>パラメーター

*X*<br/>
点の論理 x 座標を指定します。

*Y*<br/>
点の論理 y 座標を指定します。

*ポイント*<br/>
論理座標をチェックインする点を指定します。 このパラメーターには、`POINT`構造体またはオブジェクトを`CPoint`渡すことができます。

### <a name="return-value"></a>戻り値

指定したポイントがクリッピング領域内にある場合は 0 以外の値を返します。それ以外の場合は 0。

## <a name="cdcqueryabort"></a><a name="queryabort"></a>CDC::クエリアボートアボート

印刷アプリケーションの[SetAbortProc](#setabortproc)メンバー関数によってインストールされた中止関数を呼び出し、印刷を終了するかどうかを問い合わせます。

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>戻り値

印刷を続行する必要がある場合、または中止プロシージャがない場合は、0 以外の値を返します。 印刷ジョブを終了する必要がある場合は 0 です。 戻り値は、abort 関数によって提供されます。

## <a name="cdcrealizepalette"></a><a name="realizepalette"></a>CDC::ア実現パレット

現在の論理パレットからシステム パレットにエントリをマップします。

```
UINT RealizePalette();
```

### <a name="return-value"></a>戻り値

論理パレット内のエントリ数が、システム パレットの異なるエントリにマップされた数を示します。 これは、論理パレットが最後に実現されてからのシステムパレットの変更に対応するために、この関数が再マップしたエントリの数を表します。

### <a name="remarks"></a>解説

論理カラー パレットは、色を多く消費するアプリケーションとシステムの間のバッファーとして機能し、アプリケーションが表示される独自の色や他のウィンドウで表示される色に影響を与えることなく、必要な数の色を使用できます。

ウィンドウに入力フォーカスがあり、 が呼`RealizePalette`び出されると、ウィンドウは、画面上で同時に使用可能な最大数まで、要求されたすべての色を表示します。 ウィンドウのパレットにない色も、使用可能な色に合わせて表示されます。

また、Windows は、使用可能な色に対して、関数を呼び出す非アクティブウィンドウによって要求された色とできるだけ近い色と一致します。 これにより、非アクティブウィンドウに表示される色の望ましくない変更が大幅に減少します。

## <a name="cdcrectangle"></a><a name="rectangle"></a>CDC::長方形

現在のペンを使用して四角形を描画します。

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
四角形の左上隅の x 座標を指定します (論理単位)。

*y1*<br/>
四角形の左上隅の y 座標を指定します (論理単位)。

*x2*<br/>
四角形の右下隅の x 座標を指定します (論理単位)。

*y2*<br/>
四角形の右下隅の y 座標を指定します (論理単位)。

*Lprect*<br/>
四角形を論理単位で指定します。 このパラメーターの`CRect`構造体にオブジェクトまたはポインターを`RECT`渡すことができます。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

四角形の内部は、現在のブラシを使用して塗りつぶされます。

四角形は、右辺と下の座標まで拡張しますが、含まれていません。 つまり、四角形の高さは*y2* - *y1、* 四角形の幅は*x2* - *x1*です。 四角形の幅と高さの両方が 2 単位より大きく、32,767 単位未満である必要があります。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

## <a name="cdcrectvisible"></a><a name="rectvisible"></a>CDC::整流可能

指定された四角形の一部が、表示コンテキストのクリッピング領域内にあるかどうかを判断します。

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>パラメーター

*Lprect*<br/>
指定された四`RECT`角形の`CRect`論理座標を格納する構造体またはオブジェクトへのポインター。

### <a name="return-value"></a>戻り値

指定された四角形の一部がクリッピング領域内にある場合は 0 以外の値を返します。それ以外の場合は 0。

## <a name="cdcreleaseattribdc"></a><a name="releaseattribdc"></a>CDC::リリースアットリブDC

NULL に設定`m_hAttribDC`するには、このメンバー関数を呼び出します。

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>解説

これにより、a が`Detach`発生することはありません。 出力デバイス コンテキストだけが`CDC`オブジェクトにアタッチされ、デタッチできるのはそのコンテキストだけです。

## <a name="cdcreleaseoutputdc"></a><a name="releaseoutputdc"></a>CDC::リリースアウトプットDC

メンバを NULL に設定`m_hDC`するには、このメンバー関数を呼び出します。

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>解説

出力デバイス コンテキストがオブジェクトにアタッチされている場合、このメンバー関数は`CDC`呼び出せません。 メンバー関数`Detach`を使用して、出力デバイス コンテキストをデタッチします。

## <a name="cdcresetdc"></a><a name="resetdc"></a>CDC::リセットDC

`CDC`オブジェクトによってラップされたデバイス コンテキストを更新します。

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>パラメーター

*を使用します。*<br/>
Windows`DEVMODE`構造体へのポインター。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

デバイス コンテキストは、Windows`DEVMODE`構造体で指定された情報から更新されます。 このメンバー関数は、属性のデバイス コンテキストのみをリセットします。

アプリケーションは通常、ウィンドウが`ResetDC`メッセージを処理するときにメンバー関数を`WM_DEVMODECHANGE`使用します。 また、このメンバー関数を使用して、文書の印刷中に用紙の向きや用紙のビンを変更することもできます。

このメンバー関数を使用して、ドライバー名、デバイス名、または出力ポートを変更することはできません。 ユーザーがポート接続またはデバイス名を変更した場合は、元のデバイス コンテキストを削除し、新しい情報を持つ新しいデバイス コンテキストを作成する必要があります。

このメンバー関数を呼び出す前に、デバイス コンテキストで選択されたすべてのオブジェクト (ストック オブジェクト以外) が選択されていることを確認する必要があります。

## <a name="cdcrestoredc"></a><a name="restoredc"></a>CDC::復元DC

*nSavedDC*で識別された以前の状態にデバイス コンテキストを復元します。

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>パラメーター

*n保存されたDC*<br/>
復元するデバイス コンテキストを指定します。 前`SaveDC`の関数呼び出しによって返される値を指定できます。 *nSavedDC*が -1 の場合、最後に保存されたデバイス コンテキストが復元されます。

### <a name="return-value"></a>戻り値

指定したコンテキストが復元された場合は 0 以外。それ以外の場合は 0。

### <a name="remarks"></a>解説

`RestoreDC`メンバー関数への以前の呼び出しによって作成されたスタックから状態情報をポップ`SaveDC`して、デバイス コンテキストを復元します。

スタックには、複数のデバイス コンテキストの状態情報を含めることができます。 *nSavedDC*で指定されたコンテキストがスタックの先頭にない場合は`RestoreDC`*、nSavedDC*で指定されたデバイス コンテキストとスタックの最上位との間のすべての状態情報を削除します。 削除された情報は失われます。

## <a name="cdcroundrect"></a><a name="roundrect"></a>CDC::ラウンドレック

現在のペンを使用して角が丸い四角形を描画します。

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
四角形の左上隅の x 座標を指定します (論理単位)。

*y1*<br/>
四角形の左上隅の y 座標を指定します (論理単位)。

*x2*<br/>
四角形の右下隅の x 座標を指定します (論理単位)。

*y2*<br/>
四角形の右下隅の y 座標を指定します (論理単位)。

*x3*<br/>
丸い角を描画するために使用する楕円の幅を指定します (論理単位)。

*y3*<br/>
丸い角を描画するために使用する楕円の高さを指定します (論理単位)。

*Lprect*<br/>
外接する四角形を論理単位で指定します。 このパラメーターの`CRect`構造体にオブジェクトまたはポインターを`RECT`渡すことができます。

*ポイント*<br/>
x 座標の*点*は、丸い角を描画する楕円の幅を指定します(論理単位)。 y 座標の*点*は、丸い角を描画する楕円の高さを(論理単位で)指定します。 このパラメーターには、`POINT`構造体またはオブジェクトを`CPoint`渡すことができます。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

四角形の内部は、現在のブラシを使用して塗りつぶされます。

この関数が描画する図形は、右と下の座標までは拡張されますが、含まれていません。 つまり、図の高さは*y2* - *y1、* 図形の幅は*x2* - *x1*です。 外接する四角形の高さと幅は、2 単位より大きく、32,767 単位未満である必要があります。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

## <a name="cdcsavedc"></a><a name="savedc"></a>CDC::セーブDC

状態情報 (クリッピング領域、選択したオブジェクト、マッピング モードなど) を Windows によって維持されるコンテキスト スタックにコピーして、デバイス コンテキストの現在の状態を保存します。

```
virtual int SaveDC();
```

### <a name="return-value"></a>戻り値

保存されたデバイス コンテキストを識別する整数。 エラーが発生した場合は 0 です。 この戻り値を使用して、 を呼び出`RestoreDC`してデバイス コンテキストを復元できます。

### <a name="remarks"></a>解説

保存されたデバイス コンテキストは、 を使用`RestoreDC`して後で復元できます。

`SaveDC`デバイス コンテキスト状態をいくつでも保存するために、何度でも使用できます。

## <a name="cdcscaleviewportext"></a><a name="scaleviewportext"></a>CDC:スケールビューポートエクスタブ

現在の値に対するビューポート範囲を変更します。

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>パラメーター

*xNum*<br/>
現在の x 範囲を乗算する量を指定します。

*xデノム*<br/>
現在の x 範囲に*xNum*パラメーターの値を乗算した結果を除算する量を指定します。

*yNum*<br/>
現在の y 範囲を乗算する量を指定します。

*イデノム*<br/>
現在の y 範囲に*yNum*パラメーターの値を乗算した結果を除算する量を指定します。

### <a name="return-value"></a>戻り値

以前のビューポートの範囲 (デバイス単位) を`CSize`オブジェクトとして指定します。

### <a name="remarks"></a>解説

数式は次のように記述されます。

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

新しいビューポートの範囲は、現在の範囲に指定された分子を乗算し、指定された分母で除算することによって計算されます。

## <a name="cdcscalewindowext"></a><a name="scalewindowext"></a>CDC::スケールウィンドウエクスク

現在の値に対するウィンドウ範囲を変更します。

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>パラメーター

*xNum*<br/>
現在の x 範囲を乗算する量を指定します。

*xデノム*<br/>
現在の x 範囲に*xNum*パラメーターの値を乗算した結果を除算する量を指定します。

*yNum*<br/>
現在の y 範囲を乗算する量を指定します。

*イデノム*<br/>
現在の y 範囲に*yNum*パラメーターの値を乗算した結果を除算する量を指定します。

### <a name="return-value"></a>戻り値

前のウィンドウのエクステント (論理単位)`CSize`をオブジェクトとして指定します。

### <a name="remarks"></a>解説

数式は次のように記述されます。

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

新しいウィンドウ範囲は、現在の範囲に指定された分子を乗算し、指定された分母で除算することによって計算されます。

## <a name="cdcscrolldc"></a><a name="scrolldc"></a>CDC::スクロールDC

ビットの四角形を水平方向および垂直方向にスクロールします。

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>パラメーター

*Dx*<br/>
水平スクロールの単位数を指定します。

*Dy*<br/>
垂直スクロールの単位数を指定します。

*スクロール*<br/>
スクロールする四`RECT`角形の`CRect`座標を格納している構造体またはオブジェクトへのポインター。

*クリップ*<br/>
クリッピング四`RECT`角形の`CRect`座標を含む構造体またはオブジェクトへのポインター。 この四角形が*lpRectScroll*によって指される元の四角形よりも小さい場合、スクロールは小さい四角形でのみ発生します。

*更新*<br/>
スクロール処理によって検出された領域を識別します。 この`ScrollDC`関数は、この領域を定義します。必ずしも長方形ではありません。

*更新プログラム*<br/>
スクロール更新領域`RECT`に境界`CRect`を持つ四角形の座標を受け取る構造体またはオブジェクトへのポインター。 これは、再描画が必要な最大の矩形領域です。 関数が返すときの構造体またはオブジェクトの値は、指定されたデバイス コンテキストのマッピング モードに関係なく、クライアント座標で行われます。

### <a name="return-value"></a>戻り値

スクロールが実行された場合は 0 以外。それ以外の場合は 0。

### <a name="remarks"></a>解説

*lpRectUpdate*が NULL の場合、更新の四角形は計算されません。 *pRgnUpdate*と*lpRectUpdate*の両方が NULL の場合、更新領域は計算されません。 *pRgnUpdate*が NULL でない場合、スクロール処理によって検出された領域 (メンバー関数で定義されている領域) への有効な`ScrollDC`ポインターが含まれていると見なされます。 必要に応じて *、lpRectUpdate*で返される`CWnd::InvalidateRgn`更新領域を渡すことができます。

アプリケーションは、ウィンドウの`ScrollWindow`クライアント領域全体を`CWnd`スクロールする必要がある場合に、クラスのメンバー関数を使用する必要があります。 それ以外の場合は`ScrollDC`、 を使用する必要があります。

## <a name="cdcselectclippath"></a><a name="selectclippath"></a>CDC::クリップパスを選択します。

現在のパスをデバイス コンテキストのクリッピング領域として選択し、指定したモードを使用して、新しい領域と既存のクリップ領域を組み合わせます。

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>パラメーター

*nモード*<br/>
パスの使用方法を指定します。 次の値を使用できます。

- RGN_AND新しいクリップ領域には、現在のクリップ領域と現在のパスの交差 (重なり合う領域) が含まれます。

- RGN_COPY 新しいクリッピング領域が現在のパスです。

- RGN_DIFF新しいクリップ領域には、現在のクリップ領域の領域が含まれ、現在のパスの領域は除外されます。

- RGN_OR 新しいクリップ領域には、現在のクリップ領域と現在のパスの結合領域(結合領域)が含まれます。

- RGN_XOR新しいクリッピング領域には、現在のクリップ領域と現在のパスの結合が含まれますが、重なり合う領域は含み、領域は重複します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

識別されたデバイス コンテキストには、閉じたパスが含まれている必要があります。

## <a name="cdcselectcliprgn"></a><a name="selectcliprgn"></a>CDC::選択クリップルグン

指定した領域をデバイス コンテキストの現在のクリップ領域として選択します。

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>パラメーター

*Prgn*<br/>
選択する領域を識別します。

- この関数の最初のバージョンでは、この値が NULL の場合、クライアント領域全体が選択され、出力はウィンドウにクリップされます。

- この関数の 2 番目のバージョンでは、このハンドルは、RGN_COPY モードが指定されている場合にのみ NULL になります。

*nモード*<br/>
実行する操作を指定します。 次のいずれかの値を指定する必要があります。

- RGN_AND 新しいクリッピング領域は、現在のクリッピング領域と*pRgn*で識別される領域の重なり合う領域を結合します。

- RGN_COPY 新しいクリッピング領域は*pRgn*で識別される領域のコピーです。 これは、機能は の最初の`SelectClipRgn`バージョンと同じです。 *pRgn*で識別される領域が NULL の場合、新しいクリッピング領域はデフォルトのクリッピング領域になります (NULL 領域)。

- RGN_DIFF新しいクリッピング領域は、現在のクリッピング領域の領域と *、pRgn*で識別される領域から除外された領域を結合します。

- RGN_OR 新しいクリッピング領域は、現在のクリッピング領域と*pRgn*で識別される領域を結合します。

- RGN_XOR新しいクリッピング領域は、現在のクリッピング領域と*pRgn*で識別される領域を結合しますが、重なり合う領域は除外されます。

### <a name="return-value"></a>戻り値

リージョンの型。 次のいずれかの値を指定できます。

- [コンプレックス領域] 新しいクリップ領域の境界線が重なっています。

- エラー デバイス コンテキストまたは領域が無効です。

- 新しいクリッピング領域が空です。

- シンプル領域 新しいクリップ領域には、重なり合う境界線はありません。

### <a name="remarks"></a>解説

選択した領域のコピーのみが使用されます。 領域自体は、他のデバイス コンテキストの任意の数に選択することも、削除することもできます。

この関数は、指定された領域の座標がデバイス単位で指定されていることを前提としています。 一部のプリンタ デバイスでは、テキスト メトリックを表現するために必要な精度を維持するために、グラフィックス出力よりも高い解像度でテキスト出力をサポートしています。 これらのデバイスは、デバイス単位を高い解像度(テキスト単位)で報告します。 これらのデバイスは、グラフィックスの座標をスケーリングして、複数の報告されたデバイスユニットが 1 つのグラフィックユニットのみにマップされるようにします。 テキスト単位を使用して`SelectClipRgn`、常に関数を呼び出す必要があります。

GDI でグラフィック オブジェクトのスケーリングを行う必要があるアプリケーションでは、GETSCALINGFACTOR プリンターエスケープを使用して、スケーリング係数を決定できます。 このスケールファクターはクリッピングに影響します。 領域を使用してグラフィックスをクリップする場合、GDI は座標をスケーリング係数で除算します。 領域を使用してテキストをクリップする場合、GDI はスケーリングの調整を行いません。 スケーリング係数が 1 の場合、座標は 2 で除算されます。スケーリング係数が 2 の場合、座標は 4 で除算されます。などなど。

## <a name="cdcselectobject"></a><a name="selectobject"></a>CDC::オブジェクトの選択

デバイス コンテキストにオブジェクトを選択します。

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>パラメーター

*ペン*<br/>
選択する[CPen](../../mfc/reference/cpen-class.md)オブジェクトへのポインター。

*pブラシ*<br/>
選択する[CBrush](../../mfc/reference/cbrush-class.md)オブジェクトへのポインター。

*フォント*<br/>
選択する[CFont](../../mfc/reference/cfont-class.md)オブジェクトへのポインター。

*ビットマップ*<br/>
選択する[CBitmap](../../mfc/reference/cbitmap-class.md)オブジェクトへのポインター。

*Prgn*<br/>
選択する[CRgn](../../mfc/reference/crgn-class.md)オブジェクトへのポインター。

*pObject*<br/>
選択する[CGdiObject](../../mfc/reference/cgdiobject-class.md)オブジェクトへのポインター。

### <a name="return-value"></a>戻り値

置換されるオブジェクトへのポインター。 これは、 など`CGdiObject``CPen`、 から派生したクラスのオブジェクトへのポインターです。 エラーが発生した場合、戻り値は NULL です。 この関数は、一時オブジェクトへのポインタを返します。 この一時オブジェクトは、1 つの Windows メッセージの処理中にのみ有効です。 詳細については、「`CGdiObject::FromHandle`」を参照してください。

region パラメーターを受け取るメンバー関数のバージョンは、メンバー関数と`SelectClipRgn`同じタスクを実行します。 戻り値は、次のいずれかになります。

- [コンプレックス領域] 新しいクリップ領域の境界線が重なっています。

- エラー デバイス コンテキストまたは領域が無効です。

- 新しいクリッピング領域が空です。

- シンプル領域 新しいクリップ領域には、重なり合う境界線はありません。

### <a name="remarks"></a>解説

Class`CDC`は、ペン、ブラシ、フォント、ビットマップ、領域など、特定の種類の GDI オブジェクトに特化した 5 つのバージョンを提供します。 新しく選択したオブジェクトは、同じタイプの前のオブジェクトを置き換えます。 たとえば、一般的なバージョン`SelectObject`の*pObject*が[CPen](../../mfc/reference/cpen-class.md)オブジェクトを指している場合、関数は現在のペンを*pObject*で指定されたペンに置き換えます。

アプリケーションは、ビットマップをメモリ デバイス コンテキストにのみ選択でき、一度に 1 つのメモリ デバイス コンテキストにしか選択できません。 ビットマップの形式は、モノクロであるか、デバイス コンテキストと互換性がある必要があります。それでない場合は、`SelectObject`エラーを返します。

Windows 3.1 以降では、`SelectObject`関数はメタファイルで使用されているかどうかにかかわらず、同じ値を返します。 以前のバージョンの Windows`SelectObject`では、メタファイルで使用された場合、成功の場合は 0 以外の値を返し、失敗した場合は 0 以外の値を返しました。

## <a name="cdcselectpalette"></a><a name="selectpalette"></a>CDC::パレットの選択

デバイス コンテキストの選択されたパレット オブジェクトとして*pPalette*で指定された論理パレットを選択します。

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>パラメーター

*をクリックします。*<br/>
選択する論理パレットを識別します。 このパレットは、メンバー関数`CPalette`[CreatePalette](../../mfc/reference/cpalette-class.md#createpalette)を使用して既に作成されている必要があります。

*bフォースバックグラウンド*<br/>
論理パレットを強制的にバックグラウンド パレットにするかどうかを指定します。 *bForceBackground*が 0 以外の場合、ウィンドウに入力フォーカスが設定されているかどうかに関係なく、選択したパレットは常にバックグラウンド パレットになります。 *bForceBackground*が 0 で、デバイス コンテキストがウィンドウにアタッチされている場合、ウィンドウに入力フォーカスがある場合、論理パレットはフォアグラウンド パレットになります。

### <a name="return-value"></a>戻り値

*pPalette*で`CPalette`指定されたパレットに置き換えられた論理パレットを識別するオブジェクトへのポインター。 エラーが発生した場合は NULL です。

### <a name="remarks"></a>解説

新しいパレットは、デバイス コンテキストに表示される色を制御するために GDI によって使用されるパレット オブジェクトになり、前のパレットを置き換えます。

アプリケーションは、複数のデバイス コンテキストに論理パレットを選択できます。 ただし、論理パレットを変更すると、そのパレットが選択されているすべてのデバイス コンテキストに影響します。 アプリケーションが複数のデバイス コンテキストにパレットを選択する場合、デバイス コンテキストはすべて同じ物理デバイスに属している必要があります。

## <a name="cdcselectstockobject"></a><a name="selectstockobject"></a>CDC::オブジェクトを選択します。

定義済みのストック ペン、ブラシ、またはフォントのいずれかに対応する[CGdiObject](../../mfc/reference/cgdiobject-class.md)オブジェクトを選択します。

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>パラメーター

*nIndex*<br/>
必要なストック オブジェクトの種類を指定します。 次のいずれかの値を指定できます。

- BLACK_BRUSHブラックブラシ。

- DKGRAY_BRUSHダークグレーブラシ。

- グレーブラシGRAY_BRUSH。

- HOLLOW_BRUSH中空ブラシ。

- LTGRAY_BRUSHライトグレーブラシ。

- NULL_BRUSH Null ブラシ。

- WHITE_BRUSHホワイトブラシ。

- BLACK_PEN黒いペン。

- NULL_PENヌルペン。

- WHITE_PEN白いペン。

- ANSI_FIXED_FONT ANSI 固定システム フォント。

- ANSI 可変システム フォントANSI_VAR_FONTします。

- DEVICE_DEFAULT_FONTデバイス依存フォントです。

- OEM 依存の固定フォントをOEM_FIXED_FONTします。

- SYSTEM_FONT システム フォント。 既定では、Windows はシステム フォントを使用して、メニュー、ダイアログ ボックス コントロール、およびその他のテキストを描画します。 ただし、ダイアログやウィンドウで使用されるフォントを取得するためにSYSTEM_FONTに依存しないことをお勧めします。 代わりに、SPI_GETNONCLIENTMETRICS`SystemParametersInfo`パラメーターを指定して関数を使用して、現在のフォントを取得します。 `SystemParametersInfo`では、現在のテーマを考慮し、キャプション、メニュー、メッセージダイアログのフォント情報を提供します。

- SYSTEM_FIXED_FONT バージョン 3.0 より前の Windows で使用される固定幅システム フォント。 このオブジェクトは、以前のバージョンの Windows との互換性のために使用できます。

- DEFAULT_PALETTE既定のカラー パレットです。 このパレットは、システム パレットの 20 色の静的カラーで構成されます。

### <a name="return-value"></a>戻り値

関数が正常に`CGdiObject`実行された場合に置き換えられたオブジェクトへのポインター。 実際に指されているオブジェクトは[、CPen](../../mfc/reference/cpen-class.md) [、CBrush](../../mfc/reference/cbrush-class.md)、または[CFont](../../mfc/reference/cfont-class.md)オブジェクトです。 呼び出しが失敗した場合、戻り値は NULL です。

## <a name="cdcsetabortproc"></a><a name="setabortproc"></a>CDC::セットアボート・プロセス

印刷ジョブの中止手順をインストールします。

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>パラメーター

*lpfn*<br/>
中止プロシージャとしてインストールする中止関数へのポインター。 コールバック関数の詳細については[、「CDC のコールバック関数::SetAbortProc](callback-functions-used-by-mfc.md#setabortproc)」を参照してください。

### <a name="return-value"></a>戻り値

関数の結果を指定`SetAbortProc`します。 次の値の一部は他の値よりも可能性が高いですが、すべて可能です。

- SP_ERROR一般エラーです。

- SP_OUTOFDISKスプールに使用できるディスク領域が不足しており、これ以上使用可能な領域はありません。

- SP_OUTOFMEMORY スプールに使用できるメモリが不足しています。

- SP_USERABORT ユーザーは印刷マネージャーを使用してジョブを終了しました。

### <a name="remarks"></a>解説

アプリケーションがスプール中に印刷ジョブを取り消すことを許可する場合は[、StartDoc](#startdoc)メンバー関数を使用して印刷ジョブを開始する前に、中止機能を設定する必要があります。 印刷マネージャは、スプール中に abort 関数を呼び出して、アプリケーションが印刷ジョブを取り消したり、ディスク領域不足の状態を処理したりできるようにします。 中断機能が設定されていない場合、スプーリング用の十分なディスク領域がない場合、印刷ジョブは失敗します。

Visual C++ の機能により、 に渡されるコールバック関数の作成が`SetAbortProc`簡略化されることに注意してください。 メンバー関数に渡される`EnumObjects`アドレスは、`__declspec(dllexport)``__stdcall`呼び出し規約でエクスポートされた関数へのポインターです。

また、アプリケーションのモジュール定義ファイル内の**EXPORTS**ステートメントで関数名をエクスポートする必要はありません。 代わりに **、EXPORT**関数修飾子を使用できます。

**BOOL コールバックエクスポート**ファンクション( **HDC** `int`), **);**

コンパイラが名前でエイリアスを使用せずにエクスポートするための適切なエクスポート レコードを生成するようにします。 これはほとんどのニーズに適しています。 序数による関数のエクスポートやエクスポートの別名変更など、特殊なケースがある場合は、モジュール定義ファイルで**EXPORTS**ステートメントを使用する必要があります。

コールバック登録インターフェイスはタイプ セーフになりました (特定のコールバックに対して適切な種類の関数を指す関数ポインタを渡す必要があります)。

また、すべてのコールバック関数は、コールバック境界を越えて例外をスローすることはできないので、Windows に戻る前に Microsoft Foundation の例外をトラップする必要があることに注意してください。 例外の詳細については、記事「[例外](../../mfc/exception-handling-in-mfc.md)」を参照してください。

## <a name="cdcsetarcdirection"></a><a name="setarcdirection"></a>CDC::セットアークディレクション

円弧関数および四角形関数で使用する描画方向を設定します。

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>パラメーター

*アークディレクション*<br/>
新しい円弧の方向を指定します。 このパラメーターには、次のいずれかの値を指定できます。

- AD_COUNTERCLOCKWISE反時計回りに描かれた図形。

- AD_CLOCKWISE時計回りに描かれた図形。

### <a name="return-value"></a>戻り値

正常に実行された場合は、古い円弧の方向を指定します。それ以外の場合は 0。

### <a name="remarks"></a>解説

既定の方向は反時計回りです。 この`SetArcDirection`関数は、次の関数が描画する方向を指定します。

|Arc|円グラフ|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

## <a name="cdcsetattribdc"></a><a name="setattribdc"></a>CDC::セットリブDC

属性デバイス コンテキストを設定するには、`m_hAttribDC`この関数を呼び出します。

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>パラメーター

*Hdc*<br/>
Windows デバイス コンテキスト。

### <a name="remarks"></a>解説

このメンバー関数は、デバイス コンテキストをオブジェクトに`CDC`アタッチしません。 `CDC`出力デバイス コンテキストだけがオブジェクトにアタッチされます。

## <a name="cdcsetbkcolor"></a><a name="setbkcolor"></a>CDC::セットBkカラー

現在の背景色を指定した色に設定します。

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>パラメーター

*Crcolor*<br/>
新しい背景色を指定します。

### <a name="return-value"></a>戻り値

RGB カラー値としての前の背景色。 エラーが発生した場合、戻り値は 0x80000000 です。

### <a name="remarks"></a>解説

背景モードが OPAQUE の場合、システムは背景色を使用して、スタイル付きの線分のギャップ、ブラシのハッチング線の間のギャップ、および文字セルの背景を塗りつぶします。 また、カラーとモノクロのデバイス コンテキスト間でビットマップを変換する際にも、背景色が使用されます。

指定した色をデバイスで表示できない場合は、背景色が最も近い物理色に設定されます。

## <a name="cdcsetbkmode"></a><a name="setbkmode"></a>CDC::セットBkモード

バックグラウンド モードを設定します。

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>パラメーター

*をクリックします。*<br/>
設定するモードを指定します。 このパラメーターには、次のいずれかの値を指定できます。

- 不透明な背景は、テキスト、ハッチング ブラシ、またはペンが描画される前に、現在の背景色で塗りつぶされます。 これはデフォルトのバックグラウンドモードです。

- 図面の前に透明な背景は変更されません。

### <a name="return-value"></a>戻り値

前のバックグラウンド モード。

### <a name="remarks"></a>解説

背景モードでは、テキスト、ハッチングブラシ、または実線でないペンスタイルを描画する前に、描画サーフェイス上の既存の背景色を削除するかどうかを定義します。

### <a name="example"></a>例

  [「CWnd::OnCtlColor」](../../mfc/reference/cwnd-class.md#onctlcolor)の例を参照してください。

## <a name="cdcsetboundsrect"></a><a name="setboundsrect"></a>CDC::セットバウンドレクト

指定したデバイス コンテキストの外接四角形情報の蓄積を制御します。

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>パラメーター

*を指定します。*<br/>
外接する`RECT`四角形`CRect`の設定に使用される構造体またはオブジェクトへのポインター。 四角形の寸法は、論理座標で指定されます。 このパラメーターは NULL にすることができます。

*フラグ*<br/>
新しい四角形を累積した四角形と組み合わせる方法を指定します。 このパラメーターは、次の値の組み合わせにすることができます。

- DCB_ACCUMULATE *lpRectBounds*で指定された四角形を外接する四角形に追加します (四角形ユニオン演算を使用)。

- DCB_DISABLE 境界の累積をオフにします。

- DCB_ENABLE 境界の累積をオンにします。 (境界累積のデフォルト設定は無効です。

### <a name="return-value"></a>戻り値

関数が成功した場合の外接する四角形の現在の状態。 *フラグ*と同様に、戻り値は**DCB_** 値の組み合わせになります。

- DCB_ACCUMULATE 外接する四角形が空ではありません。 この値は常に設定されます。

- DCB_DISABLE境界の蓄積がオフです。

- DCB_ENABLE境界の蓄積がオンです。

### <a name="remarks"></a>解説

Windows では、すべての描画操作に外接する四角形を保持できます。 この四角形は、アプリケーションによってクエリを実行し、リセットできます。 描画境界は、ビットマップ キャッシュを無効にする場合に便利です。

## <a name="cdcsetbrushorg"></a><a name="setbrushorg"></a>CDC::セットブラシオルグ

GDI が、アプリケーションがデバイス コンテキストに選択する次のブラシに割り当てる原点を指定します。

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
新しい原点の x 座標 (デバイス単位) を指定します。 この値は 0 から 7 の範囲にする必要があります。

*Y*<br/>
新しい原点の y 座標 (デバイス単位) を指定します。 この値は 0 から 7 の範囲にする必要があります。

*ポイント*<br/>
新しい原点の x 座標と y 座標を指定します。 各値は 0 から 7 の範囲内にする必要があります。 このパラメーターには、`POINT`構造体またはオブジェクトを`CPoint`渡すことができます。

### <a name="return-value"></a>戻り値

ブラシの前の原点 (デバイス単位)。

### <a name="remarks"></a>解説

ブラシの原点のデフォルトの座標は(0, 0)です。 ブラシの原点を`UnrealizeObject`変更するには、`CBrush`オブジェクトの関数を呼び出し、`SetBrushOrg`を呼び出`SelectObject`し、メンバー関数を呼び出して、デバイス コンテキストにブラシを選択します。

ストック`CBrush`オブジェクトには`SetBrushOrg`使用しないでください。

## <a name="cdcsetcoloradjustment"></a><a name="setcoloradjustment"></a>CDC::カラー調整

指定した値を使用して、デバイス コンテキストの色調整値を設定します。

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>パラメーター

*調整する*<br/>
色調整値を含む[COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment)データ構造体へのポイント。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

色調整値は、ハーフトーン モードが設定されている場合にメンバー関数を呼び`CDC::StretchBlt`出す場合にソース ビットマップの入力色を調整するために使用されます。

## <a name="cdcsetdcbrushcolor"></a><a name="setdcbrushcolor"></a>CDC::セットDCブラシカラー

現在のデバイス コンテキスト (DC) ブラシの色を、指定した色の値に設定します。

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>パラメーター

*Crcolor*<br/>
新しいブラシの色を指定します。

### <a name="return-value"></a>戻り値

関数が成功した場合、戻り値は、前の DC ブラシの色を COLORREF 値として指定します。

関数が失敗した場合、戻り値は CLR_INVALID です。

### <a name="remarks"></a>解説

このメソッドは、Windows SDK で説明されているように、関数[SetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-setdcbrushcolor)の機能をエミュレートします。

## <a name="cdcsetdcpencolor"></a><a name="setdcpencolor"></a>CDC::セットDCペンカラー

現在のデバイス コンテキスト (DC) ペンの色を、指定した色の値に設定します。

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>パラメーター

*Crcolor*<br/>
新しいペンの色を指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

このメンバー関数は、Windows SDK で説明されているように、Win32 関数[SetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-setdcpencolor)を使用します。

## <a name="cdcsetgraphicsmode"></a><a name="setgraphicsmode"></a>CDC::セットグラフィックスモード

指定したデバイス コンテキストのグラフィックス モードを設定します。

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>パラメーター

*iモード*<br/>
グラフィックス モードを指定します。 このパラメーターに使用できる値の一覧については、「 [SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode)」を参照してください。

### <a name="return-value"></a>戻り値

正常に実行された場合に、古いグラフィックス モードを返します。

失敗した場合は 0 を返します。 拡張エラー情報を取得するには[、GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)を呼び出します。

### <a name="remarks"></a>解説

このメソッドは、Windows GDI 関数[を](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode)ラップします。

## <a name="cdcsetlayout"></a><a name="setlayout"></a>CDC::セットレイアウト

デバイス コンテキストのテキストとグラフィックスのレイアウトを右から左に変更します。

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>パラメーター

*dw レイアウト*<br/>
デバイス コンテキスト レイアウトとビットマップ コントロール フラグ。 以下の値を組み合わせることができます。

|[値]|意味|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|[CDC::BitBlt](#bitblt)と[CDC::StretchBlt](#stretchblt)への呼び出しのリフレクションを無効にします。|
|LAYOUT_RTL|既定の水平レイアウトを右から左に設定します。|
|LAYOUT_LTR|既定のレイアウトを左から右に設定します。|

### <a name="return-value"></a>戻り値

正常に実行された場合は、デバイス コンテキストの前のレイアウト。

失敗した場合は、GDI_ERROR。 拡張エラー情報を取得するには[、GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)を呼び出します。

### <a name="remarks"></a>解説

通常、ウィンドウを呼び出`SetLayout`しません。 ウィンドウ内の右から左へのレイアウトを制御するには、WS_EX_RTLREADINGなどの[拡張ウィンドウ スタイル](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)を設定します。 プリンターやメタファイルなどのデバイス コンテキストは、このレイアウトを継承しません。 右から左に表示するレイアウトのデバイス コンテキストを設定する唯一の方法は`SetLayout`、 を呼び出す方法です。

**SetLayout(LAYOUT_RTL**を`SetLayout`呼び出すと、マッピング モードが自動的にMM_ISOTROPICに変更されます。 その結果[、GetMapMode](#getmapmode)への後続の呼び出しは、MM_TEXTではなくMM_ISOTROPICを返します。

多くのビットマップを使用する場合など、左から右へのレイアウトを保持する必要がある場合があります。 このような場合は、 または`BitBlt``StretchBlt`を呼び出してイメージをレンダリングし *、dwLayout*のビットマップ コントロール フラグを LAYOUT_BITMAPORIENTATIONPRESERVED に設定します。

LAYOUT_RTLフラグを使用してレイアウトを変更すると、通常は左右を指定するフラグが逆になります。 混乱を避けるため、標準フラグの代替名を定義する必要があります。 推奨される代替フラグ名の一覧については、Windows SDK[の「SetLayout」](/windows/win32/api/wingdi/nf-wingdi-setlayout)を参照してください。

## <a name="cdcsetmapmode"></a><a name="setmapmode"></a>CDC::セットマップモード

マッピング モードを設定します。

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>パラメーター

*マップモード*<br/>
新しいマッピング モードを指定します。 次のいずれかの値を指定できます。

- MM_ANISOTROPIC論理単位は、任意にスケーリングされた軸を持つ任意の単位に変換されます。 マッピング モードを MM_ANISOTROPIC に設定しても、現在のウィンドウやビューポートの設定は変更されません。 単位、方向、およびスケーリングを変更するには、[メンバー](#setwindowext)関数を呼び出します[SetViewportExt](#setviewportext)。

- MM_HIENGLISH 各論理単位は 0.001 インチに変換されます。 正の x は右です。正の y がアップしています。

- MM_HIMETRIC 各論理単位は 0.01 ミリメートルに変換されます。 正の x は右です。正の y がアップしています。

- MM_ISOTROPIC論理単位は、等しくスケーリングされた軸を持つ任意の単位に変換されます。つまり、x 軸に沿った 1 単位は、y 軸に沿った 1 単位に等しくなります。 および`SetWindowExt``SetViewportExt`メンバー関数を使用して、目的の単位と軸の方向を指定します。 GDI は、x と y の単位が同じサイズで維持されるように、必要に応じて調整を行います。

- MM_LOENGLISH 各論理単位は 0.01 インチに変換されます。 正の x は右です。正の y がアップしています。

- MM_LOMETRIC各論理単位は 0.1 ミリメートルに変換されます。 正の x は右です。正の y がアップしています。

- MM_TEXT 各論理単位は 1 つのデバイス ピクセルに変換されます。 正の x は右です。正の y がダウンしています。

- MM_TWIPS 各論理単位は 1 ポイントの 1/20 に変換されます。 (ポイントは 1/72 インチなので、1/1440 インチです。正の x は右です。正の y がアップしています。

### <a name="return-value"></a>戻り値

前のマッピング モード。

### <a name="remarks"></a>解説

マッピング・モードは、論理単位を装置単位に変換するために使用される測定単位を定義します。また、デバイスの x 軸と y 軸の方向も定義します。 GDI は、マッピング モードを使用して、論理座標を適切なデバイス座標に変換します。 MM_TEXTモードでは、アプリケーションはデバイスピクセルで動作し、1単位は1ピクセルに等しくなります。 ピクセルの物理的なサイズは、デバイスごとに異なります。

MM_HIENGLISH、MM_HIMETRIC、MM_LOENGLISH、MM_LOMETRIC、およびMM_TWIPSモードは、物理的に意味のある単位 (インチやミリメートルなど) で描画する必要があるアプリケーションに役立ちます。 MM_ISOTROPICモードでは、画像の正確な形状を維持することが重要な場合に便利な 1:1 のアスペクト比が保証されます。 MM_ANISOTROPICモードでは、x 座標と y 座標を個別に調整できます。

> [!NOTE]
> [SetLayout](#setlayout)を呼び出して DC (デバイス コンテキスト) を右から左`SetLayout`へのレイアウトに変更すると、マッピング モードが自動的にMM_ISOTROPICに変更されます。

### <a name="example"></a>例

  [例については、CView::OnPrepareDC を参照](../../mfc/reference/cview-class.md#onpreparedc)してください。

## <a name="cdcsetmapperflags"></a><a name="setmapperflags"></a>CDC::セットマッパーフラグ

論理フォントを物理フォントに変換するときにフォント マッパーが使用するメソッドを変更します。

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>パラメーター

*ドフフラグ*<br/>
フォント マッパーがフォントの縦横の高さと幅をデバイスに合わせようとするかどうかを指定します。 この値がASPECT_FILTERINGされると、マッパーは、x-aspect と y-aspect が指定されたデバイスのものと完全に一致するフォントのみを選択します。

### <a name="return-value"></a>戻り値

フォント マッパー フラグの前の値。

### <a name="remarks"></a>解説

アプリケーションは、フォント`SetMapperFlags`マッパーが、指定されたデバイスの縦横比と完全に一致する物理フォントのみを選択しようとする場合に使用できます。

ラスター フォントのみを使用するアプリケーションでは、この`SetMapperFlags`関数を使用して、フォント マッパーで選択されたフォントが、指定されたデバイスで魅力的で読み取り可能であることを確認できます。 スケーラブル (TrueType) フォントを使用するアプリケーションは通常`SetMapperFlags`、 を使用しません。

論理フォントの仕様に一致する縦横比が物理フォントに存在しない場合、GDI は新しい縦横比を選択し、この新しい縦横比に一致するフォントを選択します。

## <a name="cdcsetmiterlimit"></a><a name="setmiterlimit"></a>CDC::セットマイターリミット

デバイス コンテキストのマイター結合の長さの制限を設定します。

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>パラメーター

*ミターリミット*<br/>
デバイス コンテキストの新しいマイター制限を指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

マイタの長さは、結合の内側のラインウォールの交点から、結合の外側のラインウォールの交点までの距離として定義されます。 マイター限界は、線幅に対するマイター長の最大許容比率です。 デフォルトのマイター制限は 10.0 です。

## <a name="cdcsetoutputdc"></a><a name="setoutputdc"></a>CDC::出力DC

出力デバイス コンテキストを設定するには、`m_hDC`このメンバー関数を呼び出します。

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>パラメーター

*Hdc*<br/>
Windows デバイス コンテキスト。

### <a name="remarks"></a>解説

このメンバー関数は、デバイス コンテキストが`CDC`オブジェクトにアタッチされていない場合にのみ呼び出すことができます。 このメンバー関数は`m_hDC`、設定されますが、デバイス コンテキストをオブジェクト`CDC`にアタッチしません。

## <a name="cdcsetpixel"></a><a name="setpixel"></a>CDC::セットピクセル

指定したポイントのピクセルを *、crColor*で指定した色の最も近似値に設定します。

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
設定する点の論理 x 座標を指定します。

*Y*<br/>
設定する点の論理 y 座標を指定します。

*Crcolor*<br/>
ポイントの描画に使用する色を指定するカラーレフ RGB 値。 この値の説明については、Windows SDK の[COLORREF](/windows/win32/gdi/colorref)を参照してください。

*ポイント*<br/>
設定する点の論理 x 座標と y 座標を指定します。 このパラメーターには、`POINT`構造体またはオブジェクトを`CPoint`渡すことができます。

### <a name="return-value"></a>戻り値

ポイントが実際に描画される色の RGB 値。 この値は、そのカラーの近似値を使用する場合 *、crColor*で指定された値とは異なる場合があります。 関数が失敗した場合 (ポイントがクリッピング領域の外側にある場合)、戻り値は -1 です。

### <a name="remarks"></a>解説

ポイントは、クリッピング領域内になければなりません。 ポイントがクリッピング領域にない場合、関数は何も実行しません。

一部のデバイスでは、`SetPixel` 関数がサポートされていません。 デバイスが をサポート`SetPixel`しているかどうかを確認するには、RASTERCAPS インデックスを使用して`GetDeviceCaps`メンバー関数を呼び出し、RC_BITBLT フラグの戻り値を確認します。

## <a name="cdcsetpixelv"></a><a name="setpixelv"></a>CDC::セットピクセルV

指定した座標のピクセルを、指定した色の最も近似値に設定します。

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
設定する点の x 座標を論理単位で指定します。

*Y*<br/>
設定する点の y 座標を論理単位で指定します。

*Crcolor*<br/>
ポイントの描画に使用する色を指定します。

*ポイント*<br/>
設定する点の論理 x 座標と y 座標を指定します。 このパラメーターには[、POINT](/windows/win32/api/windef/ns-windef-point)データ構造または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)オブジェクトのいずれかを渡すことができます。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

ポイントは、クリップ領域とデバイス サーフェスの可視部分の両方に配置する必要があります。 すべてのデバイスがメンバー関数をサポートしているわけではありません。 詳細については、メンバー関数のRC_BITBLT機能を`CDC::GetDeviceCaps`参照してください。 `SetPixelV`実際に描画`SetPixel`された点の色値を返す必要がないため、より高速です。

## <a name="cdcsetpolyfillmode"></a><a name="setpolyfillmode"></a>CDC::セットポリフィルモード

ポリゴン塗りつぶしモードを設定します。

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>パラメーター

*nポリフィルモード*<br/>
新しい塗りつぶしモードを指定します。 この値は、代替または巻き上げのいずれかです。 Windows で設定される既定のモードは代替モードです。

### <a name="return-value"></a>戻り値

正常終了した場合は、直前の塗りつぶしモード。それ以外の場合は 0。

### <a name="remarks"></a>解説

ポリゴン塗りつぶしモードが ALTERNATE の場合、各スキャン ラインの奇数ポリゴン側と偶数数のポリゴン辺の間の領域が塗りつぶされます。 つまり、システムは、第 1 側と 2 番目の側、3 番目と 4 番目の側の間の領域を塗りつぶします。 これが既定のモードです。

ポリゴン充填モードが WINDING の場合、図が描画された方向を使用して、領域を塗りつぶすかどうかを決定します。 ポリゴン内の各線分セグメントは、時計回りまたは反時計回りの方向に描画されます。 囲まれた領域から図形の外側に描画された架空の線が時計回りの線分セグメントを通過すると、カウントが増分されます。 線が反時計回りの線分を通過すると、カウントはデクリメントされます。 線が図の外側に達したときにカウントが 0 以外の場合、領域は塗りつぶされます。

## <a name="cdcsetrop2"></a><a name="setrop2"></a>CDC::セットロップ2

現在の描画モードを設定します。

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>パラメーター

*をクリックします。*<br/>
新しい描画モードを指定します。 次のいずれかの値を指定できます。

- R2_BLACKピクセルは常に黒です。

- R2_WHITEピクセルは常に白です。

- R2_NOPピクセルは変更されません。

- R2_NOTピクセルは画面の色の逆です。

- R2_COPYPENピクセルはペンの色です。

- R2_NOTCOPYPENピクセルはペンの色の逆です。

- R2_MERGEPENNOTピクセルは、ペンの色と画面の色の逆 (最終ピクセル = (画面ピクセルではない) またはペンの組み合わせです。

- R2_MASKPENNOTピクセルは、ペンと画面の逆の両方に共通する色の組み合わせです(最終ピクセル = (画面ピクセルではない) とペン)。

- R2_MERGENOTPENピクセルは、画面の色とペンの色の逆 (最終ピクセル = (ペンなし) または画面ピクセルの組み合わせです。

- R2_MASKNOTPENピクセルは、画面とペンの逆の両方に共通する色の組み合わせです(最終ピクセル = (ペンなし) と画面ピクセル)。

- R2_MERGEPENピクセルは、ペンの色と画面の色(最終ピクセル= ペンまたは画面ピクセル)の組み合わせです。

- R2_NOTMERGEPENピクセルは、R2_MERGEPEN色の逆です(最終ピクセル = NOT(ペンまたは画面ピクセル))。

- R2_MASKPENピクセルは、ペンと画面の両方に共通する色の組み合わせです(最終ピクセル = ペンと画面ピクセル)。

- R2_NOTMASKPENピクセルは、R2_MASKPEN色の逆です(最終ピクセル = NOT(ペンと画面ピクセル))。

- R2_XORPENピクセルはペンまたは画面内の色の組み合わせですが、両方に含まれていません (最終ピクセル = ペン XOR スクリーンピクセル)。

- R2_NOTXORPENピクセルは、R2_XORPEN色の逆です(最終ピクセル = NOT(ペンXORスクリーンピクセル))。

### <a name="return-value"></a>戻り値

前の描画モード。

これは、Windows SDK で指定された値のいずれかです。

### <a name="remarks"></a>解説

描画モードは、ペンの色と塗りつぶされたオブジェクトの内部を、表示サーフェス上の既に表示されている色と組み合わせる方法を指定します。

描画モードはラスター デバイス専用です。ベクトルデバイスには適用されません。 描画モードは、2 項演算子 AND、OR、XOR (排他的 OR) と単項演算 NOT を使用して、2 つの変数のすべてのブール値の組み合わせを表す 2 進ラスター演算コードです。

## <a name="cdcsetstretchbltmode"></a><a name="setstretchbltmode"></a>CDC::セットストレッチブルトモード

メンバー関数のビットマップストレッチ モードを`StretchBlt`設定します。

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>パラメーター

*ストレッチモード*<br/>
伸縮モードを指定します。 次のいずれかの値を指定できます。

|[値]|説明|
|-----------|-----------------|
|ブラックンホワイト|削除されたピクセルと既存のピクセルのカラー値を使用して、ブール演算 AND 演算を実行します。 ビットマップがモノクロ ビットマップの場合、このモードでは白いピクセルを犠牲にして黒のピクセルが保持されます。|
|カラーオンカラー|ピクセルを削除します。 このモードでは、情報を保持せずに、すべてのピクセルの行を削除します。|
|ハーフトーン|コピー元の四角形のピクセルを、移動先の四角形のピクセル ブロックにマップします。 ピクセルのターゲット ブロックの平均色は、ソース ピクセルの色に近似します。|
||ハーフトーンストレッチ モードを設定した後、アプリケーションは、Win32 関数[SetBrushOrgEx](/windows/win32/api/wingdi/nf-wingdi-setbrushorgex)を呼び出してブラシの原点を設定する必要があります。 それが失敗した場合、ブラシのずれが発生します。|
|STRETCH_ANDSCANS|**ウィンドウズ 95/98**: ブラックロンホワイトと同じ|
|STRETCH_DELETESCANS|**ウィンドウズ 95/98**: カラーオンカラーと同じ|
|STRETCH_HALFTONE|**ウィンドウズ 95/98**: ハーフトーンと同じ.|
|STRETCH_ORSCANS|**ウィンドウズ 95/98**: ホワイトノンブラックと同じ|
|ホワイトノンブラック|削除されたピクセルと既存のピクセルのカラー値を使用して、ブール演算 OR 演算を実行します。 ビットマップがモノクロ ビットマップの場合、このモードでは白いピクセルが保持され、黒のピクセルが犠牲になります。|

### <a name="return-value"></a>戻り値

前のストレッチ モード。 STRETCH_ANDSCANS、STRETCH_DELETESCANS、またはSTRETCH_ORSCANSを指定できます。

### <a name="remarks"></a>解説

ビットマップストレッチ モードは、関数を使用して圧縮されるビットマップから情報を削除する方法を定義します。

ブラックオンホワイト (STRETCH_ANDSCANS) モードと WhiteonBLACK (STRETCH_ORSCANS) モードは、通常、モノクロ ビットマップで前景ピクセルを保持するために使用されます。 COLORONCOLOR (STRETCH_DELETESCANS) モードは、通常、カラー ビットマップのカラーを保持するために使用されます。

ハーフトーン モードでは、他の 3 つのモードよりもソース イメージの処理が多くなります。それは他のものより遅いですが、より高品質のイメージを生成します。 また、ブラシ`SetBrushOrgEx`のずれを避けるために、ハーフトーンモードを設定した後に呼び出す必要があることにも注意してください。

デバイス ドライバーの機能によっては、追加のストレッチ モードも使用できる場合があります。

## <a name="cdcsettextalign"></a><a name="settextalign"></a>CDC::テキスト整列

テキスト配置フラグを設定します。

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>パラメーター

*Nflags*<br/>
テキスト配置フラグを指定します。 フラグは、ポイントとテキストに境界を持つ四角形の関係を指定します。 ポイントは、現在位置またはテキスト出力関数で指定された座標のいずれかです。 テキストに境界を設定する四角形は、テキスト文字列内の隣接する文字セルによって定義されます。 *nFlags*パラメーターには、次の 3 つのカテゴリから 1 つ以上のフラグを指定できます。 各カテゴリからフラグを 1 つだけ選択します。 最初のカテゴリは、X 方向のテキストの配置に影響します。

- TA_CENTER外接する四角形の水平方向の中心にポイントを配置します。

- TA_LEFT外接する四角形の左側にポイントを配置します。 これが既定の設定です。

- TA_RIGHT外接する四角形の右側にポイントを配置します。

2 番目のカテゴリは、y 方向のテキストの配置に影響します。

- TA_BASELINE選択したフォントの基線にポイントを配置します。

- TA_BOTTOM外接する四角形の下端にポイントを配置します。

- TA_TOP外接する四角形の上端にポイントを配置します。 これが既定の設定です。

3 番目のカテゴリは、テキストの書き込み時に現在位置を更新するかどうかを決定します。

- TA_NOUPDATECP テキスト出力関数を呼び出した後、現在位置を更新しません。 これが既定の設定です。

- TA_UPDATECP テキスト出力関数を呼び出した後の現在の x 位置を更新します。 新しい位置は、テキストの外接する四角形の右側にあります。 このフラグを設定すると、`TextOut`メンバー関数の呼び出しで指定された座標は無視されます。

### <a name="return-value"></a>戻り値

正常に実行された場合は、直前のテキスト配置設定。 下位バイトには水平設定が含まれ、上位バイトには垂直設定が含まれます。それ以外の場合は 0。

### <a name="remarks"></a>解説

および`TextOut``ExtTextOut`メンバー関数は、ディスプレイまたはデバイス上のテキスト文字列を配置するときに、これらのフラグを使用します。 フラグは、特定のポイントとテキストに境界を持つ四角形との関係を指定します。 この点の座標は、`TextOut`メンバー関数にパラメーターとして渡されます。 テキストに境界を設定する四角形は、テキスト文字列内の隣接する文字セルによって形成されます。

## <a name="cdcsettextcharacterextra"></a><a name="settextcharacterextra"></a>テキスト文字エクストラ

文字間の間隔を設定します。

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>パラメーター

*nチャルエクストラ*<br/>
各文字に追加する余分なスペースの量を論理単位で指定します。 現在のマッピング モードが`MM_TEXT`を使用しない場合は *、nCharExtra*が変換され、最も近いピクセルに丸められます。

### <a name="return-value"></a>戻り値

直前の文字間の間隔の量。

### <a name="remarks"></a>解説

GDI は、デバイス コンテキストにテキスト行を書き込むときに、区切り文字を含む各文字にこの間隔を追加します。 文字間間隔のデフォルト値は 0 です。

## <a name="cdcsettextcolor"></a><a name="settextcolor"></a>テキストの色を設定します。

テキストの色を指定した色に設定します。

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>パラメーター

*Crcolor*<br/>
テキストの色を RGB カラー値として指定します。

### <a name="return-value"></a>戻り値

直前のテキストの色の RGB 値。

### <a name="remarks"></a>解説

このデバイス コンテキストにテキストを書き込むとき、およびビットマップを色とモノクロのデバイス コンテキスト間で変換するときにも、システムはこのテキスト色を使用します。

指定した色をデバイスで表すことができない場合は、テキストの色が最も近い物理色に設定されます。 文字の背景色は、`SetBkColor`および`SetBkMode`メンバー関数で指定します。

### <a name="example"></a>例

  [「CWnd::OnCtlColor」](../../mfc/reference/cwnd-class.md#onctlcolor)の例を参照してください。

## <a name="cdcsettextjustification"></a><a name="settextjustification"></a>CDC::テキストの正当化

文字列内の改行文字にスペースを追加します。

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>パラメーター

*エクストラ*<br/>
テキスト行に追加する余分なスペースの合計を指定します (論理単位)。 現在のマッピング モードが`MM_TEXT`でなかった場合、このパラメーターで指定された値は現在のマッピング モードに変換され、最も近いデバイス単位に丸められます。

*カウントを区切る*<br/>
行内の改行文字の数を指定します。

### <a name="return-value"></a>戻り値

関数が正常に実行された場合は 1 つ。それ以外の場合は 0。

### <a name="remarks"></a>解説

アプリケーションは、メンバー関数`GetTextMetrics`を使用して、フォントの区切り文字を取得できます。

メンバー関数`SetTextJustification`が呼び出された後、テキスト出力関数 ( など`TextOut`) を呼び出すと、指定した余分な空白が、指定した区切り文字の間で均等に配分されます。 通常、改行文字はスペース文字 (ASCII 32) ですが、フォントによって他の文字として定義される場合があります。

通常、メンバー`GetTextExtent`関数は`SetTextJustification`で使用されます。 `GetTextExtent`は、配置前に指定された行の幅を計算します。 アプリケーションは、配置後の文字列の幅から返される`GetTextExtent`値を減算することで *、nBreakExtra*パラメーターに指定する領域を決定できます。

この`SetTextJustification`関数を使用すると、異なるフォントで複数の実行を含む行を揃えることができます。 この場合、ラインは各実行を個別に整列して書き込んで、断片的に作成する必要があります。

丸めエラーは配置中に発生する可能性があるため、システムは現在のエラーを定義する実行中のエラー用語を保持します。 複数の実行を含む行を揃える`GetTextExtent`場合、次の実行の範囲を計算するときに、このエラー項が自動的に使用されます。 これにより、テキスト出力関数は、エラーを新しい実行にブレンドできます。

各行が整列された後、このエラー項が次の行に組み込まれないように、このエラー項をクリアする必要があります。 この用語は`SetTextJustification`*、nBreakExtra*を 0 に設定して呼び出すことによってクリアできます。

## <a name="cdcsetviewportext"></a><a name="setviewportext"></a>CDC::ビューポートを設定します。

デバイス コンテキストのビューポートの x 範囲と y 範囲を設定します。

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>パラメーター

*Cx*<br/>
ビューポートの x 範囲を指定します (デバイス単位)。

*Cy*<br/>
ビューポートの Y 範囲を指定します (デバイス単位)。

*サイズ*<br/>
ビューポートの x 範囲と y 範囲を指定します (デバイス単位)。

### <a name="return-value"></a>戻り値

[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクトとしてのビューポートの以前の範囲。 エラーが発生した場合、返される`CSize`オブジェクトの x 座標と y 座標は、どちらも 0 に設定されます。

### <a name="remarks"></a>解説

ビューポートは、デバイス コンテキスト ウィンドウと共に、GDI が論理座標系のポイントを実際のデバイスの座標系内のポイントにマップする方法を定義します。 つまり、GDI が論理座標をデバイス座標に変換する方法を定義します。

次のマッピング モードが設定されている場合、`SetWindowExt`呼`SetViewportExt`び出しは無視されます。

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|Mm_text|
|MM_LOENGLISH|MM_TWIPS|

MM_ISOTROPIC モードが設定されている場合、アプリケーションは、`SetWindowExt`を呼び出`SetViewportExt`す前にメンバー関数を呼び出す必要があります。

### <a name="example"></a>例

  [例については、CView::OnPrepareDC を参照](../../mfc/reference/cview-class.md#onpreparedc)してください。

## <a name="cdcsetviewportorg"></a><a name="setviewportorg"></a>CDC::セットビューポートオルガ

デバイス コンテキストのビューポートの原点を設定します。

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
ビューポートの原点の x 座標 (デバイス単位) を指定します。 値は、デバイス座標系の範囲内になければなりません。

*Y*<br/>
ビューポートの原点の y 座標(デバイス単位)を指定します。 値は、デバイス座標系の範囲内になければなりません。

*ポイント*<br/>
ビューポートの原点を指定します。 値は、デバイス座標系の範囲内になければなりません。 このパラメーターには、`POINT`構造体またはオブジェクトを`CPoint`渡すことができます。

### <a name="return-value"></a>戻り値

ビューポートの直前の原点 (デバイス座標) をオブジェクト`CPoint`として指定します。

### <a name="remarks"></a>解説

ビューポートは、デバイス コンテキスト ウィンドウと共に、GDI が論理座標系のポイントを実際のデバイスの座標系内のポイントにマップする方法を定義します。 つまり、GDI が論理座標をデバイス座標に変換する方法を定義します。

ビューポートの原点は、GDI がウィンドウの原点をマップするデバイス座標系の点を`SetWindowOrg`マークします。 GDI は、ウィンドウの原点をビューポートの原点にマップするために必要な同じプロセスに従って、他のすべてのポイントをマップします。 たとえば、窓の原点を中心とした円の中のポイントはすべて、ビューポートの原点の点を囲む円になります。 同様に、ウィンドウ原点を通過するライン内のすべての点は、ビューポートの原点を通過する線になります。

### <a name="example"></a>例

  [例については、CView::OnPrepareDC を参照](../../mfc/reference/cview-class.md#onpreparedc)してください。

## <a name="cdcsetwindowext"></a><a name="setwindowext"></a>CDC::セットウィンドウエクスク

デバイス コンテキストに関連付けられているウィンドウの x および y の範囲を設定します。

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>パラメーター

*Cx*<br/>
ウィンドウの x 範囲を論理単位で指定します。

*Cy*<br/>
ウィンドウの y 範囲を論理単位で指定します。

*サイズ*<br/>
ウィンドウの x および y のエクステントを論理単位で指定します。

### <a name="return-value"></a>戻り値

ウィンドウの以前の範囲 (論理単位) をオブジェクトとして`CSize`指定します。 エラーが発生した場合、返される`CSize`オブジェクトの x 座標と y 座標は、両方とも 0 に設定されます。

### <a name="remarks"></a>解説

このウィンドウは、デバイス コンテキスト ビューポートと共に、GDI が論理座標系のポイントをデバイス座標系内のポイントにマップする方法を定義します。

次のマッピング モードが設定されている場合、`SetWindowExt`呼`SetViewportExt`び出しと関数は無視されます。

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- Mm_text

- MM_TWIPS

MM_ISOTROPIC モードが設定されている場合、アプリケーションは、`SetWindowExt`を呼び`SetViewportExt`出す前にメンバー関数を呼び出す必要があります。

### <a name="example"></a>例

  [例については、CView::OnPrepareDC を参照](../../mfc/reference/cview-class.md#onpreparedc)してください。

## <a name="cdcsetwindoworg"></a><a name="setwindoworg"></a>CDC::セットウィンドウオルグ

デバイス コンテキストのウィンドウの原点を設定します。

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
ウィンドウの新しい原点の論理 x 座標を指定します。

*Y*<br/>
ウィンドウの新しい原点の論理 y 座標を指定します。

*ポイント*<br/>
ウィンドウの新しい原点の論理座標を指定します。 このパラメーターには、`POINT`構造体またはオブジェクトを`CPoint`渡すことができます。

### <a name="return-value"></a>戻り値

ウィンドウのオブジェクトとしての前の`CPoint`原点。

### <a name="remarks"></a>解説

このウィンドウは、デバイス コンテキスト ビューポートと共に、GDI が論理座標系のポイントをデバイス座標系内のポイントにマップする方法を定義します。

ウィンドウの原点は、GDI がビューポートの原点をマップする論理座標系の点を`SetWindowOrg`マークします。 GDI は、ウィンドウの原点をビューポートの原点にマップするために必要な同じプロセスに従って、他のすべてのポイントをマップします。 たとえば、窓の原点を中心とした円の中のポイントはすべて、ビューポートの原点の点を囲む円になります。 同様に、ウィンドウ原点を通過するライン内のすべての点は、ビューポートの原点を通過する線になります。

## <a name="cdcsetworldtransform"></a><a name="setworldtransform"></a>CDC::セットワールドトランスフォーム

指定したデバイス コンテキストのワールド空間とページ空間の間の 2 次元の線形変換を設定します。 この変換は、グラフィックス出力の拡大/縮小、回転、傾斜、または変換に使用できます。

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>パラメーター

*rXフォーム*<br/>
変換データを含む[XFORM](/windows/win32/api/wingdi/ns-wingdi-xform)構造体への参照。

### <a name="return-value"></a>戻り値

成功した場合に 0 以外の値を返します。

失敗した場合は 0 を返します。

拡張エラー情報を取得するには[、GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)を呼び出します。

### <a name="remarks"></a>解説

このメソッドは、Windows GDI 関数[をラップします](/windows/win32/api/wingdi/nf-wingdi-setworldtransform)。

## <a name="cdcstartdoc"></a><a name="startdoc"></a>CDC::スタートドック

新しい印刷ジョブが開始され、呼び出しが発生するまで、`StartPage`同`EndPage`じジョブの下で、すべての後続の呼び出`EndDoc`しをスプールする必要があることをデバイス ドライバーに通知します。

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>パラメーター

*をクリックします。*<br/>
ドキュメント ファイルの名前と出力ファイルの名前を含む[DOCINFO](/windows/win32/api/wingdi/ns-wingdi-docinfow)構造体へのポイント。

*名前*<br/>
ドキュメント ファイルの名前を含む文字列へのポインター。

### <a name="return-value"></a>戻り値

関数が成功した場合、戻り値は 0 より大きくなります。 この値は、ドキュメントの印刷ジョブ識別子です。

関数が失敗した場合、戻り値は 0 以下になります。

### <a name="remarks"></a>解説

これにより、1 ページより長いドキュメントが他のジョブに散在しないようにします。

Windows バージョン 3.1 以降では、この関数は STARTDOC プリンターエスケープを置き換えます。 この機能を使用すると、複数のページを含むドキュメントが他の印刷ジョブに散在しないようにします。

`StartDoc`メタファイル内で使用しないでください。

### <a name="example"></a>例

このコードは、既定のプリンターを取得し、印刷ジョブを開き、1 ページをスプール "Hello, World! その上に。 このコードで印刷されるテキストはプリンターの論理単位に合わせて拡張されないため、出力テキストは小さな文字で表示されるため、結果が読み取れない場合があります。 などの CDC スケーリング関数`SetMapMode``SetViewportOrg`、 、および`SetWindowExt`などのスケーリング関数を使用して、スケーリングを修正できます。

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

## <a name="cdcstartpage"></a><a name="startpage"></a>CDC::スタートページ

データを受信するプリンター ドライバーを準備します。

```
int StartPage();
```

### <a name="return-value"></a>戻り値

関数が成功した場合は 0 以上、エラーが発生した場合は負の値。

### <a name="remarks"></a>解説

`StartPage`は、NEWFRAME と BANDINFO エスケープに優先します。

印刷呼び出しの順序の概要については[、StartDoc](#startdoc)メンバー関数を参照してください。

システムは、 と`ResetDC``EndPage`の呼び出`StartPage`しの間のメンバー関数を無効にします。

### <a name="example"></a>例

  [CDC::StartDoc](#startdoc)の例を参照してください。

## <a name="cdcstretchblt"></a><a name="stretchblt"></a>CDC::ストレッチブレット

コピー元の四角形から、必要に応じてコピー先の四角形に合うようにビットマップを拡大または縮小してコピーします。

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
コピー先の四角形の左上隅を示す X 座標を (論理単位で) 指定します。

*Y*<br/>
コピー先の四角形の左上隅を示す Y 座標を (論理単位で) 指定します。

*n幅*<br/>
コピー先の四角形の幅を (論理単位で) 指定します。

*nHeight*<br/>
コピー先の四角形の高さを (論理単位で) 指定します。

*pSrcDC*<br/>
コピー元のデバイス コンテキストを指定します。

*xSrc*<br/>
コピー元の四角形の左上隅を示す X 座標を (論理単位で) 指定します。

*ySrc*<br/>
コピー元の四角形の左上隅を示す Y 座標を (論理単位で) 指定します。

*幅*<br/>
コピー元の四角形の幅を (論理単位で) 指定します。

*NSrcHeight*<br/>
コピー元の四角形の高さを (論理単位で) 指定します。

*dwRop*<br/>
実行するラスター オペレーションを指定します。 ラスター オペレーション コードにより、現在のブラシ、有効なコピー元のビットマップ、およびコピー先のビットマップが関連する出力操作における、GDI による色の組み合わせが定義されます。 このパラメーターには、次のいずれかの値を指定できます。

- [ブラックネス] すべての出力を黒に変えます。

- DSTINVERT は、変換先ビットマップを反転します。

- MERGECOPY ブール演算子 AND を使用して、パターンとソース ビットマップを結合します。

- MERGEPAINT ブール演算子を使用して、反転されたソース ビットマップとターゲット ビットマップを組み合わせます。

- NOTSRCCOPY 反転ソースビットマップをコピー先にコピーします。

- NOTSRCERASE ブール演算子を使用して、変換先ビットマップとソース ビットマップを結合した結果を反転します。

- PATCOPY パターンをコピー先ビットマップにコピーします。

- PATINVERT ブール XOR 演算子を使用して、ターゲット ビットマップをパターンと組み合わせます。

- PATPAINT ブール値 OR 演算子を使用して、反転されたソース ビットマップとパターンを組み合わせます。 さらに、ブール型 OR 演算子を使用して、この演算の結果とコピー先ビットマップを組み合わせます。

- SRCAND ブール演算子 AND を使用して、変換先ビットマップと変換元ビットマップのピクセルを結合します。

- SRCCOPY ソース ビットマップをコピー先ビットマップにコピーします。

- SRCERASE は、出力先のビットマップを反転し、ブール演算子 AND 演算子を使用して、結果をソース ビットマップと結合します。

- SRCINVERT ブール XOR 演算子を使用して、変換先ビットマップと変換元ビットマップのピクセルを結合します。

- SRCPAINT ブール演算子を使用して、変換先ビットマップと変換元ビットマップのピクセルを結合します。

- 白さ すべての出力を白くします。

### <a name="return-value"></a>戻り値

ビットマップが描画された場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

この関数は、コピー先デバイス コンテキストの伸縮モード (`SetStretchBltMode` で設定) を使用して、ビットマップを拡大または縮小する方法を決定します。

この`StretchBlt`関数は *、pSrcDC*によって指定されたソース デバイスから、メンバー関数が呼び出されるデバイス コンテキスト オブジェクトによって表されるターゲット デバイスにビットマップを移動します。 *xSrc* *、ySrc、nSrcWidth*、*および nSrcHeight*パラメーターは、ソース四角形の左上隅と寸法を定義します。 *nSrcWidth* *x、y、nWidth*、*および nHeight*パラメータは、左上隅と移動先の四角形の寸法を指定します。 *x* *nWidth* *dwRop*で指定されたラスター操作は、ソース ビットマップと、既にターゲット デバイス上にあるビットを結合する方法を定義します。

nSrcWidth と nWidth パラメーターまたは`StretchBlt`*nSrcHeight パラメーターと nSrcHeight*パラメーターと*nWidth**nSrcHeight*パラメーターの符号が異なる場合、この関数はビットマップのミラー イメージを作成します。 *nHeight* *nSrcWidth*と*nWidth*の符号が異なる場合、関数は x 軸に沿ってビットマップのミラー イメージを作成します。 *nSrcHeight*と*nHeight*の符号が異なる場合、関数は y 軸に沿ってビットマップのミラー イメージを作成します。

`StretchBlt` 関数は、メモリ内のコピー元ビットマップを拡大または縮小し、その結果をコピー先にコピーします。 パターンを結果とマージする場合、そのパターンは、拡大されたコピー元ビットマップがコピー先にコピーされるまでマージされません。 ブラシを使用する場合、そのブラシは、コピー先デバイス コンテキストで選択されたブラシです。 コピー先の座標は、コピー先デバイス コンテキストに従って変換されます。コピー元の座標は、コピー元デバイス コンテキストに従って変換されます。

コピー先ビットマップ、コピー元ビットマップ、およびパターン ビットマップの色の形式が異なる場合は、`StretchBlt` によって、コピー元ビットマップとパターン ビットマップが、コピー先ビットマップに合わせて変換されます。 変換では、コピー先デバイス コンテキストの前景色と背景色が使用されます。

モノクロ ビットマップをカラーに変換する必要がある場合、`StretchBlt` は白のビット (1) を背景色に、黒のビット (0) を前景色に設定します。 カラーをモノクロに変換するには、背景色に一致するピクセルを白 (1) に設定し、その他のすべてのピクセルを黒 (0) に設定します。 カラーのデバイス コンテキストの前景色と背景色は使用されます。

一部のデバイスでは、`StretchBlt` 関数がサポートされていません。 デバイスが をサポート`StretchBlt`しているかどうかを確認するには、RASTERCAPS インデックスを使用して`GetDeviceCaps`メンバー関数を呼び出し、RC_STRETCHBLT フラグの戻り値を確認します。

## <a name="cdcstrokeandfillpath"></a><a name="strokeandfillpath"></a>CDC::ストロークアンドフィルパス

パス内の開いている図形を閉じ、現在のペンを使用してパスのアウトラインをストロークし、現在のブラシを使用して内部を塗りつぶします。

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

デバイス コンテキストには、閉じたパスが含まれている必要があります。 メンバー`StrokeAndFillPath`関数は、パス内の開いている図形をすべて閉じたり、パスを個別にストロークして塗りつぶすのと同じ効果を持ちますが、塗りつぶされた領域はペンが幅の広い領域であってもストローク領域に重なりません。

## <a name="cdcstrokepath"></a><a name="strokepath"></a>CDC::ストロークパス

現在のペンを使用して、指定したパスをレンダリングします。

```
BOOL StrokePath();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

デバイス コンテキストには、閉じたパスが含まれている必要があります。

## <a name="cdctabbedtextout"></a><a name="tabbedtextout"></a>CDC::タブベッドテキストアウト

指定した位置に文字列を書き込み、タブをタブ ストップ位置の配列で指定された値に展開します。

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
文字列の開始点の論理 x 座標を指定します。

*Y*<br/>
文字列の開始点の論理 y 座標を指定します。

*文字列*<br/>
描画する文字列を指します。 このパラメーターには、文字の配列へのポインターまたは[CString](../../atl-mfc-shared/reference/cstringt-class.md)オブジェクトのいずれかを渡すことができます。

*nカウント*<br/>
*lpszString*[が指す文字列の長さを](/windows/win32/gdi/specifying-length-of-text-output-string)指定します。

*nタブポジション*<br/>
タブストップ位置の配列内の値の数を指定します。

*位置を指定します。*<br/>
タブストップ位置を含む配列へのポイント (論理単位)。 タブ位置は昇順に並べ替える必要があります。最小の x 値は、配列の最初の項目である必要があります。

*nタブオリジン*<br/>
タブを展開する開始位置の x 座標を指定します (論理単位)。

*Str*<br/>
指定`CString`した文字を含むオブジェクト。

### <a name="return-value"></a>戻り値

`CSize`オブジェクトとしての文字列の寸法 (論理単位)。

### <a name="remarks"></a>解説

テキストは現在選択されているフォントで書き込まれます。 *nTabPositions が*0 で *、lpnTab ストップポジション*が NULL の場合、タブは平均文字幅の 8 倍に拡張されます。

*nTabPositions が*1 の場合、タブストップは *、lpnTabStopPositions*配列の最初の値で指定された距離で区切られます。 *lpnTabStopPositions*配列に複数の値が含まれている場合、配列内の各値に対して*タブ*ストップが設定されます。 *nTabOrigin*パラメータを使用すると、アプリケーションは`TabbedTextOut`1 行に対して関数を複数回呼び出すことができます。 nTabOrigin を毎回同じ値に設定して、アプリケーションが関数を複数回呼び出す場合 *、nTabOrigin*で指定された位置に関連*nTabOrigin*するすべてのタブが展開されます。

既定では、関数は現在位置を使用することも、更新することもありません。 アプリケーションが関数を呼び出すときに現在の位置を更新する必要がある場合、アプリケーションは、TA_UPDATECPに設定された*nFlags*を使用して[SetTextAlign](#settextalign)メンバー関数を呼び出すことができます。 このフラグが設定されている場合、Windows は、代*y*わりに現在の位置を使用`TabbedTextOut`して、 に対する後続の呼び出しで*x*および y パラメーターを無視します。

## <a name="cdctextout"></a><a name="textout"></a>CDC::テキストアウト

現在選択されているフォントを使用して、文字列を指定位置から書き込みます。

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>パラメーター

*X*<br/>
テキストの始点の論理的な X 座標を指定します。

*Y*<br/>
テキストの始点の論理的な Y 座標を指定します。

*文字列*<br/>
描画される文字列を指します。

*nカウント*<br/>
文字列の文字数を指定します。

*Str*<br/>
描画される文字が含まれる `CString` オブジェクト。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

文字の起点は文字セルの左上隅です。 既定では、関数は現在位置を使用することも、更新することもありません。

アプリケーションが呼び出`TextOut`すときに現在の位置を更新する必要がある場合、アプリケーション`SetTextAlign`は、TA_UPDATECPに設定された*nFlags*を使用してメンバー関数を呼び出すことができます。 このフラグが設定されている場合、Windows は、代*y*わりに現在の位置を使用`TextOut`して、 に対する後続の呼び出しで*x*および y パラメーターを無視します。

### <a name="example"></a>例

  [CDC::BeginPath](#beginpath)の例を参照してください。

## <a name="cdctransparentblt"></a><a name="transparentblt"></a>CDC::トランスペアレントブレット

指定したソース デバイス コンテキストのピクセルの四角形に対応する色データのビット ブロックを転送するには、このメンバー関数を呼び出します。

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>パラメーター

*xDest*<br/>
移動先の四角形の左上隅の x 座標を論理単位で指定します。

*イデスト*<br/>
移動先の四角形の左上隅の y 座標を論理単位で指定します。

*幅*<br/>
コピー先の四角形の幅を論理単位で指定します。

*最も高い*<br/>
コピー先の四角形の高さを論理単位で指定します。

*pSrcDC*<br/>
ソース デバイス コンテキストへのポインター。

*xSrc*<br/>
ソース四角形の x 座標を論理単位で指定します。

*ySrc*<br/>
ソース四角形の y 座標を論理単位で指定します。

*幅*<br/>
ソース四角形の幅を論理単位で指定します。

*NSrcHeight*<br/>
ソース四角形の高さを論理単位で指定します。

*clr透明*<br/>
透明として扱うソース ビットマップの RGB カラー。

### <a name="return-value"></a>戻り値

成功した場合は TRUE、それ以外の場合は FALSE。

### <a name="remarks"></a>解説

`TransparentBlt`透明度を可能にします。つまり *、clrTransparent*で示される RGB カラーは、転送のために透明にレンダリングされます。

詳細については、Windows SDK の[「トランスペアレントブルト](/windows/win32/api/wingdi/nf-wingdi-transparentblt)」を参照してください。

## <a name="cdcupdatecolors"></a><a name="updatecolors"></a>CDC::更新色

クライアント領域の現在の色をピクセル単位でシステム パレットに合わせて、デバイス コンテキストのクライアント領域を更新します。

```
void UpdateColors();
```

### <a name="remarks"></a>解説

論理パレットが実現された非アクティブウィンドウは、システム`UpdateColors`パレットが変更されたときにクライアント領域を再描画する代わりに呼び出す場合があります。

カラー パレットの使用の詳細については、「Windows SDK[の更新色](/windows/win32/api/wingdi/nf-wingdi-updatecolors)」を参照してください。

通常`UpdateColors`、メンバー関数は、領域を再描画するよりも高速にクライアント領域を更新します。 ただし、システム パレットが変更される前の各ピクセルの色に基づいて色の変換が実行されるため、この関数を呼び出すたびに、色の精度が失われます。

## <a name="cdcwidenpath"></a><a name="widenpath"></a>CDC::ワイドパス

現在のパスをデバイス コンテキストで現在選択されているペンを使用してストロークされた場合に描画される領域として、現在のパスを再定義します。

```
BOOL WidenPath();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>解説

この関数は、現在のペンが 2 番目のバージョンのメンバー関数によって作成`CreatePen`された幾何学的なペンであるか、最初のバージョンの`CreatePen`の ペンが作成され、幅が 1 より大きいデバイス単位である場合にのみ成功します。 デバイス コンテキストには、閉じたパスが含まれている必要があります。 パス内の任意の Bzier 曲線は、広がった曲線に近い直線のシーケンスに変換されます。 したがって、Bzier 曲線は呼び出された後`WidenPath`のパスに残っていません。

## <a name="see-also"></a>関連項目

[Cオブジェクトクラス](../../mfc/reference/cobject-class.md)<br/>
[階層グラフ](../../mfc/hierarchy-chart.md)<br/>
[CペイントDCクラス](../../mfc/reference/cpaintdc-class.md)<br/>
[CWindowDC クラス](../../mfc/reference/cwindowdc-class.md)<br/>
[CClientDC クラス](../../mfc/reference/cclientdc-class.md)<br/>
[クラス](../../mfc/reference/cmetafiledc-class.md)
