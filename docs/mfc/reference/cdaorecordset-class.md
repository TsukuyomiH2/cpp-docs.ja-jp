---
title: クラス
ms.date: 08/27/2018
f1_keywords:
- CDaoRecordset
- AFXDAO/CDaoRecordset
- AFXDAO/CDaoRecordset::CDaoRecordset
- AFXDAO/CDaoRecordset::AddNew
- AFXDAO/CDaoRecordset::CanAppend
- AFXDAO/CDaoRecordset::CanBookmark
- AFXDAO/CDaoRecordset::CancelUpdate
- AFXDAO/CDaoRecordset::CanRestart
- AFXDAO/CDaoRecordset::CanScroll
- AFXDAO/CDaoRecordset::CanTransact
- AFXDAO/CDaoRecordset::CanUpdate
- AFXDAO/CDaoRecordset::Close
- AFXDAO/CDaoRecordset::Delete
- AFXDAO/CDaoRecordset::DoFieldExchange
- AFXDAO/CDaoRecordset::Edit
- AFXDAO/CDaoRecordset::FillCache
- AFXDAO/CDaoRecordset::Find
- AFXDAO/CDaoRecordset::FindFirst
- AFXDAO/CDaoRecordset::FindLast
- AFXDAO/CDaoRecordset::FindNext
- AFXDAO/CDaoRecordset::FindPrev
- AFXDAO/CDaoRecordset::GetAbsolutePosition
- AFXDAO/CDaoRecordset::GetBookmark
- AFXDAO/CDaoRecordset::GetCacheSize
- AFXDAO/CDaoRecordset::GetCacheStart
- AFXDAO/CDaoRecordset::GetCurrentIndex
- AFXDAO/CDaoRecordset::GetDateCreated
- AFXDAO/CDaoRecordset::GetDateLastUpdated
- AFXDAO/CDaoRecordset::GetDefaultDBName
- AFXDAO/CDaoRecordset::GetDefaultSQL
- AFXDAO/CDaoRecordset::GetEditMode
- AFXDAO/CDaoRecordset::GetFieldCount
- AFXDAO/CDaoRecordset::GetFieldInfo
- AFXDAO/CDaoRecordset::GetFieldValue
- AFXDAO/CDaoRecordset::GetIndexCount
- AFXDAO/CDaoRecordset::GetIndexInfo
- AFXDAO/CDaoRecordset::GetLastModifiedBookmark
- AFXDAO/CDaoRecordset::GetLockingMode
- AFXDAO/CDaoRecordset::GetName
- AFXDAO/CDaoRecordset::GetParamValue
- AFXDAO/CDaoRecordset::GetPercentPosition
- AFXDAO/CDaoRecordset::GetRecordCount
- AFXDAO/CDaoRecordset::GetSQL
- AFXDAO/CDaoRecordset::GetType
- AFXDAO/CDaoRecordset::GetValidationRule
- AFXDAO/CDaoRecordset::GetValidationText
- AFXDAO/CDaoRecordset::IsBOF
- AFXDAO/CDaoRecordset::IsDeleted
- AFXDAO/CDaoRecordset::IsEOF
- AFXDAO/CDaoRecordset::IsFieldDirty
- AFXDAO/CDaoRecordset::IsFieldNull
- AFXDAO/CDaoRecordset::IsFieldNullable
- AFXDAO/CDaoRecordset::IsOpen
- AFXDAO/CDaoRecordset::Move
- AFXDAO/CDaoRecordset::MoveFirst
- AFXDAO/CDaoRecordset::MoveLast
- AFXDAO/CDaoRecordset::MoveNext
- AFXDAO/CDaoRecordset::MovePrev
- AFXDAO/CDaoRecordset::Open
- AFXDAO/CDaoRecordset::Requery
- AFXDAO/CDaoRecordset::Seek
- AFXDAO/CDaoRecordset::SetAbsolutePosition
- AFXDAO/CDaoRecordset::SetBookmark
- AFXDAO/CDaoRecordset::SetCacheSize
- AFXDAO/CDaoRecordset::SetCacheStart
- AFXDAO/CDaoRecordset::SetCurrentIndex
- AFXDAO/CDaoRecordset::SetFieldDirty
- AFXDAO/CDaoRecordset::SetFieldNull
- AFXDAO/CDaoRecordset::SetFieldValue
- AFXDAO/CDaoRecordset::SetFieldValueNull
- AFXDAO/CDaoRecordset::SetLockingMode
- AFXDAO/CDaoRecordset::SetParamValue
- AFXDAO/CDaoRecordset::SetParamValueNull
- AFXDAO/CDaoRecordset::SetPercentPosition
- AFXDAO/CDaoRecordset::Update
- AFXDAO/CDaoRecordset::m_bCheckCacheForDirtyFields
- AFXDAO/CDaoRecordset::m_nFields
- AFXDAO/CDaoRecordset::m_nParams
- AFXDAO/CDaoRecordset::m_pDAORecordset
- AFXDAO/CDaoRecordset::m_pDatabase
- AFXDAO/CDaoRecordset::m_strFilter
- AFXDAO/CDaoRecordset::m_strSort
helpviewer_keywords:
- CDaoRecordset [MFC], CDaoRecordset
- CDaoRecordset [MFC], AddNew
- CDaoRecordset [MFC], CanAppend
- CDaoRecordset [MFC], CanBookmark
- CDaoRecordset [MFC], CancelUpdate
- CDaoRecordset [MFC], CanRestart
- CDaoRecordset [MFC], CanScroll
- CDaoRecordset [MFC], CanTransact
- CDaoRecordset [MFC], CanUpdate
- CDaoRecordset [MFC], Close
- CDaoRecordset [MFC], Delete
- CDaoRecordset [MFC], DoFieldExchange
- CDaoRecordset [MFC], Edit
- CDaoRecordset [MFC], FillCache
- CDaoRecordset [MFC], Find
- CDaoRecordset [MFC], FindFirst
- CDaoRecordset [MFC], FindLast
- CDaoRecordset [MFC], FindNext
- CDaoRecordset [MFC], FindPrev
- CDaoRecordset [MFC], GetAbsolutePosition
- CDaoRecordset [MFC], GetBookmark
- CDaoRecordset [MFC], GetCacheSize
- CDaoRecordset [MFC], GetCacheStart
- CDaoRecordset [MFC], GetCurrentIndex
- CDaoRecordset [MFC], GetDateCreated
- CDaoRecordset [MFC], GetDateLastUpdated
- CDaoRecordset [MFC], GetDefaultDBName
- CDaoRecordset [MFC], GetDefaultSQL
- CDaoRecordset [MFC], GetEditMode
- CDaoRecordset [MFC], GetFieldCount
- CDaoRecordset [MFC], GetFieldInfo
- CDaoRecordset [MFC], GetFieldValue
- CDaoRecordset [MFC], GetIndexCount
- CDaoRecordset [MFC], GetIndexInfo
- CDaoRecordset [MFC], GetLastModifiedBookmark
- CDaoRecordset [MFC], GetLockingMode
- CDaoRecordset [MFC], GetName
- CDaoRecordset [MFC], GetParamValue
- CDaoRecordset [MFC], GetPercentPosition
- CDaoRecordset [MFC], GetRecordCount
- CDaoRecordset [MFC], GetSQL
- CDaoRecordset [MFC], GetType
- CDaoRecordset [MFC], GetValidationRule
- CDaoRecordset [MFC], GetValidationText
- CDaoRecordset [MFC], IsBOF
- CDaoRecordset [MFC], IsDeleted
- CDaoRecordset [MFC], IsEOF
- CDaoRecordset [MFC], IsFieldDirty
- CDaoRecordset [MFC], IsFieldNull
- CDaoRecordset [MFC], IsFieldNullable
- CDaoRecordset [MFC], IsOpen
- CDaoRecordset [MFC], Move
- CDaoRecordset [MFC], MoveFirst
- CDaoRecordset [MFC], MoveLast
- CDaoRecordset [MFC], MoveNext
- CDaoRecordset [MFC], MovePrev
- CDaoRecordset [MFC], Open
- CDaoRecordset [MFC], Requery
- CDaoRecordset [MFC], Seek
- CDaoRecordset [MFC], SetAbsolutePosition
- CDaoRecordset [MFC], SetBookmark
- CDaoRecordset [MFC], SetCacheSize
- CDaoRecordset [MFC], SetCacheStart
- CDaoRecordset [MFC], SetCurrentIndex
- CDaoRecordset [MFC], SetFieldDirty
- CDaoRecordset [MFC], SetFieldNull
- CDaoRecordset [MFC], SetFieldValue
- CDaoRecordset [MFC], SetFieldValueNull
- CDaoRecordset [MFC], SetLockingMode
- CDaoRecordset [MFC], SetParamValue
- CDaoRecordset [MFC], SetParamValueNull
- CDaoRecordset [MFC], SetPercentPosition
- CDaoRecordset [MFC], Update
- CDaoRecordset [MFC], m_bCheckCacheForDirtyFields
- CDaoRecordset [MFC], m_nFields
- CDaoRecordset [MFC], m_nParams
- CDaoRecordset [MFC], m_pDAORecordset
- CDaoRecordset [MFC], m_pDatabase
- CDaoRecordset [MFC], m_strFilter
- CDaoRecordset [MFC], m_strSort
ms.assetid: 2322067f-1027-4662-a5d7-aa2fc7488630
ms.openlocfilehash: 5b4b2919405696c748ce01217ac82afeac316de2
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81377153"
---
# <a name="cdaorecordset-class"></a>クラス

データ ソースから選択された 1 組のレコードセットを表現します。

## <a name="syntax"></a>構文

```
class CDaoRecordset : public CObject
```

## <a name="members"></a>メンバー

### <a name="public-constructors"></a>パブリック コンストラクター

|名前|説明|
|----------|-----------------|
|[コダレコードセット::CDaoレコード](#cdaorecordset)|`CDaoRecordset` オブジェクトを構築します。|

### <a name="public-methods"></a>パブリック メソッド

|名前|説明|
|----------|-----------------|
|[コダレコード::新しい追加](#addnew)|新しいレコードを追加する準備をします。 [更新](#update)を呼び出して、追加を完了します。|
|[コダオレコードセット::缶詰](#canappend)|[AddNew](#addnew)メンバー関数を使用してレコードセットに新しいレコードを追加できる場合は、0 以外を返します。|
|[レコードセット::缶ブックマーク](#canbookmark)|レコードセットがブックマークをサポートする場合は、0 以外を返します。|
|[レコードセット::キャンセル更新](#cancelupdate)|[編集](#edit)または[AddNew](#addnew)操作により、保留中の更新をキャンセルします。|
|[コダレコード::缶リスタート](#canrestart)|レコードセットのクエリを再実行するために[Requery](#requery)を呼び出すことができる場合は、0 以外を返します。|
|[コダレコード::缶スクロール](#canscroll)|レコードをスクロールできる場合は、0 以外を返します。|
|[コダレコード::缶トランスアクト](#cantransact)|データ ソースがトランザクションをサポートする場合は、0 以外を返します。|
|[コダレコード::缶更新](#canupdate)|レコードセットを更新できる場合 (レコードを追加、更新、または削除できる場合)、0 以外を返します。|
|[コダレコード::閉じる](#close)|レコードセットを閉じます。|
|[コダオレコード::Dエレテ](#delete)|レコードセットから現在のレコードを削除します。 削除後に別のレコードに明示的にスクロールする必要があります。|
|[コダオレコードセット::Dフィールドエクスチェンジ](#dofieldexchange)|レコードセットのフィールド データ メンバーとデータ ソースの対応するレコードの間でデータを (双方向で) 交換するために呼び出されます。 DAO レコード フィールド エクスチェンジ (DFX) を実装します。|
|[コダオレコード::編集](#edit)|現在のレコードに対する変更の準備をします。 編集`Update`を完了するために呼び出します。|
|[レコードセット::フィルキャッシュ](#fillcache)|ODBC データ ソースのデータを含むレコードセット オブジェクトのローカル キャッシュのすべてまたは一部を埋めます。|
|[コダオレコード::検索](#find)|指定した条件を満たし、そのレコードを現在のレコードにするダイナセット タイプのレコードセット内の特定の文字列の最初、次、前、または最後の位置を検索します。|
|[コダレコード::最初に検索](#findfirst)|指定した条件を満たし、そのレコードを現在のレコードにするダイナセット タイプまたはスナップショット タイプのレコードセット内の最初のレコードを検索します。|
|[コダレコード::FindLast](#findlast)|指定した条件を満たし、そのレコードを現在のレコードにするダイナセット タイプまたはスナップショット タイプのレコードセット内の最後のレコードを検索します。|
|[次を見つける](#findnext)|指定した条件を満たし、そのレコードを現在のレコードにするダイナセット タイプまたはスナップショット タイプのレコードセット内の次のレコードを検索します。|
|[コダオレコードセット::FindPrev](#findprev)|指定した条件を満たし、そのレコードを現在のレコードにするダイナセット タイプまたはスナップショット タイプのレコードセット内の前のレコードを検索します。|
|[コダレコードセット::絶対位置を取得します。](#getabsoluteposition)|レコードセット オブジェクトの現在のレコードのレコード番号を返します。|
|[レコードセット::取得ブックマーク](#getbookmark)|レコードのブックマークを表す値を返します。|
|[レコードセット::ゲットキャッシュサイズ](#getcachesize)|ODBC データ ソースからローカルにキャッシュされるデータを含むダイナセット タイプのレコードセット内のレコード数を指定する値を返します。|
|[レコードセット::ゲットキャッシュスタート](#getcachestart)|キャッシュされるレコードセットの最初のレコードのブックマークを指定する値を返します。|
|[レコードセット::ゲットカレントインデックス](#getcurrentindex)|インデックス付`CString`きのテーブル型で最後に使用されたインデックスの名前を含むを返`CDaoRecordset`します。|
|[コダオレコードセット::ゲットデイト作成](#getdatecreated)|オブジェクトの基になるベース テーブルが作成された`CDaoRecordset`日時を返します。|
|[コダレコード::ゲットデイトラスト更新](#getdatelastupdated)|オブジェクトの基になる基本テーブルのデザインに対して行われた最新の変更の日時を`CDaoRecordset`返します。|
|[レコードセット::デフォルトDB名](#getdefaultdbname)|既定のデータ ソースの名前を返します。|
|[コダオレコードセット::デフォルトSQL](#getdefaultsql)|実行する既定の SQL 文字列を取得するために呼び出されます。|
|[コダオレコードセット::ゲットエディットモード](#geteditmode)|現在のレコードの編集状態を示す値を返します。|
|[コダレコードセット::ゲットフィールドカウント](#getfieldcount)|レコードセット内のフィールド数を表す値を返します。|
|[コダレコード::ゲットフィールドインフォ](#getfieldinfo)|レコードセットのフィールドに関する特定の種類の情報を返します。|
|[コダレコードセット::フィールド値を取得します。](#getfieldvalue)|レコードセット内のフィールドの値を返します。|
|[レコードセット::インデックスカウントを取得します。](#getindexcount)|レコードセットの基になるテーブルのインデックス数を取得します。|
|[コダオレコードセット::インデックス情報を取得します。](#getindexinfo)|インデックスに関するさまざまな種類の情報を返します。|
|[レコードセット::ラスト修正ブックマーク](#getlastmodifiedbookmark)|最近追加または更新されたレコードを判別するために使用します。|
|[コダロック::ゲットロッキングモード](#getlockingmode)|編集中に有効なロックの種類を示す値を返します。|
|[コダオレコードセット::ゲットネーム](#getname)|レコードセット`CString`の名前を含むを返します。|
|[コダレコード::ゲットパラムバリュー](#getparamvalue)|基になる DAOParameter オブジェクトに格納されている指定したパラメーターの現在の値を取得します。|
|[コダレコードセット::取得パーセントポジション](#getpercentposition)|レコードの合計数に対するパーセンテージで、現在のレコードの位置を返します。|
|[レコード数を取得します。](#getrecordcount)|レコードセット オブジェクト内でアクセスされたレコードの数を返します。|
|[コダオレコードセット::ゲットSQL](#getsql)|レコードセットのレコードを選択するために使用する SQL 文字列を取得します。|
|[コダレコード::ゲットタイプ](#gettype)|テーブル タイプ、ダイナセット タイプ、またはスナップショット タイプのレコードセットの種類を決定するために呼び出されます。|
|[コダオレコードセット::検証ルールを取得します。](#getvalidationrule)|フィールドに`CString`入力されたデータを検証する値を含むを返します。|
|[コダオレコードセット::テキストを取得します。](#getvalidationtext)|入力規則が満たされない場合に表示されるテキストを取得します。|
|[コダオレコード::イズボフ](#isbof)|レコードセットが最初のレコードの前に配置されている場合は、0 以外を返します。 現在のレコードが存在しません。|
|[コダオレコードセット::削除](#isdeleted)|レコードセットが削除されたレコードに配置されている場合は、0 以外を返します。|
|[コダオレコード::イセフ](#iseof)|レコードセットが最後のレコードの後に配置されている場合は、0 以外を返します。 現在のレコードが存在しません。|
|[コダレコード::イズフィールドダーティ](#isfielddirty)|現在のレコードの指定されたフィールドが変更されている場合は、0 以外を返します。|
|[コダレコードセット::イズフィールドヌル](#isfieldnull)|現在のレコードの指定されたフィールドが Null (値なし) の場合は、0 以外を返します。|
|[コダオレコードセット::イズフィールドNull可能](#isfieldnullable)|現在のレコードの指定されたフィールドが Null (値なし) に設定できる場合は、0 以外を返します。|
|[コダレコード::IsOpen](#isopen)|[Open](#open)が以前に呼び出された場合は、0 以外を返します。|
|[コダオレコード::移動](#move)|レコードセットを、現在のレコードの指定した数のレコードを、いずれかの方向に移動します。|
|[コダレコード::ムーブファースト](#movefirst)|カレント レコードをレコードセットの最初のレコードに配置します。|
|[コダレコード::移動ラスト](#movelast)|カレント レコードをレコードセットの最後のレコードに配置します。|
|[コダオレコードセット::次に移動](#movenext)|カレント レコードをレコードセット内の次のレコードに配置します。|
|[コダレコード::ムーブプレフ](#moveprev)|カレント レコードをレコードセットの前のレコードに配置します。|
|[セオレコード::オープン](#open)|テーブル、ダイナセット、またはスナップショットから新しいレコードセットを作成します。|
|[コダオレコードセット::再クエリ](#requery)|レコードセットのクエリを再実行して、選択したレコードを更新します。|
|[コダオレコード::シーク](#seek)|現在のインデックスに対して指定された条件を満たし、そのレコードをカレント レコードにする、インデックス付きのテーブル タイプのレコードセット オブジェクト内のレコードを検索します。|
|[コダレコードセット::セットアブソリュートポジション](#setabsoluteposition)|レコードセット オブジェクトの現在のレコードのレコード番号を設定します。|
|[レコードセット::ブックマークを設定します。](#setbookmark)|指定したブックマークを含むレコードにレコードセットを配置します。|
|[レコードセット::セットキャッシュサイズ](#setcachesize)|ODBC データ ソースからローカルにキャッシュされるデータを含むダイナセット タイプのレコードセット内のレコード数を指定する値を設定します。|
|[レコードセット::セットキャッシュスタート](#setcachestart)|キャッシュされるレコードセットの最初のレコードのブックマークを指定する値を設定します。|
|[レコードセット::セットカレントインデックス](#setcurrentindex)|テーブル タイプのレコードセットにインデックスを設定するために呼び出されます。|
|[セオレコードセット::セットフィールドダーティ](#setfielddirty)|カレント レコードの指定したフィールドに変更をマークします。|
|[レコードセット::セットフィールドヌル](#setfieldnull)|現在のレコードの指定されたフィールドの値を Null (値なし) に設定します。|
|[コダレコード::セットフィールド値](#setfieldvalue)|レコードセット内のフィールドの値を設定します。|
|[レコードセット::セットフィールド値Null](#setfieldvaluenull)|レコードセット内のフィールドの値を Null に設定します。 (値を持たない)。|
|[セオロックモード::セットロックモード](#setlockingmode)|編集中に有効にするロックの種類を示す値を設定します。|
|[コダレコード::セットパラム値](#setparamvalue)|基になる DAOParameter オブジェクトに格納されている指定されたパラメーターの現在の値を設定します。|
|[クオダレコードセット::セットパラム値Null](#setparamvaluenull)|指定したパラメータの現在の値を Null (値なし) に設定します。|
|[コダレコードセット::設定パーセントポジション](#setpercentposition)|カレント レコードの位置を、レコードセット内のレコードの総数に対する割合に対応する位置に設定します。|
|[セオレコード::更新](#update)|新規または編集`AddNew`した`Edit`データをデータ ソースに保存して、または 操作を完了します。|

### <a name="public-data-members"></a>パブリック データ メンバー

|名前|説明|
|----------|-----------------|
|[セオレコード::m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields)|フィールドが自動的に変更済みとしてマークされるかどうかを示すフラグが含まれています。|
|[コダオレコード::m_nFields](#m_nfields)|レコードセット クラスのフィールド データ メンバの数と、データ ソースからレコードセットによって選択された列数を格納します。|
|[コダオレコード::m_nParams](#m_nparams)|レコードセット クラス内のパラメータ データ メンバの数を格納します。|
|[コダオレコード::m_pDAORecordset](#m_pdaorecordset)|レコードセット オブジェクトの基になる DAO インターフェイスへのポインター。|
|[コダオレコード::m_pDatabase](#m_pdatabase)|この結果セットのソース データベース。 オブジェクトへのポインターを格納[します](../../mfc/reference/cdaodatabase-class.md)。|
|[コダオレコード::m_strFilter](#m_strfilter)|SQL **WHERE**ステートメントの作成に使用する文字列を格納します。|
|[コダオレコード::m_strSort](#m_strsort)|SQL **ORDER BY**ステートメントの作成に使用する文字列を格納します。|

## <a name="remarks"></a>解説

"レコードセット" と`CDaoRecordset`呼ばれるオブジェクトは、次の 3 つの形式で使用できます。

- テーブル タイプのレコードセットは、1 つのデータベース テーブルのレコードを調べたり、追加したり、変更したり、削除したりするために使用できるベース テーブルを表します。

- ダイナセット タイプのレコードセットは、更新可能なレコードを持つことができるクエリの結果です。 これらのレコードセットは、基になるデータベース テーブルのレコードを調べたり、追加したり、変更したり、削除したりするために使用できるレコードのセットです。 ダイナセット タイプのレコードセットには、データベース内の 1 つ以上のテーブルのフィールドを含めることができます。

- スナップショット タイプのレコードセットは、データの検索やレポートの生成に使用できる一連のレコードの静的コピーです。 これらのレコードセットには、データベース内の 1 つ以上のテーブルのフィールドを含めることができますが、更新することはできません。

レコードセットの各フォームは、レコードセットが開かれた時点で固定されたレコードのセットを表します。 テーブル タイプのレコードセットまたはダイナセット タイプのレコードセットのレコードまでスクロールすると、レコードセットを開いた後に、他のユーザーやアプリケーション内の他のレコードセットによって行われた変更が反映されます。 (スナップショット タイプのレコードセットは更新できません。から直接使用`CDaoRecordset`することも、アプリケーション固有のレコードセット クラスを`CDaoRecordset`派生することもできます。 この場合は、次のいずれかの操作を行うことができます。

- レコードをスクロールします。

- インデックスを設定し[、Seek](#seek)を使用してレコードをすばやく検索します (テーブル タイプのレコードセットのみ)。

- 文字列比較に基づいてレコードを検索します: "<"、"""""""""""""""">"、\<または">"(ダイナセット タイプおよびスナップショット タイプのレコードセット)。

- レコードを更新し、ロック モードを指定します (スナップショット タイプのレコードセットを除く)。

- レコードセットをフィルタして、データ ソースで使用できるレコードから選択するレコードを制限します。

- レコードセットを並べ替えます。

- 実行時まで不明な情報で選択をカスタマイズするには、レコードセットをパラメータ化します。

クラス`CDaoRecordset`は、クラス`CRecordset`のインターフェイスと同様のインターフェイスを提供します。 主な違いは、`CDaoRecordset`クラスが OLE に基づいてデータ アクセス オブジェクト (DAO) を使用してデータにアクセスする点です。 クラス`CRecordset`は、オープン データベース接続 (ODBC) とその DBMS の ODBC ドライバーを使用して DBMS にアクセスします。

> [!NOTE]
> DAO データベース クラスは、オープン データベース接続 (ODBC) に基づく MFC データベース クラスとは異なります。 DAO データベースクラス名には、すべて "CDao" というプレフィックスが付いています。 DAO クラスを使用して ODBC データ ソースにアクセスすることはできます。DAO クラスは、通常、Jet データベース エンジンに固有の優れた機能を提供します。

クラスは直接使用`CDaoRecordset`することも、 から`CDaoRecordset`派生することもできます。 どちらの場合もレコードセット クラスを使用するには、データベースを開いてレコードセット オブジェクトを構築し、コンストラクターに`CDaoDatabase`オブジェクトへのポインターを渡します。 オブジェクトを`CDaoRecordset`構築して MFC で一時`CDaoDatabase`オブジェクトを作成することもできます。 次に、オブジェクトがテーブル タイプのレコードセット、ダイナセット タイプのレコードセット、またはスナップショット タイプのレコードセットのいずれであるかを指定して、レコードセットの[Open](#open)メンバー関数を呼び出します。 呼`Open`び出しは、データベースからデータを選択し、最初のレコードを取得します。

オブジェクトのメンバー関数とデータ メンバーを使用して、レコードをスクロールして操作します。 オブジェクトがテーブル タイプのレコードセット、ダイナセット タイプのレコードセット、スナップショット タイプのレコードセットのいずれであるか、および更新可能か読み取り専用であるかによって、使用できる操作は、データベースまたはオープン データベース接続 (ODBC) データ ソースの機能によって異なります。 呼び出し後に変更または追加された可能性のある`Open`レコードを更新するには、オブジェクトの[Requery](#requery)メンバー関数を呼び出します。 オブジェクトの`Close`メンバー関数を呼び出し、オブジェクトを終了すると破棄します。

`CDaoRecordset`DAO レコード フィールド エクスチェンジ (DFX) を使用して、ユーザーまたは`CDaoRecordset``CDaoRecordset`派生クラスのタイプ セーフな C++ メンバーを通じてレコード フィールドの読み取りと更新をサポートします。 また[、GetFieldValue](#getfieldvalue)と[SetFieldValue](#setfieldvalue)を使用して DFX メカニズムを使用せずに、データベース内の列の動的なバインドを実装することもできます。

関連情報については、DAO ヘルプの「レコード セット オブジェクト」を参照してください。

## <a name="inheritance-hierarchy"></a>継承階層

[CObject](../../mfc/reference/cobject-class.md)

`CDaoRecordset`

## <a name="requirements"></a>必要条件

**ヘッダー:** afxdao.h

## <a name="cdaorecordsetaddnew"></a><a name="addnew"></a>コダレコード::新しい追加

テーブル タイプまたはダイナセット タイプのレコードセットに新しいレコードを追加します。

```
virtual void AddNew();
```

### <a name="remarks"></a>解説

レコードのフィールドは、最初は Null です。 (データベース用語では、Null は "値を持たない" ことを意味し、C++ では NULL と同じではありません。操作を完了するには[、Update](#update)メンバー関数を呼び出す必要があります。 `Update`データ ソースに対する変更を保存します。

> [!CAUTION]
> レコードを編集し、 を呼び出`Update`さずに別のレコードにスクロールすると、変更は警告なしに失われます。

[AddNew](#addnew)を呼び出してダイナセット タイプのレコードセットにレコードを追加すると、レコードはレコードセットに表示され、基になるテーブルに含まれ、新`CDaoRecordset`しいオブジェクトから見えるようになります。

新しいレコードの位置は、レコードセットの種類によって異なります。

- ダイナセット タイプのレコードセットでは、新しいレコードが挿入される保証はありません。 この動作は、パフォーマンスと同時実行の理由から、Microsoft Jet 3.0 で変更されました。 新しく追加したレコードをカレント レコードにする場合は、最後に変更したレコードのブックマークを取得し、そのブックマークに移動します。

[!code-cpp[NVC_MFCDatabase#1](../../mfc/codesnippet/cpp/cdaorecordset-class_1.cpp)]

- インデックスが指定されているテーブル タイプのレコードセットでは、レコードは並べ替え順序で適切な位置に返されます。 インデックスが指定されていない場合は、レコードセットの末尾に新しいレコードが返されます。

使用する前に最新のレコードを`AddNew`使用したレコードは、現在のレコードのままです。 新しいレコードを現在のレコードにし、レコードセットがブックマークをサポートする場合は、基になる DAO レコードセット オブジェクトの LastModified プロパティ設定で識別されるブックマークに[SetBookmark](#setbookmark)を呼び出します。 この操作は、追加されたレコードのカウンター (自動インクリメント) フィールドの値を決定する場合に役立ちます。 詳細については、「[ラスト修正ブックマーク](#getlastmodifiedbookmark)」を参照してください。

データベースがトランザクションをサポートしている場合は、`AddNew`トランザクションの一部を呼び出すことができます。 トランザクションの詳細については、「[クラス CDaoWorkspace](../../mfc/reference/cdaoworkspace-class.md)」を参照してください。 呼び出す前に[CDaoWorkspace::BeginTrans](../../mfc/reference/cdaoworkspace-class.md#begintrans)を呼び出す`AddNew`必要があることに注意してください。

Open メンバー関数が`AddNew`呼び出されていない[Open](#open)レコードセットを呼び出す方法は無効です。 A`CDaoException`は、追加できない`AddNew`レコードセットを呼び出すとスローされます。 CanAppend を呼び出すことで、レコードセット[CanAppend](#canappend)が更新可能かどうかを判断できます。

フレームワークは、変更されたフィールド データ メンバーをマークして、DAO レコード フィールド エクスチェンジ (DFX) 機構によってデータ ソースのレコードに書き込まれるようにします。 フィールドの値を変更すると、通常はフィールドが自動的にダーティになるため[、SetFieldDirty](#setfielddirty)を自分で呼び出す必要はめったにありませんが、フィールド データ メンバーの値に関係なく、列が明示的に更新または挿入されるようにする必要がある場合があります。 DFX メカニズムでは **、PSEUDO NULL**を使用することもできます。 詳細については[、「CDaoFieldExchange::m_nOperation」](../../mfc/reference/cdaofieldexchange-class.md#m_noperation)を参照してください。

ダブル バッファリングメカニズムが使用されていない場合、フィールドの値を変更しても、フィールドはダーティとして自動的に設定されません。 この場合、フィールドを明示的にダーティに設定する必要があります。 [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields)に含まれるフラグは、この自動フィールド検査を制御します。

> [!NOTE]
> レコードがダブルバッファリングされている場合 (つまり、自動フィールド検査が有効になっている場合`CancelUpdate`)、呼び出しは、メンバー変数を`AddNew`以前`Edit`または呼び出された値に復元します。

関連情報については、DAO ヘルプの「AddNew メソッド」、「キャンセル更新メソッド」、「LastModified プロパティ」、および「EditMode プロパティ」の各トピックを参照してください。

## <a name="cdaorecordsetcanappend"></a><a name="canappend"></a>コダオレコードセット::缶詰

前に開いたレコードセットが[AddNew](#addnew)メンバー関数を呼び出して新しいレコードを追加できるかどうかを調べます。

```
BOOL CanAppend() const;
```

### <a name="return-value"></a>戻り値

レコードセットで新しいレコードを追加できる場合は 0 以外の値を指定します。それ以外の場合は 0。 `CanAppend`レコードセットを読み取り専用で開いた場合は 0 を返します。

### <a name="remarks"></a>解説

関連情報については、DAO ヘルプの「メソッドの追加」を参照してください。

## <a name="cdaorecordsetcanbookmark"></a><a name="canbookmark"></a>レコードセット::缶ブックマーク

以前に開いたレコードセットがブックマークを使用してレコードを個別にマークできるかどうかを調べます。

```
BOOL CanBookmark();
```

### <a name="return-value"></a>戻り値

レコードセットがブックマークをサポートする場合は 0 以外の値を返します。

### <a name="remarks"></a>解説

Microsoft Jet データベース エンジン のテーブルに基づいてレコードセットを使用している場合は、前方スクロール専用レコードセットとしてフラグが設定されたスナップショット タイプのレコードセットを除いて、ブックマークを使用できます。 他のデータベース製品 (外部 ODBC データ ソース) は、ブックマークをサポートしていない可能性があります。

関連情報については、DAO ヘルプの「ブックマーク可能なプロパティ」を参照してください。

## <a name="cdaorecordsetcancelupdate"></a><a name="cancelupdate"></a>レコードセット::キャンセル更新

メンバー`CancelUpdate`関数は、[編集](#edit)または[AddNew](#addnew)操作により保留中の更新をキャンセルします。

```
virtual void CancelUpdate();
```

### <a name="remarks"></a>解説

`Edit`たとえば、アプリケーションが または`AddNew`メンバー関数を呼び出し、 Update を`CancelUpdate`呼び出していない`Edit`場合`AddNew`、[呼](#update)び出された変更は、後または呼び出された後でキャンセルされます。

> [!NOTE]
> レコードがダブルバッファリングされている場合 (つまり、自動フィールド検査が有効になっている場合`CancelUpdate`)、呼び出しは、メンバー変数を`AddNew`以前`Edit`または呼び出された値に復元します。

操作が保留中または`Edit`何`AddNew`もない場合、MFC`CancelUpdate`が例外をスローします。 [GetEditMode](#geteditmode)メンバー関数を呼び出して、キャンセルできる保留中の操作があるかどうかを確認します。

関連情報については、DAO ヘルプの「更新のキャンセル方法」を参照してください。

## <a name="cdaorecordsetcanrestart"></a><a name="canrestart"></a>コダレコード::缶リスタート

このメンバー関数を呼び出して、レコードセットが`Requery`メンバ関数を呼び出してクエリを再開できるかどうかを調べます ( レコードを更新する) 。

```
BOOL CanRestart();
```

### <a name="return-value"></a>戻り値

レコードセットの`Requery`クエリを再度実行するために呼び出すことができる場合は 0 以外の値を返します。

### <a name="remarks"></a>解説

テーブル タイプのレコードセットは、`Requery`をサポートしていません。

サポート`Requery`されていない場合は[、Close](#close)を呼び出してから[Open](#open)を呼び出してデータを更新します。 パラメーター値が`Requery`変更された後に、レコードセット オブジェクトの基になるパラメーター クエリを更新する呼び出しを行うことができます。

関連情報については、DAO ヘルプの「再開可能なプロパティ」を参照してください。

## <a name="cdaorecordsetcanscroll"></a><a name="canscroll"></a>コダレコード::缶スクロール

レコードセットでスクロールが許可されているかどうかを調べます。

```
BOOL CanScroll() const;
```

### <a name="return-value"></a>戻り値

レコードをスクロールできる場合は 0 以外の値を返します。

### <a name="remarks"></a>解説

[で開く](#open)`dbForwardOnly`を呼び出した場合、レコードセットは前方にスクロールすることしかできません。

関連情報については、DAO ヘルプの「DAO を使用した現在のレコード ポインタの配置」を参照してください。

## <a name="cdaorecordsetcantransact"></a><a name="cantransact"></a>コダレコード::缶トランスアクト

レコードセットがトランザクションを許可するかどうかを調べます。

```
BOOL CanTransact();
```

### <a name="return-value"></a>戻り値

基になるデータ ソースがトランザクションをサポートする場合は 0 以外の値を返します。

### <a name="remarks"></a>解説

関連情報については、DAO ヘルプの「トランザクション プロパティ」を参照してください。

## <a name="cdaorecordsetcanupdate"></a><a name="canupdate"></a>コダレコード::缶更新

レコードセットを更新できるかどうかを調べます。

```
BOOL CanUpdate() const;
```

### <a name="return-value"></a>戻り値

レコードセットを更新 (レコードの追加、更新、削除) できる場合は 0 以外の値を返します。

### <a name="remarks"></a>解説

基になるデータ ソースが読み取り専用の場合、またはレコードセットに対して`dbReadOnly` [Open](#open)を呼び出したときに*nOptions*に指定した場合、レコードセットは読み取り専用になることがあります。

関連情報については、DAO ヘルプの「AddNew メソッド」、「メソッドの編集」、「メソッドの削除」、「メソッドの更新」、および「更新可能なプロパティ」の各トピックを参照してください。

## <a name="cdaorecordsetcdaorecordset"></a><a name="cdaorecordset"></a>コダレコードセット::CDaoレコード

`CDaoRecordset` オブジェクトを構築します。

```
CDaoRecordset(CDaoDatabase* pDatabase = NULL);
```

### <a name="parameters"></a>パラメーター

*データベース*<br/>
[オブジェクト](../../mfc/reference/cdaodatabase-class.md)へのポインターを格納するか、NULL 値を指定します。 NULL でない場合、`CDaoDatabase`オブジェクトの`Open`メンバー関数がデータ ソースに接続するために呼び出されていない場合、レコードセットは、独自の[Open](#open)呼び出し中に、オブジェクトのメンバー関数を開こうとします。 NULL を渡すと、`CDaoDatabase`オブジェクトが作成され、からレコードセット クラスを派生した場合に指定したデータ ソース情報`CDaoRecordset`を使用して接続されます。

### <a name="remarks"></a>解説

を直接使用`CDaoRecordset`することも、アプリケーション固有のクラスを から`CDaoRecordset`派生することもできます。 クラス ウィザードを使用して、レコードセット クラスを派生させることができます。

> [!NOTE]
> 派生クラスの`CDaoRecordset`場合は、派生クラスが独自のコンストラクターを提供する必要があります。 派生クラスのコンストラクターで、コンストラクター`CDaoRecordset::CDaoRecordset`を呼び出して、適切なパラメーターを渡します。

オブジェクトを自動的に作成して接続するには`CDaoDatabase`、レコードセット コンストラクターに NULL を渡します。 これは、レコードセットを構築する前にオブジェクトを構築および接続する`CDaoDatabase`必要がない便利なショートカットです。 オブジェクトが`CDaoDatabase`開いていない場合は、既定のワークスペースを使用する[CDaoWorkspace](../../mfc/reference/cdaoworkspace-class.md)オブジェクトも作成されます。 詳細については[、「CDao データベース::CDao データベース」を参照してください。](../../mfc/reference/cdaodatabase-class.md#cdaodatabase)

## <a name="cdaorecordsetclose"></a><a name="close"></a>コダレコード::閉じる

オブジェクトを`CDaoRecordset`閉じると、関連付けられたデータベース内の開いているレコードセットのコレクションからオブジェクトが削除されます。

```
virtual void Close();
```

### <a name="remarks"></a>解説

オブジェクト`Close`は`CDaoRecordset`破棄されないため、同じデータ ソースまたは別のデータ`Open`ソースを呼び出してオブジェクトを再利用できます。

保留中の[AddNew](#addnew)ステートメントまたは[Edit](#edit)ステートメントはすべて取り消され、保留中のすべてのトランザクションはロールバックされます。 保留中の追加または編集を保持する場合は、各レコード[Update](#update)セットを呼び`Close`出す前に Update を呼び出します。

を呼び`Open`出した後`Close`、もう一度呼び出すことができます。 これにより、レコードセット オブジェクトを再利用できます。 可能であれば[、Requery](#requery)を呼び出す方法を使用することをおしだい。

関連情報については、DAO ヘルプの「メソッドを閉じる」を参照してください。

## <a name="cdaorecordsetdelete"></a><a name="delete"></a>コダオレコード::Dエレテ

開いているダイナセット タイプまたはテーブル タイプのレコードセット オブジェクトの現在のレコードを削除します。

```
virtual void Delete();
```

### <a name="remarks"></a>解説

削除が成功すると、レコードセットのフィールド データ メンバーは Null 値に設定され、削除されたレコードから移動するには、レコードセット ナビゲーション メンバー関数 ([移動](#move)、[シーク](#seek)[、SetBookmark](#setbookmark)など) のいずれかを明示的に呼び出す必要があります。 レコードセットからレコードを削除する場合は、呼び出す`Delete`前にレコードセットにカレント レコードが存在する必要があります。それ以外の場合、MFC は例外をスローします。

`Delete`現在のレコードを削除し、アクセスできないようにします。 削除されたレコードは編集または使用できませんが、現在のレコードはそのまま残ります。 ただし、いったん別のレコードに移動すると、削除されたレコードを再度現在のレコードにすることはできません。

> [!CAUTION]
> レコードセットは更新可能で、呼び出`Delete`し時にレコードセットに有効なレコードが現在存在している必要があります。 たとえば、レコードを削除しても、新しいレコードにスクロールしないと、再度呼び出`Delete`す場合は`Delete`[、CDaoException](../../mfc/reference/cdaoexception-class.md)をスローします。

トランザクションを使用して[CDaoWorkspace::ロールバック](../../mfc/reference/cdaoworkspace-class.md#rollback)メンバー関数を呼び出すと、レコードの削除を取り消すことができます。 ベース テーブルがカスケード削除関係の主テーブルである場合、現在のレコードを削除すると、外部テーブルの 1 つ以上のレコードが削除される可能性があります。 詳細については、DAO ヘルプの「連鎖削除」の定義を参照してください。

と`AddNew``Edit`とは異なり`Delete`、 への呼び出し`Update`の後に.

関連情報については、DAO ヘルプの「AddNew メソッド」、「メソッドの編集」、「メソッドの削除」、「メソッドの更新」、および「更新可能なプロパティ」の各トピックを参照してください。

## <a name="cdaorecordsetdofieldexchange"></a><a name="dofieldexchange"></a>コダオレコードセット::Dフィールドエクスチェンジ

フレームワークは、レコードセット オブジェクトのフィールド データ メンバーと、データ ソースの現在のレコードの対応する列との間でデータを自動的に交換するために、このメンバー関数を呼び出します。

```
virtual void DoFieldExchange(CDaoFieldExchange* pFX);
```

### <a name="parameters"></a>パラメーター

*Pfx*<br/>
オブジェクトへのポインターを`CDaoFieldExchange`格納します。 フレームワークは、フィールド交換操作のコンテキストを指定するために、このオブジェクトを既に設定しています。

### <a name="remarks"></a>解説

また、パラメータ データ メンバーがある場合は、レコードセットの選択用の SQL ステートメント文字列内のパラメータ プレースホルダにバインドします。 DAO レコード フィールド エクスチェンジ (DFX) と呼ばれるフィールド データの交換は、レコードセット オブジェクトのフィールド データ メンバーからデータ ソースのレコードのフィールド、およびデータ ソースのレコードからレコードセット オブジェクトまで、両方向に機能します。 列を動的にバインドする場合は、 を実装`DoFieldExchange`する必要はありません。

派生レコードセット クラスに実装`DoFieldExchange`するために通常必要な操作は、ClassWizard を使用してクラスを作成し、フィールド データ メンバーの名前とデータ型を指定する必要があります。 また、ClassWizard が書き込むコードを追加して、パラメーター データ メンバーを指定することもできます。 すべてのフィールドを動的にバインドする場合、パラメーター・データ・メンバーを指定しない限り、この関数は非アクティブになります。

ClassWizard を使用して派生レコードセット クラスを宣言すると、ウィザードによって`DoFieldExchange`、次の例のようなオーバーライドが書き込まれます。

[!code-cpp[NVC_MFCDatabase#2](../../mfc/codesnippet/cpp/cdaorecordset-class_2.cpp)]

## <a name="cdaorecordsetedit"></a><a name="edit"></a>コダオレコード::編集

現在のレコードを変更できるようにするには、このメンバー関数を呼び出します。

```
virtual void Edit();
```

### <a name="remarks"></a>解説

メンバー関数を`Edit`呼び出すと、現在のレコードのフィールドに加えられた変更がコピー バッファにコピーされます。 レコードに必要な変更を加えたら、変更`Update`を保存するために呼び出します。 `Edit`レコードセットのデータ メンバの値を保存します。 を呼び`Edit`出した場合、変更を`Edit`加えてから再度呼び出すと、レコードの値は最初`Edit`の呼び出しの前の値に戻ります。

> [!CAUTION]
> レコードを編集し、最初に 呼び出`Update`さずに別のレコードに移動する操作を実行すると、変更は警告なしに失われます。 また、レコードセットまたは親データベースを閉じると、編集したレコードは警告なしに破棄されます。

場合によっては、列を Null (データを含み) にして更新する必要がある場合があります。 これを行うには、TRUE`SetFieldNull`のパラメーターを指定して呼び出して、フィールド Null をマークします。これにより、列も更新されます。 値が変更されていない場合でもフィールドをデータ ソースに書き込む場合は、TRUE`SetFieldDirty`のパラメーターを指定して呼び出します。 これは、フィールドに Null 値が設定されている場合でも機能します。

フレームワークは、変更されたフィールド データ メンバーをマークして、DAO レコード フィールド エクスチェンジ (DFX) 機構によってデータ ソースのレコードに書き込まれるようにします。 フィールドの値を変更すると、通常はフィールドが自動的にダーティになるため[、SetFieldDirty](#setfielddirty)を自分で呼び出す必要はめったにありませんが、フィールド データ メンバーの値に関係なく、列が明示的に更新または挿入されるようにする必要がある場合があります。 DFX メカニズムでは **、PSEUDO NULL**を使用することもできます。 詳細については[、「CDaoFieldExchange::m_nOperation」](../../mfc/reference/cdaofieldexchange-class.md#m_noperation)を参照してください。

ダブル バッファリングメカニズムが使用されていない場合、フィールドの値を変更しても、フィールドはダーティとして自動的に設定されません。 この場合、フィールドを明示的にダーティに設定する必要があります。 [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields)に含まれるフラグは、この自動フィールド検査を制御します。

マルチユーザー環境でレコードセット オブジェクトが悲観的にロックされている場合、レコード`Edit`は更新が完了するまで使用されるまでロックされたままになります。 レコードセットがオプティミスティックロックされている場合、レコードはロックされ、データベースで更新される直前に、編集前のレコードと比較されます。 呼び出`Edit`し後にレコードが変更された`Update`場合、操作は失敗し、MFC は例外をスローします。 ロック モードは で変更`SetLockingMode`できます。

> [!NOTE]
> オプティミスティック・ロックは、ODBC やインストール可能な ISAM などの外部データベース形式で常に使用されます。

現在のレコードは、 を呼`Edit`び出した後も現在のレコードのままです。 を呼`Edit`び出すためには、現在のレコードが存在する必要があります。 カレント レコードがない場合、またはレコードセットがオープン テーブル タイプまたはダイナセット タイプのレコードセット オブジェクトを参照していない場合は、例外が発生します。 呼`Edit`び出`CDaoException`しは、次の条件でスローされます。

- 現在のレコードが存在しません。

- データベースまたはレコードセットは読み取り専用です。

- レコード内のフィールドは更新可能ではありません。

- データベースまたはレコードセットは、別のユーザーが排他用に開かれました。

- 別のユーザーが、レコードを含むページをロックしました。

データ ソースがトランザクションをサポートしている場合は、トランザクション`Edit`の呼び出しの一部を作成できます。 呼び出しの`CDaoWorkspace::BeginTrans`前、`Edit`およびレコードセットが開かれた後に呼び出す必要があります。 また、呼び`CDaoWorkspace::CommitTrans`出しは`Edit`操作を完了`Update`するための呼び出しの代わりではありません。 トランザクションの詳細については、クラス`CDaoWorkspace`を参照してください。

関連情報については、DAO ヘルプの「AddNew メソッド」、「メソッドの編集」、「メソッドの削除」、「メソッドの更新」、および「更新可能なプロパティ」の各トピックを参照してください。

## <a name="cdaorecordsetfillcache"></a><a name="fillcache"></a>レコードセット::フィルキャッシュ

レコードセットから指定した数のレコードをキャッシュします。

```
void FillCache(
    long* pSize = NULL,
    COleVariant* pBookmark = NULL);
```

### <a name="parameters"></a>パラメーター

*Psize*<br/>
キャッシュに入力する行数を指定します。 このパラメーターを省略すると、基になる DAO オブジェクトの CacheSize プロパティの設定によって値が決定されます。

*ブックマーク*<br/>
ブックマークを指定する[COleVariant](../../mfc/reference/colevariant-class.md)です。 キャッシュは、このブックマークで示されたレコードから始まります。 このパラメータを省略すると、基になる DAO オブジェクトの CacheStart プロパティで示されるレコードからキャッシュが設定されます。

### <a name="remarks"></a>解説

キャッシュを使用すると、リモート サーバーからデータを取得またはフェッチするアプリケーションのパフォーマンスが向上します。 キャッシュは、アプリケーションの実行中にデータが再び要求される可能性があることを前提に、サーバーから最後にフェッチされたデータを保持するローカル メモリ内の領域です。 データが要求されると、Microsoft Jet データベース エンジンは、キャッシュのデータをサーバーからフェッチするのではなく、キャッシュを最初にチェックします。 ODBC 以外のデータ ソースでデータ キャッシュを使用しても、キャッシュにデータが保存されないので、何の効果もありません。

キャッシュにレコードがフェッチされるのを待つのではなく、メンバー関数を呼び出すことによって、いつでも明示的にキャッシュを`FillCache`埋めることができます。 これは、一度に 1 つではなく`FillCache`複数のレコードをフェッチするため、キャッシュを埋めるより高速な方法です。 たとえば、各レコードのスクリーンが表示されている間に、アプリケーション呼び出し`FillCache`を使用して次の画面レコードを取得できます。

レコードセット オブジェクトでアクセスされる ODBC データベースは、ローカル キャッシュを持つことができます。 キャッシュを作成するには、リモート データ ソースからレコードセット オブジェクトを開き、`SetCacheSize`レコード`SetCacheStart`セットの と メンバー関数を呼び出します。 *lSize*と*lBookmark*が、 と`SetCacheSize``SetCacheStart`で指定された範囲の一部または完全範囲外の範囲を作成する場合、この範囲の外側にあるレコードセットの部分は無視され、キャッシュに読み込まれません。 要求`FillCache`がリモート データ ソースに残っているレコードより多い場合は、残りのレコードだけがフェッチされ、例外はスローされません。

キャッシュからフェッチされたレコードは、他のユーザーがソース データに対して同時に行った変更を反映しません。

`FillCache`は、キャッシュされていないレコードのみをフェッチします。 キャッシュされたすべてのデータを強制的に更新するには *、lSize*パラメータ`SetCacheSize`を 0 にしてメンバー関数を呼び出`SetCacheSize`し、最初に要求したキャッシュのサイズと同じ*lSize*パラメータを指定して`FillCache`もう一度呼び出し、 を呼び出します。

関連情報については、DAO ヘルプの「FillCache メソッド」を参照してください。

## <a name="cdaorecordsetfind"></a><a name="find"></a>コダオレコード::検索

比較演算子を使用して、ダイナセット タイプまたはスナップショット タイプのレコードセット内の特定の文字列を検索します。

```
virtual BOOL Find(
    long lFindType,
    LPCTSTR lpszFilter);
```

### <a name="parameters"></a>パラメーター

*l検索タイプ*<br/>
必要な検索操作の種類を示す値。 指定できる値は、

- AFX_DAO_NEXT一致する文字列の次の場所を検索します。

- AFX_DAO_PREV 一致する文字列の前の場所を検索します。

- AFX_DAO_FIRST 一致する文字列の最初の場所を検索します。

- AFX_DAO_LAST 一致する文字列の最後の場所を検索します。

*Lpszfilter*<br/>
レコードを検索するために使用される**WHERE**文字列式 (SQL ステートメントの**WHERE**句など) です。 次に例を示します。

[!code-cpp[NVC_MFCDatabase#3](../../mfc/codesnippet/cpp/cdaorecordset-class_3.cpp)]

### <a name="return-value"></a>戻り値

一致するレコードが見つかった場合は 0 以外、それ以外の場合は 0。

### <a name="remarks"></a>解説

文字列の最初、次、前、または最後のインスタンスを検索できます。 `Find`は仮想関数なので、オーバーライドして独自の実装を追加できます。 `FindFirst`、、`FindLast`および`FindNext``FindPrev`メンバー関数はメンバー関数を`Find`呼び出すため、すべての`Find`Find 操作の動作を制御できます。

テーブル タイプのレコードセット内のレコードを検索するには[、Seek](#seek)メンバー関数を呼び出します。

> [!TIP]
> レコードのセットが小さいほど、より効果的`Find`になります。 一般的に、特に ODBC データでは、必要なレコードだけを取得する新しいクエリを作成することをお望めします。

関連情報については、DAO ヘルプのトピック「検索First、FindLast、次の検索、前のメソッドの検索」を参照してください。

## <a name="cdaorecordsetfindfirst"></a><a name="findfirst"></a>コダレコード::最初に検索

指定した条件に一致する最初のレコードを検索します。

```
BOOL FindFirst(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>パラメーター

*Lpszfilter*<br/>
レコードを検索するために使用される**WHERE**文字列式 (SQL ステートメントの**WHERE**句など) です。

### <a name="return-value"></a>戻り値

一致するレコードが見つかった場合は 0 以外、それ以外の場合は 0。

### <a name="remarks"></a>解説

メンバー`FindFirst`関数は、レコードセットの先頭から検索を開始し、レコードセットの末尾まで検索します。

特定の条件を満たすレコードだけでなく、すべてのレコードを検索に含める場合は、Move 操作のいずれかを使用してレコード間を移動します。 テーブル タイプのレコードセット内のレコードを検索するには、`Seek`メンバー関数を呼び出します。

条件に一致するレコードが見つからない場合、現在のレコード ポインタは未確定`FindFirst`になり、0 を返します。 レコードセットに、条件を満たすレコードが複数含まれている場合は、`FindFirst`最初のレコードを検索し、`FindNext`次のレコードを検索します。

> [!CAUTION]
> 現在のレコードを編集する場合は、別のレコードに移動する前`Update`に、メンバー関数を呼び出して変更を保存してください。 更新せずに別のレコードに移動すると、警告なしに変更は失われます。

メンバー`Find`関数は、次の表で指定された場所と方向から検索します。

|操作の検索|Begin|検索方向|
|---------------------|-----------|----------------------|
|`FindFirst`|レコードセットの先頭|レコードセットの末尾|
|`FindLast`|レコードセットの末尾|レコードセットの先頭|
|`FindNext`|現在のレコード|レコードセットの末尾|
|`FindPrevious`|現在のレコード|レコードセットの先頭|

> [!NOTE]
> を呼び`FindLast`出すと、検索を開始する前に Microsoft Jet データベース エンジンによってレコードセットが完全に設定されます (まだ行われていない場合)。 最初の検索は、以降の検索よりも時間がかかる場合があります。

検索操作の 1 つを使用することは、呼び`MoveFirst`出`MoveNext`しまたは と同じではありません。 検索操作を実行して移動操作を実行できます。

検索操作を使用する場合は、次の点に注意してください。

- 0`Find`以外を返す場合、現在のレコードは定義されません。 この場合、現在のレコード ポインタを有効なレコードに戻す必要があります。

- 前方スクロール専用のスナップショット タイプのレコードセットでは、検索操作を使用できません。

- 日付を含むフィールドを検索する場合は、米国版の Microsoft Jet データベース エンジンを使用していない場合でも、米国日付形式 (月-日-年) を使用する必要があります。それ以外の場合は、一致するレコードが見つからない可能性があります。

- ODBC データベースや大きなダイナセットを操作する場合、特に大きなレコードセットを操作する場合は、検索操作の使用が遅くなることがあります。 カスタマイズされた**ORDERBY**句または**WHERE**句、パラメータ クエリ、または`CDaoQuerydef`特定のインデックス付きレコードを取得するオブジェクトを使用して SQL クエリを使用することにより、パフォーマンスを向上させることができます。

関連情報については、DAO ヘルプのトピック「検索First、FindLast、次の検索、前のメソッドの検索」を参照してください。

## <a name="cdaorecordsetfindlast"></a><a name="findlast"></a>コダレコード::FindLast

指定した条件に一致する最後のレコードを検索します。

```
BOOL FindLast(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>パラメーター

*Lpszfilter*<br/>
レコードを検索するために使用される**WHERE**文字列式 (SQL ステートメントの**WHERE**句など) です。

### <a name="return-value"></a>戻り値

一致するレコードが見つかった場合は 0 以外、それ以外の場合は 0。

### <a name="remarks"></a>解説

メンバー`FindLast`関数は、レコードセットの末尾から検索を開始し、レコードセットの先頭に向かって逆方向に検索します。

特定の条件を満たすレコードだけでなく、すべてのレコードを検索に含める場合は、Move 操作のいずれかを使用してレコード間を移動します。 テーブル タイプのレコードセット内のレコードを検索するには、`Seek`メンバー関数を呼び出します。

条件に一致するレコードが見つからない場合、現在のレコード ポインタは未確定`FindLast`になり、0 を返します。 レコードセットに、条件を満たすレコードが複数含まれている場合は、`FindFirst`最初の出現箇所を見つけ`FindNext`、最初の出現箇所の次の出現を見つけます。

> [!CAUTION]
> 現在のレコードを編集する場合は、別のレコードに移動する前`Update`に、メンバー関数を呼び出して変更を保存してください。 更新せずに別のレコードに移動すると、警告なしに変更は失われます。

検索操作の 1 つを使用することは、呼び`MoveFirst`出`MoveNext`しまたは と同じではありません。 検索操作を実行して移動操作を実行できます。

検索操作を使用する場合は、次の点に注意してください。

- 0`Find`以外を返す場合、現在のレコードは定義されません。 この場合、現在のレコード ポインタを有効なレコードに戻す必要があります。

- 前方スクロール専用のスナップショット タイプのレコードセットでは、検索操作を使用できません。

- 日付を含むフィールドを検索する場合は、米国版の Microsoft Jet データベース エンジンを使用していない場合でも、米国日付形式 (月-日-年) を使用する必要があります。それ以外の場合は、一致するレコードが見つからない可能性があります。

- ODBC データベースや大きなダイナセットを操作する場合、特に大きなレコードセットを操作する場合は、検索操作の使用が遅くなることがあります。 カスタマイズされた**ORDERBY**句または**WHERE**句、パラメータ クエリ、または`CDaoQuerydef`特定のインデックス付きレコードを取得するオブジェクトを使用して SQL クエリを使用することにより、パフォーマンスを向上させることができます。

関連情報については、DAO ヘルプのトピック「検索First、FindLast、次の検索、前のメソッドの検索」を参照してください。

## <a name="cdaorecordsetfindnext"></a><a name="findnext"></a>次を見つける

指定した条件に一致する次のレコードを検索します。

```
BOOL FindNext(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>パラメーター

*Lpszfilter*<br/>
レコードを検索するために使用される**WHERE**文字列式 (SQL ステートメントの**WHERE**句など) です。

### <a name="return-value"></a>戻り値

一致するレコードが見つかった場合は 0 以外、それ以外の場合は 0。

### <a name="remarks"></a>解説

メンバー`FindNext`関数は、現在のレコードから検索を開始し、レコードセットの末尾まで検索します。

特定の条件を満たすレコードだけでなく、すべてのレコードを検索に含める場合は、Move 操作のいずれかを使用してレコード間を移動します。 テーブル タイプのレコードセット内のレコードを検索するには、`Seek`メンバー関数を呼び出します。

条件に一致するレコードが見つからない場合、現在のレコード ポインタは未確定`FindNext`になり、0 を返します。 レコードセットに、条件を満たすレコードが複数含まれている場合は、`FindFirst`最初のレコードを検索し、`FindNext`次のレコードを検索します。

> [!CAUTION]
> 現在のレコードを編集する場合は、別のレコードに移動する前`Update`に、メンバー関数を呼び出して変更を保存してください。 更新せずに別のレコードに移動すると、警告なしに変更は失われます。

検索操作の 1 つを使用することは、呼び`MoveFirst`出`MoveNext`しまたは と同じではありません。 検索操作を実行して移動操作を実行できます。

検索操作を使用する場合は、次の点に注意してください。

- 0`Find`以外を返す場合、現在のレコードは定義されません。 この場合、現在のレコード ポインタを有効なレコードに戻す必要があります。

- 前方スクロール専用のスナップショット タイプのレコードセットでは、検索操作を使用できません。

- 日付を含むフィールドを検索する場合は、米国版の Microsoft Jet データベース エンジンを使用していない場合でも、米国日付形式 (月-日-年) を使用する必要があります。それ以外の場合は、一致するレコードが見つからない可能性があります。

- ODBC データベースや大きなダイナセットを操作する場合、特に大きなレコードセットを操作する場合は、検索操作の使用が遅くなることがあります。 カスタマイズされた**ORDERBY**句または**WHERE**句、パラメータ クエリ、または`CDaoQuerydef`特定のインデックス付きレコードを取得するオブジェクトを使用して SQL クエリを使用することにより、パフォーマンスを向上させることができます。

関連情報については、DAO ヘルプのトピック「検索First、FindLast、次の検索、前のメソッドの検索」を参照してください。

## <a name="cdaorecordsetfindprev"></a><a name="findprev"></a>コダオレコードセット::FindPrev

指定した条件に一致する前のレコードを検索します。

```
BOOL FindPrev(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>パラメーター

*Lpszfilter*<br/>
レコードを検索するために使用される**WHERE**文字列式 (SQL ステートメントの**WHERE**句など) です。

### <a name="return-value"></a>戻り値

一致するレコードが見つかった場合は 0 以外、それ以外の場合は 0。

### <a name="remarks"></a>解説

メンバー`FindPrev`関数は、現在のレコードから検索を開始し、レコードセットの先頭に向かって逆方向に検索します。

特定の条件を満たすレコードだけでなく、すべてのレコードを検索に含める場合は、Move 操作のいずれかを使用してレコード間を移動します。 テーブル タイプのレコードセット内のレコードを検索するには、`Seek`メンバー関数を呼び出します。

条件に一致するレコードが見つからない場合、現在のレコード ポインタは未確定`FindPrev`になり、0 を返します。 レコードセットに、条件を満たすレコードが複数含まれている場合は、`FindFirst`最初のレコードを検索し、`FindNext`次のレコードを検索します。

> [!CAUTION]
> 現在のレコードを編集する場合は、別のレコードに移動する前`Update`に、メンバー関数を呼び出して変更を保存してください。 更新せずに別のレコードに移動すると、警告なしに変更は失われます。

検索操作の 1 つを使用することは、呼び`MoveFirst`出`MoveNext`しまたは と同じではありません。 検索操作を実行して移動操作を実行できます。

検索操作を使用する場合は、次の点に注意してください。

- 0`Find`以外を返す場合、現在のレコードは定義されません。 この場合、現在のレコード ポインタを有効なレコードに戻す必要があります。

- 前方スクロール専用のスナップショット タイプのレコードセットでは、検索操作を使用できません。

- 日付を含むフィールドを検索する場合は、米国版の Microsoft Jet データベース エンジンを使用していない場合でも、米国日付形式 (月-日-年) を使用する必要があります。それ以外の場合は、一致するレコードが見つからない可能性があります。

- ODBC データベースや大きなダイナセットを操作する場合、特に大きなレコードセットを操作する場合は、検索操作の使用が遅くなることがあります。 カスタマイズされた**ORDERBY**句または**WHERE**句、パラメータ クエリ、または`CDaoQuerydef`特定のインデックス付きレコードを取得するオブジェクトを使用して SQL クエリを使用することにより、パフォーマンスを向上させることができます。

関連情報については、DAO ヘルプのトピック「検索First、FindLast、次の検索、前のメソッドの検索」を参照してください。

## <a name="cdaorecordsetgetabsoluteposition"></a><a name="getabsoluteposition"></a>コダレコードセット::絶対位置を取得します。

レコードセット オブジェクトの現在のレコードのレコード番号を返します。

```
long GetAbsolutePosition();
```

### <a name="return-value"></a>戻り値

0 からレコードセット内のレコード数までの整数。 レコードセット内の現在のレコードの位置を表す序数に対応します。

### <a name="remarks"></a>解説

基になる DAO オブジェクトの絶対位置プロパティ値は、0 から始まります。0 の設定は、レコードセットの最初のレコードを参照します。 レコードセットに設定されたレコードの数を調べるには、 [GetRecordCount](#getrecordcount)を呼び出します。 カウント`GetRecordCount`を決定するためにすべてのレコードにアクセスする必要があるため、呼び出しには時間がかかる場合があります。

レコードセットにレコードがない場合のように、カレント レコードがない場合は、-1 が返されます。 カレント レコードが削除されると、AbsolutePosition プロパティ値は定義されず、参照されている場合は例外がスローされます。 ダイナセット タイプのレコードセットの場合、新しいレコードはシーケンスの末尾に追加されます。

> [!NOTE]
> このプロパティは、代理レコード番号として使用するためのものではありません。 ブックマークは、指定された位置を保持して戻す方法として推奨され、すべての種類のレコードセット オブジェクトに現在のレコードを配置する唯一の方法です。 特に、レコードの前にあるレコードが削除されると、特定のレコードの位置が変わります。 また、レコードセット内の個々のレコードの順序は **、ORDERBY**句を使用して SQL ステートメントを使用して作成されない限り、レコードセットが再作成された場合に、そのレコードが同じ絶対位置を持つという保証はありません。

> [!NOTE]
> このメンバー関数は、ダイナセット タイプおよびスナップショット タイプのレコードセットに対してのみ有効です。

関連情報については、DAO ヘルプの「絶対位置プロパティ」を参照してください。

## <a name="cdaorecordsetgetbookmark"></a><a name="getbookmark"></a>レコードセット::取得ブックマーク

特定のレコードのブックマーク値を取得します。

```
COleVariant GetBookmark();
```

### <a name="return-value"></a>戻り値

現在のレコードのブックマークを表す値を返します。

### <a name="remarks"></a>解説

レコードセット オブジェクトを作成または開くと、各レコードがサポートされている場合は、そのレコードの各レコードに既に一意のブックマークが設定されています。 レコード`CanBookmark`セットがブックマークをサポートしているかどうかを調べる呼び出し。

オブジェクトにブックマークの値を割り当てることによって、現在のレコードのブックマークを`COleVariant`保存できます。 別のレコードに移動した後、いつでもそのレコードにすばやく戻るには、その`SetBookmark``COleVariant`オブジェクトの値に対応するパラメータを指定して呼び出します。

> [!NOTE]
> [再クエリを](#requery)呼び出すと、DAO のブックマークが変更されます。

関連情報については、DAO ヘルプの「ブックマーク プロパティ」を参照してください。

## <a name="cdaorecordsetgetcachesize"></a><a name="getcachesize"></a>レコードセット::ゲットキャッシュサイズ

キャッシュされたレコードの数を取得します。

```
long GetCacheSize();
```

### <a name="return-value"></a>戻り値

ODBC データ ソースからローカルにキャッシュされるデータを含むダイナセット タイプのレコードセット内のレコード数を指定する値。

### <a name="remarks"></a>解説

データ キャッシュを使用すると、ダイナセット タイプのレコードセット オブジェクトを使用してリモート サーバーからデータを取得するアプリケーションのパフォーマンスが向上します。 キャッシュは、アプリケーションの実行中にデータが再び要求される場合に、サーバーから最後に取得されたデータを保持するローカル メモリ内の領域です。 データが要求されると、Microsoft Jet データベース エンジンは、要求されたデータをサーバーから取得するのではなく、まずキャッシュをチェックします。 ODBC データ ソースから取得されていないデータは、キャッシュに保存されません。

アタッチ テーブルなどの ODBC データ ソースは、ローカル キャッシュを持つことができます。

関連情報については、DAO ヘルプの「CacheSize、CacheStart プロパティ」を参照してください。

## <a name="cdaorecordsetgetcachestart"></a><a name="getcachestart"></a>レコードセット::ゲットキャッシュスタート

キャッシュされるレコードセットの最初のレコードのブックマーク値を取得します。

```
COleVariant GetCacheStart();
```

### <a name="return-value"></a>戻り値

キャッシュ`COleVariant`されるレコードセットの最初のレコードのブックマークを指定します。

### <a name="remarks"></a>解説

Microsoft Jet データベース エンジンはキャッシュ範囲内のレコードをキャッシュから要求し、キャッシュ範囲外のレコードをサーバーから要求します。

> [!NOTE]
> キャッシュから取得されたレコードには、他のユーザーがソース データに対して同時に行った変更は反映されません。

関連情報については、DAO ヘルプの「CacheSize、CacheStart プロパティ」を参照してください。

## <a name="cdaorecordsetgetcurrentindex"></a><a name="getcurrentindex"></a>レコードセット::ゲットカレントインデックス

インデックス付きテーブル型`CDaoRecordset`オブジェクトで現在使用されているインデックスを調べます。

```
CString GetCurrentIndex();
```

### <a name="return-value"></a>戻り値

テーブル`CString`タイプのレコードセットで現在使用されているインデックスの名前を格納する。 インデックスが設定されていない場合は、空の文字列を返します。

### <a name="remarks"></a>解説

このインデックスは、テーブル タイプのレコードセット内のレコードを並べ替えるための基礎であり[、Seek](#seek)メンバー関数がレコードを検索するために使用します。

オブジェクト`CDaoRecordset`は複数のインデックスを持つことができますが、一度に 1 つのインデックスしか使用できません ([ただし、CDaoTableDef](../../mfc/reference/cdaotabledef-class.md)オブジェクトには複数のインデックスが定義されている場合もあります)。

関連情報については、DAO ヘルプのトピック「インデックス オブジェクト」および「現在のインデックス」の定義を参照してください。

## <a name="cdaorecordsetgetdatecreated"></a><a name="getdatecreated"></a>コダオレコードセット::ゲットデイト作成

ベース テーブルが作成された日時を取得します。

```
COleDateTime GetDateCreated();
```

### <a name="return-value"></a>戻り値

ベース テーブルが作成された日付と時刻を含む[COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md)オブジェクト。

### <a name="remarks"></a>解説

日付と時刻の設定は、ベース テーブルが作成されたコンピュータから取得されます。

関連情報については、DAO ヘルプの「日付作成、最後に更新されたプロパティ」を参照してください。

## <a name="cdaorecordsetgetdatelastupdated"></a><a name="getdatelastupdated"></a>コダレコード::ゲットデイトラスト更新

スキーマが最後に更新された日時を取得します。

```
COleDateTime GetDateLastUpdated();
```

### <a name="return-value"></a>戻り値

ベース テーブル構造 (スキーマ) が最後に更新された日付と時刻を含む[COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md)オブジェクト。

### <a name="remarks"></a>解説

日付と時刻の設定は、ベース テーブル構造 (スキーマ) が最後に更新されたコンピューターから取得されます。

関連情報については、DAO ヘルプの「日付作成、最後に更新されたプロパティ」を参照してください。

## <a name="cdaorecordsetgetdefaultdbname"></a><a name="getdefaultdbname"></a>レコードセット::デフォルトDB名

このメンバ関数を呼び出して、このレコードセットのデータベース名を調べます。

```
virtual CString GetDefaultDBName();
```

### <a name="return-value"></a>戻り値

この`CString`レコードセットの派生元のデータベースのパスと名前を含む A。

### <a name="remarks"></a>解説

レコードセットが[CDaoDatabase](../../mfc/reference/cdaodatabase-class.md)へのポインタを持たずに作成された場合、このパスはレコードセットによって既定のデータベースを開くために使用されます。 既定では、この関数は空の文字列を返します。 から新しいレコードセット`CDaoRecordset`を派生させる場合、この関数が作成されます。

次の例は、文字列が正しく解釈される際に\\\\必要な、文字列内での二重円記号 ( ) の使用を示しています。

[!code-cpp[NVC_MFCDatabase#4](../../mfc/codesnippet/cpp/cdaorecordset-class_4.cpp)]

## <a name="cdaorecordsetgetdefaultsql"></a><a name="getdefaultsql"></a>コダオレコードセット::デフォルトSQL

フレームワークは、このメンバー関数を呼び出して、レコードセットの基になる既定の SQL ステートメントを取得します。

```
virtual CString GetDefaultSQL();
```

### <a name="return-value"></a>戻り値

既定`CString`の SQL ステートメントを含む A。

### <a name="remarks"></a>解説

これは、テーブル名または SQL **SELECT**ステートメントの場合があります。

ClassWizard を使用してレコードセット クラスを宣言することで、既定の SQL ステートメントを間接的に定義すると、ClassWizard によってこのタスクが実行されます。

Null SQL 文字列を[Open](#open)に渡すと、この関数が呼び出され、レコードセットのテーブル名または SQL が決定されます。

## <a name="cdaorecordsetgeteditmode"></a><a name="geteditmode"></a>コダオレコードセット::ゲットエディットモード

編集の状態を確認するには、次のいずれかの値を指定します。

```
short GetEditMode();
```

### <a name="return-value"></a>戻り値

現在のレコードの編集状態を示す値を返します。

### <a name="remarks"></a>解説

|[値]|説明|
|-----------|-----------------|
|`dbEditNone`|編集操作は実行中ではありません。|
|`dbEditInProgress`|`Edit` が呼び出されました。|
|`dbEditAdd`|`AddNew` が呼び出されました。|

関連情報については、DAO ヘルプの「EditMode プロパティ」を参照してください。

## <a name="cdaorecordsetgetfieldcount"></a><a name="getfieldcount"></a>コダレコードセット::ゲットフィールドカウント

レコードセットで定義されているフィールド (列) の数を取得します。

```
short GetFieldCount();
```

### <a name="return-value"></a>戻り値

レコードセット内のフィールドの数。

### <a name="remarks"></a>解説

関連情報については、DAO ヘルプの「プロパティのカウント」を参照してください。

## <a name="cdaorecordsetgetfieldinfo"></a><a name="getfieldinfo"></a>コダレコード::ゲットフィールドインフォ

レコードセットのフィールドに関する情報を取得します。

```
void GetFieldInfo(
    int nIndex,
    CDaoFieldInfo& fieldinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

void GetFieldInfo(
    LPCTSTR lpszName,
    CDaoFieldInfo& fieldinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
```

### <a name="parameters"></a>パラメーター

*nIndex*<br/>
インデックスによる検索用に、レコードセットの Fields コレクション内の定義済みフィールドの 0 から始まるインデックス。

*Fieldinfo*<br/>
[構造体への](../../mfc/reference/cdaofieldinfo-structure.md)参照。

*オプション*<br/>
取得するレコードセットに関する情報を指定するオプション。 使用可能なオプションは、関数が返す原因と共にここにリストされています。 最適なパフォーマンスを得る場合は、必要なレベルの情報のみを取得します。

- `AFX_DAO_PRIMARY_INFO`(デフォルト)名前、種類、サイズ、属性

- `AFX_DAO_SECONDARY_INFO`主な情報、プラス: 順序位置、必須、長さゼロ、照合順序、外部名、ソース フィールド、ソース テーブル

- `AFX_DAO_ALL_INFO`プライマリおよびセカンダリの情報に加えて、デフォルト値、検証規則、検証テキスト

*名前を指定します。*<br/>
フィールドの名前。

### <a name="remarks"></a>解説

関数の 1 つのバージョンでは、インデックスでフィールドを検索できます。 もう 1 つのバージョンでは、フィールドを名前で検索できます。

返される情報の説明については[、CDaoFieldInfo](../../mfc/reference/cdaofieldinfo-structure.md)構造体を参照してください。 この構造体には *、dwInfoOptions*の説明に記載されている情報の項目に対応するメンバがあります。 あるレベルで情報を要求すると、以前のレベルの情報も取得できます。

関連情報については、DAO ヘルプの「属性プロパティ」を参照してください。

## <a name="cdaorecordsetgetfieldvalue"></a><a name="getfieldvalue"></a>コダレコードセット::フィールド値を取得します。

レコードセット内のデータを取得します。

```
virtual void GetFieldValue(
    LPCTSTR lpszName,
    COleVariant& varValue);

virtual void GetFieldValue(
    int nIndex,
    COleVariant& varValue);

virtual COleVariant GetFieldValue(LPCTSTR lpszName);
virtual COleVariant GetFieldValue(int nIndex);
```

### <a name="parameters"></a>パラメーター

*名前を指定します。*<br/>
フィールドの名前を含む文字列へのポインター。

*値*<br/>
フィールドの値を`COleVariant`格納するオブジェクトへの参照。

*nIndex*<br/>
インデックスによる検索用のレコードセットの Fields コレクション内のフィールドの 0 から始まるインデックス。

### <a name="return-value"></a>戻り値

`GetFieldValue`この 2 つのバージョンの値は、フィールドの値を含む[COleVariant](../../mfc/reference/colevariant-class.md)オブジェクトを返します。

### <a name="remarks"></a>解説

フィールドは、名前または序数で検索できます。

> [!NOTE]
> オブジェクトを返す`COleVariant``COleVariant`バージョンを呼び出すよりも、オブジェクト参照をパラメーターとして受け取るこのメンバー関数のバージョンのいずれかを呼び出す方が効率的です。 この関数の後者のバージョンは、下位互換性のために保持されます。

DoFieldExchange メカニズムを使用`GetFieldValue`して列を静的に連結するのではなく、実行時にフィールドを動的にバインドするには、 および[SetFieldValue](#setfieldvalue)を使用します。 [DoFieldExchange](#dofieldexchange)

`GetFieldValue`このメカニズム`DoFieldExchange`を組み合わせてパフォーマンスを向上させることができます。 たとえば、必要に`GetFieldValue`応じて必要な値を取得し、その呼び出しをインターフェイスの [詳細情報] ボタンに割り当てる場合に使用します。

関連情報については、DAO ヘルプの「フィールド オブジェクト」および「値のプロパティ」を参照してください。

## <a name="cdaorecordsetgetindexcount"></a><a name="getindexcount"></a>レコードセット::インデックスカウントを取得します。

テーブル タイプ のレコードセットで使用できるインデックスの数を調べます。

```
short GetIndexCount();
```

### <a name="return-value"></a>戻り値

テーブル タイプ のレコードセット内のインデックスの数。

### <a name="remarks"></a>解説

`GetIndexCount`は、レコードセット内のすべてのインデックスをループ処理する場合に便利です。 そのためには、 と`GetIndexCount`一緒に[使用します](#getindexinfo)。 ダイナセット タイプまたはスナップショット タイプのレコードセットでこのメンバー関数を呼び出すと、MFC は例外をスローします。

関連情報については、DAO ヘルプの「属性プロパティ」を参照してください。

## <a name="cdaorecordsetgetindexinfo"></a><a name="getindexinfo"></a>コダオレコードセット::インデックス情報を取得します。

このメンバー関数を呼び出して、基になるレコードセットのベース テーブルに定義されているインデックスに関するさまざまな種類の情報を取得します。

```
void GetIndexInfo(
    int nIndex,
    CDaoIndexInfo& indexinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

void GetIndexInfo(
    LPCTSTR lpszName,
    CDaoIndexInfo& indexinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
```

### <a name="parameters"></a>パラメーター

*nIndex*<br/>
テーブルの Indexes コレクション内の 0 から始まるインデックスで、数値位置で参照します。

*インデックス情報*<br/>
[構造体への](../../mfc/reference/cdaoindexinfo-structure.md)参照。

*オプション*<br/>
取得するインデックスに関する情報を指定するオプション。 使用可能なオプションは、関数が返す原因と共にここにリストされています。 最適なパフォーマンスを得る場合は、必要なレベルの情報のみを取得します。

- `AFX_DAO_PRIMARY_INFO`(デフォルト)名前、フィールド情報、フィールド

- `AFX_DAO_SECONDARY_INFO`プライマリ情報に加えて、プライマリ、一意、クラスタ化、無視ヌル、必須、外部

- `AFX_DAO_ALL_INFO`プライマリ情報とセカンダリ情報、および:個別のカウント

*名前を指定します。*<br/>
名前による検索用のインデックス オブジェクトの名前へのポインター。

### <a name="remarks"></a>解説

関数の 1 つのバージョンでは、コレクション内の位置でインデックスを検索できます。 もう 1 つのバージョンでは、インデックスを名前で検索できます。

返される情報の説明については[、CDaoIndexInfo](../../mfc/reference/cdaoindexinfo-structure.md)構造体を参照してください。 この構造体には *、dwInfoOptions*の説明に記載されている情報の項目に対応するメンバがあります。 あるレベルで情報を要求すると、以前のレベルの情報も取得できます。

関連情報については、DAO ヘルプの「属性プロパティ」を参照してください。

## <a name="cdaorecordsetgetlastmodifiedbookmark"></a><a name="getlastmodifiedbookmark"></a>レコードセット::ラスト修正ブックマーク

最後に追加または更新されたレコードのブックマークを取得します。

```
COleVariant GetLastModifiedBookmark();
```

### <a name="return-value"></a>戻り値

最後`COleVariant`に追加または変更されたレコードを示すブックマークを含む。

### <a name="remarks"></a>解説

レコードセット オブジェクトを作成または開くと、各レコードがサポートされている場合は、そのレコードの各レコードに既に一意のブックマークが設定されています。 レコードセットがブックマークをサポートしているかどうかを判断するために[GetBookmark](#getbookmark)を呼び出します。 レコードセットがブックマークをサポートしていない場合は、`CDaoException`がスローされます。

レコードを追加すると、レコードセットの末尾に表示され、現在のレコードではありません。 新しいレコードを現在のレコードにするには`GetLastModifiedBookmark`、呼び`SetBookmark`出しを呼び出して、新しく追加されたレコードに戻ります。

関連情報については、DAO ヘルプの「LastModified プロパティ」を参照してください。

## <a name="cdaorecordsetgetlockingmode"></a><a name="getlockingmode"></a>コダロック::ゲットロッキングモード

レコードセットに対して有効なロックの種類を調べます。

```
BOOL GetLockingMode();
```

### <a name="return-value"></a>戻り値

ロックのタイプが悲観的な場合は 0 以外、オプティミスティック・レコード・ロックの場合は 0 以外。

### <a name="remarks"></a>解説

ペシミスティック ロックが有効な場合、編集中のレコードを含むデータ ページは[、Edit](#edit)メンバー関数を呼び出すとすぐにロックされます。 [更新](#update)または[閉じる](#close)メンバー関数、または移動または検索操作のいずれかを呼び出すと、ページのロックが解除されます。

オプティミスティック・ロックが有効な場合、レコードがメンバー関数で更新されている間だけ、レコードを含`Update`むデータ・ページがロックされます。

ODBC データ ソースを操作する場合、ロック モードは常にオプティミスティックです。

関連情報については、DAO ヘルプのトピック「ロックされたプロパティ」および「マルチユーザー アプリケーションでの動作のロック」を参照してください。

## <a name="cdaorecordsetgetname"></a><a name="getname"></a>コダオレコードセット::ゲットネーム

レコードセットの名前を取得します。

```
CString GetName();
```

### <a name="return-value"></a>戻り値

レコード`CString`セットの名前を含む。

### <a name="remarks"></a>解説

レコードセットの名前は、先頭に文字を指定する必要があり、最大 40 文字を使用できます。 数字やアンダースコアの文字を含めることができますが、句読点やスペースを含めることはできません。

関連情報については、DAO ヘルプの「プロパティ名」を参照してください。

## <a name="cdaorecordsetgetparamvalue"></a><a name="getparamvalue"></a>コダレコード::ゲットパラムバリュー

基になる DAOParameter オブジェクトに格納されている指定したパラメーターの現在の値を取得します。

```
virtual COleVariant GetParamValue(int nIndex);
virtual COleVariant GetParamValue(LPCTSTR lpszName);
```

### <a name="parameters"></a>パラメーター

*nIndex*<br/>
基になる DAOParameter オブジェクト内のパラメーターの数値位置。

*名前を指定します。*<br/>
値を指定するパラメーターの名前。

### <a name="return-value"></a>戻り値

パラメーターの値を格納するクラス[のオブジェクト](../../mfc/reference/colevariant-class.md)。

### <a name="remarks"></a>解説

パラメーターには、名前またはコレクション内の数値の位置を使用してアクセスできます。

関連情報については、DAO ヘルプの「パラメータ オブジェクト」を参照してください。

## <a name="cdaorecordsetgetpercentposition"></a><a name="getpercentposition"></a>コダレコードセット::取得パーセントポジション

ダイナセット タイプまたはスナップショット タイプのレコードセットを操作しているときに、レコードセット`GetPercentPosition`を完全に設定する前に呼び出した場合、移動量は[GetRecordCount](#getrecordcount)を呼び出してアクセスされるレコードの数に対して相対的になります。

```
float GetPercentPosition();
```

### <a name="return-value"></a>戻り値

レコードセット内のレコードの割合に基づいて、レコードセット オブジェクト内の現在のレコードのおおよその位置を示す 0 ~ 100 の数値。

### <a name="remarks"></a>解説

[MoveLast](#movelast)を呼び出してすべてのレコードセットの作成を完了すると、最後のレコードに移動できますが、時間がかかる場合があります。

3 種類`GetPercentPosition`のレコードセット オブジェクト (インデックスなしのテーブルを含む) すべてを呼び出すことができます。 ただし、前方スクロールの`GetPercentPosition`みのスナップショットや、外部データベースに対するパススルー クエリから開いたレコードセットを呼び出すことはできません。 現在のレコードがない場合、または現在のレコードが削除されている場合は、`CDaoException`がスローされます。

関連情報については、DAO ヘルプのトピック「パーセント位置プロパティ」を参照してください。

## <a name="cdaorecordsetgetrecordcount"></a><a name="getrecordcount"></a>レコード数を取得します。

レコードセット内のアクセスされたレコードの数を調べるには、このメンバー関数を呼び出します。

```
long GetRecordCount();
```

### <a name="return-value"></a>戻り値

レコードセット オブジェクト内でアクセスされたレコードの数を返します。

### <a name="remarks"></a>解説

`GetRecordCount`は、すべてのレコードがアクセスされるまで、ダイナセット タイプまたはスナップショット タイプのレコードセットに含まれるレコードの数を示しません。 このメンバー関数呼び出しは、完了するまでにかなりの時間がかかる場合があります。

最後のレコードにアクセスすると、レコードセット内の削除されていないレコードの合計数が戻り値に示されます。 最後のレコードにアクセスするには、レコードセットの`MoveLast`or`FindLast`メンバー関数を呼び出します。 SQL カウントを使用して、クエリが返すレコードの概数を決定することもできます。

アプリケーションがダイナセット タイプのレコードセット内のレコードを削除すると、戻り`GetRecordCount`値が減少します。 ただし、他のユーザーによって削除されたレコードは、現在`GetRecordCount`のレコードが削除されたレコードに位置付けされるまで、そのレコードは反映されません。 レコード数に影響を与えるトランザクションを実行し、その後トランザクションをロールバック`GetRecordCount`すると、残りのレコードの実際の数は反映されません。

スナップショット タイプ`GetRecordCount`のレコードセットからの値は、基になるテーブルの変更の影響を受けません。

テーブル タイプ`GetRecordCount`のレコードセットの値は、テーブル内のレコードの概数を反映し、テーブル レコードが追加および削除されるとすぐに影響を受けます。

レコードのないレコードセットは、0 の値を返します。 アタッチされたテーブルまたは ODBC データベースを`GetRecordCount`操作する場合は、常に 1 を返します。 レコードセット`Requery`でメンバー関数を呼び出すと、クエリ`GetRecordCount`が再実行された場合と同じように値がリセットされます。

関連情報については、DAO ヘルプの「レコード数プロパティ」を参照してください。

## <a name="cdaorecordsetgetsql"></a><a name="getsql"></a>コダオレコードセット::ゲットSQL

レコードセットを開いたときにレコードセットのレコードを選択するために使用された SQL ステートメントを取得します。

```
CString GetSQL() const;
```

### <a name="return-value"></a>戻り値

SQL`CString`ステートメントを含む。

### <a name="remarks"></a>解説

これは通常、SQL **SELECT**ステートメントになります。

返される`GetSQL`文字列は、通常、open[メンバー関数](#open)に*lpszSQL*パラメーターのレコードセットに渡した文字列とは異なります。 これは、レコードセットが、渡した内容、ClassWizard で指定した内容`Open`、および[m_strFilter](#m_strfilter)および[m_strSort](#m_strsort)データ メンバーで指定した内容に基づいて、完全な SQL ステートメントを作成するためです。

> [!NOTE]
> このメンバー関数は、 を`Open`呼び出した後にのみ呼び出されます。

関連情報については、DAO ヘルプの「SQL プロパティ」を参照してください。

## <a name="cdaorecordsetgettype"></a><a name="gettype"></a>コダレコード::ゲットタイプ

レコードセットを開いた後、このメンバー関数を呼び出して、レコードセット オブジェクトの種類を確認します。

```
short GetType();
```

### <a name="return-value"></a>戻り値

レコードセットの種類を示す次のいずれかの値。

- `dbOpenTable`テーブル タイプ のレコードセット

- `dbOpenDynaset`ダイナセットタイプのレコードセット

- `dbOpenSnapshot`スナップショット タイプのレコードセット

### <a name="remarks"></a>解説

関連情報については、DAO ヘルプの「型プロパティ」を参照してください。

## <a name="cdaorecordsetgetvalidationrule"></a><a name="getvalidationrule"></a>コダオレコードセット::検証ルールを取得します。

データの検証に使用する規則を決定します。

```
CString GetValidationRule();
```

### <a name="return-value"></a>戻り値

レコード`CString`内のデータが変更またはテーブルに追加される場合に、データを検証する値を含むオブジェクト。

### <a name="remarks"></a>解説

このルールはテキストベースで、基になるテーブルが変更されるたびに適用されます。 データが有効でない場合、MFC は例外をスローします。 返されるエラー メッセージは、基になるフィールド オブジェクトの ValidationText プロパティのテキスト (指定されている場合) または基になるフィールド オブジェクトの ValidationRule プロパティで指定された式のテキストです。 エラー メッセージのテキストを取得するのには[、GetValidationText](#getvalidationtext)を呼び出すことができます。

たとえば、月の日を必要とするレコードのフィールドには、"DAY BETWEEN 1 と 31" などの入力規則が含まれている場合があります。

関連情報については、DAO ヘルプの「検証ルールプロパティ」を参照してください。

## <a name="cdaorecordsetgetvalidationtext"></a><a name="getvalidationtext"></a>コダオレコードセット::テキストを取得します。

基になるフィールド オブジェクトの ValidationText プロパティのテキストを取得します。

```
CString GetValidationText();
```

### <a name="return-value"></a>戻り値

`CString`フィールドの値が基になるフィールド オブジェクトの入力規則を満たしていない場合に表示されるメッセージのテキストを含むオブジェクト。

### <a name="remarks"></a>解説

関連情報については、DAO ヘルプの「検証テキスト プロパティ」を参照してください。

## <a name="cdaorecordsetisbof"></a><a name="isbof"></a>コダオレコード::イズボフ

レコードからレコードへスクロールする前に、このメンバー関数を呼び出して、レコードセットの最初のレコードより前に移動したかどうかを確認します。

```
BOOL IsBOF() const;
```

### <a name="return-value"></a>戻り値

レコードセットにレコードが含まれなかったり、最初のレコードの前にスクロールした場合は 0 以外の値を返します。それ以外の場合は 0。

### <a name="remarks"></a>解説

レコード`IsBOF`セット`IsEOF`にレコードが含まれているか、空かを調べることもできます。 を呼び出`Open`した直後に、レコードセットにレコード`IsBOF`が含まれている場合は、0 以外の値が返されます。 レコードが少なくとも 1 つあるレコードを開くと、最初のレコードはカレント`IsBOF`レコードになり、0 を返します。

最初のレコードが現在のレコードで、 を`MovePrev``IsBOF`呼び出すと、その後に 0 以外の値が返されます。 0`IsBOF`以外を返し、`MovePrev`を呼び出すと、例外がスローされます。 0`IsBOF`以外の値を返すと、現在のレコードは未定義になり、現在のレコードを必要とするアクションは例外になります。

特定のメソッドが設定`IsBOF`に`IsEOF`及ぼす影響:

- 内部`Open*`呼び出しでは、 を呼び出`MoveFirst`すことによって、レコードセットの最初のレコードが現在のレコードになります。 したがって、空`Open`のレコードセットを呼び出`IsBOF`すと`IsEOF`、0 以外の値が返されます。 (失敗`MoveFirst`または`MoveLast`呼び出しの動作については、次の表を参照してください)。

- レコードを正常に検索したすべての Move 操作は`IsBOF`、`IsEOF`両方の原因と 0 を返します。

- 呼`AddNew`び出しの`Update`後に新しいレコードを正常に挿入する呼`IsBOF`び出しを行うと、0 が返されますが、この値は既に 0 以外の場合`IsEOF`に限られます。 の`IsEOF`状態は常に変更されません。 Microsoft Jet データベース エンジンで定義されているように、空のレコードセットのカレント レコード ポインタはファイルの末尾にあるため、新しいレコードはカレント レコードの後に挿入されます。

- レコード`Delete`セットから残っているレコードだけを削除しても、 or`IsBOF``IsEOF`の値は変更されません。

この表は、 の組み合わせによって許可される`IsBOF`/ `IsEOF`移動操作を示しています。

||最初に移動,最後に移動|ムーブプレフ,<br /><br /> < 0 を移動する|0 を移動する|Movenext<br /><br /> > 0 を移動する|
|------|-------------------------|-----------------------------|------------|-----------------------------|
|`IsBOF`=ゼロ以外、<br /><br /> `IsEOF`=0|許可|例外|例外|許可|
|`IsBOF`=0,<br /><br /> `IsEOF`=ゼロ以外|許可|許可|例外|例外|
|両方とも 0 以外|例外|例外|例外|例外|
|両方とも 0|許可|許可|許可|許可|

移動操作を許可しても、操作がレコードを正常に見つけるという意味ではありません。 指定した移動操作の実行が許可され、例外が生成されないことを示しているだけです。 `IsBOF`および`IsEOF`メンバー関数の値は、移動の試行の結果として変更される場合があります。

次の表に、レコードが検索されない移動操作の影響`IsBOF`と`IsEOF`設定の値を示します。

||Isbof|Iseof|
|------|-----------|-----------|
|`MoveFirst`, `MoveLast`|ゼロ以外|ゼロ以外|
|`Move` 0|変更なし|変更なし|
|`MovePrev`、< `Move` 0|ゼロ以外|変更なし|
|`MoveNext`、> `Move` 0|変更なし|ゼロ以外|

関連情報については、DAO ヘルプのトピック「BOF、EOF のプロパティ」を参照してください。

## <a name="cdaorecordsetisdeleted"></a><a name="isdeleted"></a>コダオレコードセット::削除

現在のレコードが削除されたかどうかを調べます。

```
BOOL IsDeleted() const;
```

### <a name="return-value"></a>戻り値

レコードセットが削除されたレコードに配置されている場合は 0 以外の値を返します。それ以外の場合は 0。

### <a name="remarks"></a>解説

レコードまでスクロールして`IsDeleted`TRUE (ゼロ以外) を返す場合は、他のレコードセット操作を実行する前に別のレコードまでスクロールする必要があります。

> [!NOTE]
> スナップショットまたはテーブル タイプのレコードセットのレコードの削除済み状態を確認する必要はありません。 レコードはスナップショットから削除できないため、 を呼び出す`IsDeleted`必要はありません。 テーブル タイプのレコードセットの場合、削除されたレコードは実際にはレコードセットから削除されます。 レコードが削除された場合は、ユーザー、別のユーザー、または別のレコードセットから削除された後は、そのレコードにスクロールして戻ることはできません。 したがって、 を呼び出す`IsDeleted`必要はありません。

ダイナセットからレコードを削除すると、レコードセットからレコードが削除され、そのレコードにスクロールして戻ることはできません。 ただし、ダイナセット内のレコードが、別のユーザーまたは同じテーブルに基づく別のレコードセットから削除された`IsDeleted`場合、後でそのレコードにスクロールすると TRUE が返されます。

関連情報については、DAO ヘルプの「メソッドの削除」、「LastModified プロパティ」、および「EditMode プロパティ」のトピックを参照してください。

## <a name="cdaorecordsetiseof"></a><a name="iseof"></a>コダオレコード::イセフ

レコードからレコードへスクロールして、レコードセットの最後のレコードを超えたかどうかを確認するときに、このメンバー関数を呼び出します。

```
BOOL IsEOF() const;
```

### <a name="return-value"></a>戻り値

レコードセットにレコードが含まれなかったり、最後のレコードを越えてスクロールした場合は 0 以外の値を返します。それ以外の場合は 0。

### <a name="remarks"></a>解説

レコードセットにレコード`IsEOF`が含まれているか、空かを調べることもできます。 を呼び出`Open`した直後に、レコードセットにレコード`IsEOF`が含まれている場合は、0 以外の値が返されます。 レコードが少なくとも 1 つあるレコードを開くと、最初のレコードはカレント`IsEOF`レコードになり、0 を返します。

最後のレコードが 呼`MoveNext``IsEOF`び出すときに現在のレコードの場合は、その後 0 以外の値が返されます。 0`IsEOF`以外を返し、`MoveNext`を呼び出すと、例外がスローされます。 0`IsEOF`以外の値を返すと、現在のレコードは未定義になり、現在のレコードを必要とするアクションは例外になります。

特定のメソッドが設定`IsBOF`に`IsEOF`及ぼす影響:

- 内部`Open`呼び出しでは、 を呼び出`MoveFirst`すことによって、レコードセットの最初のレコードが現在のレコードになります。 したがって、空`Open`のレコードセットを呼び出`IsBOF`すと`IsEOF`、0 以外の値が返されます。 (失敗した`MoveFirst`呼び出しの動作については、次の表を参照してください)。

- レコードを正常に検索したすべての Move 操作は`IsBOF`、`IsEOF`両方の原因と 0 を返します。

- 呼`AddNew`び出しの`Update`後に新しいレコードを正常に挿入する呼`IsBOF`び出しを行うと、0 が返されますが、この値は既に 0 以外の場合`IsEOF`に限られます。 の`IsEOF`状態は常に変更されません。 Microsoft Jet データベース エンジンで定義されているように、空のレコードセットのカレント レコード ポインタはファイルの末尾にあるため、新しいレコードはカレント レコードの後に挿入されます。

- レコード`Delete`セットから残っているレコードだけを削除しても、 or`IsBOF``IsEOF`の値は変更されません。

この表は、 の組み合わせによって許可される`IsBOF`/ `IsEOF`移動操作を示しています。

||最初に移動,最後に移動|ムーブプレフ,<br /><br /> < 0 を移動する|0 を移動する|Movenext<br /><br /> > 0 を移動する|
|------|-------------------------|-----------------------------|------------|-----------------------------|
|`IsBOF`=ゼロ以外、<br /><br /> `IsEOF`=0|許可|例外|例外|許可|
|`IsBOF`=0,<br /><br /> `IsEOF`=ゼロ以外|許可|許可|例外|例外|
|両方とも 0 以外|例外|例外|例外|例外|
|両方とも 0|許可|許可|許可|許可|

移動操作を許可しても、操作がレコードを正常に見つけるという意味ではありません。 指定した移動操作の実行が許可され、例外が生成されないことを示しているだけです。 `IsBOF`および`IsEOF`メンバー関数の値は、移動の試行の結果として変更される場合があります。

次の表に、レコードが検索されない移動操作の影響`IsBOF`と`IsEOF`設定の値を示します。

||Isbof|Iseof|
|------|-----------|-----------|
|`MoveFirst`, `MoveLast`|ゼロ以外|ゼロ以外|
|`Move` 0|変更なし|変更なし|
|`MovePrev`、< `Move` 0|ゼロ以外|変更なし|
|`MoveNext`、> `Move` 0|変更なし|ゼロ以外|

関連情報については、DAO ヘルプのトピック「BOF、EOF のプロパティ」を参照してください。

## <a name="cdaorecordsetisfielddirty"></a><a name="isfielddirty"></a>コダレコード::イズフィールドダーティ

ダイナセットの指定されたフィールド データ メンバーに "ダーティ" (変更) のフラグが設定されているかどうかを調べます。

```
BOOL IsFieldDirty(void* pv);
```

### <a name="parameters"></a>パラメーター

*pv*<br/>
状態をチェックするフィールド データ メンバーへのポインター。またはいずれかのフィールドがダーティかどうかを判断する場合は NULL。

### <a name="return-value"></a>戻り値

指定されたフィールド データ メンバーがダーティとしてフラグが設定されている場合は 0 以外の値を返します。それ以外の場合は 0。

### <a name="remarks"></a>解説

すべてのダーティ フィールド データ メンバーのデータ`Update`は、(または`CDaoRecordset``Edit``AddNew`への呼び出し後) のメンバー関数の呼び出しによって現在のレコードが更新されると、データ ソースのレコードに転送されます。 この知識を使用すると、フィールド データ メンバーのフラグを解除して列にマークを付け、データ ソースに書き込まれないようにするなど、さらに手順を実行できます。

`IsFieldDirty`を通じて`DoFieldExchange`実装されます。

## <a name="cdaorecordsetisfieldnull"></a><a name="isfieldnull"></a>コダレコードセット::イズフィールドヌル

レコードセットの指定されたフィールド データ メンバーに Null のフラグが設定されているかどうかを調べます。

```
BOOL IsFieldNull(void* pv);
```

### <a name="parameters"></a>パラメーター

*pv*<br/>
状態を確認するフィールド データ メンバーへのポインター、または NULL を指定してフィールドのいずれかが Null かどうかを判断します。

### <a name="return-value"></a>戻り値

指定されたフィールド データ メンバーに Null のフラグが設定されている場合は 0 以外の値を返します。それ以外の場合は 0。

### <a name="remarks"></a>解説

(データベース用語では、Null は "値を持たない" ことを意味し、C++ では NULL と同じではありません。フィールド データ メンバーに Null というフラグが設定されている場合、そのフィールド データ メンバーは、値がない現在のレコードの列として解釈されます。

> [!NOTE]
> 次のコード例に`IsFieldNull`示すように、特定の状況では、使用が非効率的になる場合があります。

[!code-cpp[NVC_MFCDatabase#5](../../mfc/codesnippet/cpp/cdaorecordset-class_5.cpp)]

> [!NOTE]
> 動的レコード・バインディングを使用している場合は、 から`CDaoRecordset`派生しない場合は、例に示すように必ず VT_NULL を使用してください。

## <a name="cdaorecordsetisfieldnullable"></a><a name="isfieldnullable"></a>コダオレコードセット::イズフィールドNull可能

指定したフィールド データ メンバーが "null 許容" であるかどうかを調べます ( Null 値に設定できます。C++ NULL は NULL と同じではありません。

```
BOOL IsFieldNullable(void* pv);
```

### <a name="parameters"></a>パラメーター

*pv*<br/>
状態を確認するフィールド データ メンバーへのポインター、または NULL を指定してフィールドのいずれかが Null かどうかを判断します。

### <a name="return-value"></a>戻り値

指定されたフィールド データ メンバーを Null にできる場合は 0 以外の値を返します。それ以外の場合は 0。

### <a name="remarks"></a>解説

Null にできないフィールドには値が必要です。 レコードの追加または更新時にこのようなフィールドを Null に設定しようとすると、データ ソースはその追加または更新を拒否し`Update`、例外をスローします。 例外は、 を呼び`Update`出すときではなく、`SetFieldNull`を呼び出すときに発生します。

## <a name="cdaorecordsetisopen"></a><a name="isopen"></a>コダレコード::IsOpen

レコードセットが開いているかどうかを調べます。

```
BOOL IsOpen() const;
```

### <a name="return-value"></a>戻り値

レコードセット オブジェクト`Open`または`Requery`メンバ関数が以前に呼び出され、レコードセットが閉じられていない場合は 0 以外の値を返します。それ以外の場合は 0。

### <a name="remarks"></a>解説

## <a name="cdaorecordsetm_bcheckcachefordirtyfields"></a><a name="m_bcheckcachefordirtyfields"></a>セオレコード::m_bCheckCacheForDirtyFields

キャッシュされたフィールドが自動的にダーティ (変更) および Null としてマークされるかどうかを示すフラグを含みます。

### <a name="remarks"></a>解説

フラグは、デフォルトで TRUE です。 このデータ メンバーの設定は、ダブル バッファリング機構全体を制御します。 フラグを TRUE に設定すると、DFX メカニズムを使用してフィールド単位でキャッシュをオフにすることができます。 フラグを FALSE に設定した場合は、`SetFieldDirty`自分自身`SetFieldNull`を呼び出す必要があります。

を呼び出す`Open`前に、このデータ メンバを設定します。 このメカニズムは、主に使いやすさを目的とします。 変更が行われるとフィールドがダブル バッファリングされるため、パフォーマンスが低下する場合があります。

## <a name="cdaorecordsetm_nfields"></a><a name="m_nfields"></a>コダオレコード::m_nFields

レコードセット クラスのフィールド データ メンバの数と、データ ソースからレコードセットによって選択された列数を格納します。

### <a name="remarks"></a>解説

レコードセット クラスのコンストラクターは、`m_nFields`正しい数の静的にバインドされたフィールドで初期化する必要があります。 ClassWizard を使用してレコードセット クラスを宣言すると、この初期化が書き込まれます。 手動で書き込む方法もあります。

フレームワークは、この数を使用して、フィールド データ メンバーと、データ ソース上の現在のレコードの対応する列との間の相互作用を管理します。

> [!NOTE]
> この番号は、 パラメーター`DoFieldExchange``SetFieldType``CDaoFieldExchange::outputColumn`を使用して に呼び出した後に登録された出力列の数に対応する必要があります。

列は、`CDaoRecordset::GetFieldValue`および`CDaoRecordset::SetFieldValue`を使用して動的にバインドできます。 この場合、`m_nFields``DoFieldExchange`メンバー関数の DFX 関数呼び出しの数を反映するために、カウントをインクリメントする必要はありません。

## <a name="cdaorecordsetm_nparams"></a><a name="m_nparams"></a>コダオレコード::m_nParams

レコードセット クラス内のパラメータ データ メンバの数(レコードセットのクエリで渡されるパラメータの数)を格納します。

### <a name="remarks"></a>解説

レコードセット クラスにパラメータ データ メンバーがある場合、クラスのコンストラクターは *、m_nParams*正しい数値で初期化する必要があります。 *m_nParams*の値は、デフォルトで 0 になります。 パラメーター データ メンバーを追加する場合 (手動で行う必要があります) は、クラス コンストラクターに初期化を手動で追加して、パラメーターの数を反映する必要もあります (m_strFilterまたは*m_strSort*文字列のプレースホルダ*m_strFilter*の数と同じ大きさである必要があります)。

フレームワークは、レコードセットのクエリをパラメーター化するときにこの数値を使用します。

> [!NOTE]
> この番号は、 パラメーター`DoFieldExchange``SetFieldType``CFieldExchange::param`を使用して 呼び出し後に登録された 「params」 の数に対応する必要があります。

関連情報については、DAO ヘルプの「パラメータ オブジェクト」を参照してください。

## <a name="cdaorecordsetm_pdaorecordset"></a><a name="m_pdaorecordset"></a>コダオレコード::m_pDAORecordset

オブジェクトの基になる DAO レコードセット オブジェクトの OLE`CDaoRecordset`インターフェイスへのポインターを格納します。

### <a name="remarks"></a>解説

DAO インターフェイスに直接アクセスする必要がある場合は、このポインターを使用します。

関連情報については、DAO ヘルプの「レコード セット オブジェクト」を参照してください。

## <a name="cdaorecordsetm_pdatabase"></a><a name="m_pdatabase"></a>コダオレコード::m_pDatabase

レコードセットが`CDaoDatabase`データ ソースに接続されているオブジェクトへのポインターを格納します。

### <a name="remarks"></a>解説

この変数は、2 つの方法で設定されます。 通常、レコードセット オブジェクトを構築するときに、`CDaoDatabase`既に開いているオブジェクトへのポインターを渡します。 代わりに NULL を`CDaoRecordset`渡すと`CDaoDatabase`、オブジェクトが作成され、開かれます。 いずれの場合も、`CDaoRecordset`この変数にポインターを格納します。

通常は、 に格納されているポインターを直接使用する必要`m_pDatabase`はありません。 ただし、 に独自の拡張機能`CDaoRecordset`を記述する場合は、ポインターを使用する必要があります。 たとえば、独自`CDaoException`のポインタを投げる場合にポインタが必要になることがあります。

関連情報については、DAO ヘルプの「データベース オブジェクト」を参照してください。

## <a name="cdaorecordsetm_strfilter"></a><a name="m_strfilter"></a>コダオレコード::m_strFilter

SQL ステートメントの**WHERE**句を作成するために使用する文字列を格納します。

### <a name="remarks"></a>解説

レコードセットをフィルタ処理するための予約語**WHERE**は含まれません。 このデータ メンバの使用は、テーブル タイプのレコードセットには適用されません。 を使用しても`m_strFilter`、ポインターを使用してレコードセットを開`CDaoQueryDef`くときには効果がありません。

日付を含むフィールドをフィルタする場合は、米国版の Microsoft Jet データベース エンジンを使用していない場合でも、米国日付形式 (月- 日- 年) を使用します。それ以外の場合、データは期待どおりにフィルター処理されない可能性があります。

関連情報については、DAO ヘルプの「プロパティのフィルタ」を参照してください。

## <a name="cdaorecordsetm_strsort"></a><a name="m_strsort"></a>コダオレコード::m_strSort

予約語を使用せずに、SQL ステートメントの**ORDERBY**句を**ORDERBY**含む文字列を含みます。

### <a name="remarks"></a>解説

ダイナセット タイプおよびスナップショット タイプのレコードセット オブジェクトを並べ替えることができます。

テーブル タイプのレコードセット オブジェクトは並べ替えられません。 テーブル タイプのレコードセットの並べ替え順序を確認するには[、SetCurrentIndex](#setcurrentindex)を呼び出します。

*m_strSort*を使用しても、ポインターを使用してレコードセットを開`CDaoQueryDef`くときには効果がありません。

関連情報については、DAO ヘルプの「プロパティの並べ替え」を参照してください。

## <a name="cdaorecordsetmove"></a><a name="move"></a>コダオレコード::移動

現在のレコードからレコードセット*lRows*レコードを配置するには、このメンバー関数を呼び出します。

```
virtual void Move(long lRows);
```

### <a name="parameters"></a>パラメーター

*lRows*<br/>
前方または後方に移動するレコードの数。 正の値は、レコードセットの末尾に向かって前方に移動します。 負の値は、先頭に向かって後方に移動します。

### <a name="remarks"></a>解説

前後に移動できます。 `Move( 1 )`は`MoveNext`と同等で`Move( -1 )`、 と`MovePrev`同等です。

> [!CAUTION]
> レコードセットに`Move`レコードがない場合、関数を呼び出すと例外がスローされます。 一般に、Move `IsBOF` `IsEOF`操作の前と両方を呼び出して、レコードセットにレコードがあるかどうかを確認します。 または`Open``Requery`を呼び出した`IsBOF`後`IsEOF`、 または を呼び出します。

> [!NOTE]
> レコードセットの先頭または末尾を越えてスクロールした場合 (`IsBOF`または`IsEOF`0 以外を返す`Move`)、呼`CDaoException`び出しは .

> [!NOTE]
> 現在のレコードの`Move`更新または追加中にいずれかの関数を呼び出すと、警告なしに更新が失われます。

前方スクロールの`Move`みのスナップショットを呼び出すときは *、lRows*パラメーターは正の整数である必要があり、ブックマークは許可されないので、前方に進むことだけが可能です。

レコードセットの最初、最後、次、または前のレコードをカレント レコードにするには、 `MoveFirst`、、`MoveLast`または`MoveNext`、、または`MovePrev`、メンバ関数を呼び出します。

関連情報については、DAO ヘルプの「移動メソッド」および「最初に移動、最後に移動、次に移動、前のメソッドを移動する」を参照してください。

## <a name="cdaorecordsetmovefirst"></a><a name="movefirst"></a>コダレコード::ムーブファースト

レコードセット内の最初のレコード (存在する場合) をカレント レコードにする場合は、このメンバー関数を呼び出します。

```
void MoveFirst();
```

### <a name="remarks"></a>解説

レコードセットを開いた直後`MoveFirst`に呼び出す必要はありません。 その時点で、最初のレコード (存在する場合) は自動的に現在のレコードになります。

> [!CAUTION]
> レコードセットに`Move`レコードがない場合、関数を呼び出すと例外がスローされます。 一般に、Move `IsBOF` `IsEOF`操作の前と両方を呼び出して、レコードセットにレコードがあるかどうかを確認します。 または`Open``Requery`を呼び出した`IsBOF`後`IsEOF`、 または を呼び出します。

> [!NOTE]
> 現在のレコードの`Move`更新または追加中にいずれかの関数を呼び出すと、警告なしに更新が失われます。

条件を`Move`適用せずにレコード間を移動するには、関数を使用します。 検索操作を使用して、特定の条件を満たすダイナセット タイプまたはスナップショット タイプのレコードセット オブジェクト内のレコードを検索します。 テーブル タイプのレコードセット オブジェクト内のレコードを検索`Seek`するには、 を呼び出します。

レコードセットがテーブル タイプのレコードセットを参照している場合、移動はテーブルの現在のインデックスに従います。 現在のインデックスを設定する場合は、基になる DAO オブジェクトの Index プロパティを使用します。 現在のインデックスを設定しない場合、返されるレコードの順序は未定義になります。

SQL クエリ`MoveLast`またはクエリ定義に基づいてレコードセット オブジェクトを呼び出すと、クエリは強制的に完了し、レコードセット オブジェクトは完全に設定されます。

前方スクロール専用スナップショット`MoveFirst`を`MovePrev`使用して、 または メンバー関数を呼び出すことはできません。

レコードセット オブジェクト内の現在のレコードの位置を、特定のレコード数だけ前後に移動するには`Move`、 を呼び出します。

関連情報については、DAO ヘルプの「移動メソッド」および「最初に移動、最後に移動、次に移動、前のメソッドを移動する」を参照してください。

## <a name="cdaorecordsetmovelast"></a><a name="movelast"></a>コダレコード::移動ラスト

レコードセットの最後のレコード (存在する場合) をカレント レコードにする場合は、このメンバー関数を呼び出します。

```
void MoveLast();
```

### <a name="remarks"></a>解説

> [!CAUTION]
> レコードセットに`Move`レコードがない場合、関数を呼び出すと例外がスローされます。 一般に、Move `IsBOF` `IsEOF`操作の前と両方を呼び出して、レコードセットにレコードがあるかどうかを確認します。 または`Open``Requery`を呼び出した`IsBOF`後`IsEOF`、 または を呼び出します。

> [!NOTE]
> 現在のレコードの`Move`更新または追加中にいずれかの関数を呼び出すと、警告なしに更新が失われます。

条件を`Move`適用せずにレコード間を移動するには、関数を使用します。 検索操作を使用して、特定の条件を満たすダイナセット タイプまたはスナップショット タイプのレコードセット オブジェクト内のレコードを検索します。 テーブル タイプのレコードセット オブジェクト内のレコードを検索`Seek`するには、 を呼び出します。

レコードセットがテーブル タイプのレコードセットを参照している場合、移動はテーブルの現在のインデックスに従います。 現在のインデックスを設定する場合は、基になる DAO オブジェクトの Index プロパティを使用します。 現在のインデックスを設定しない場合、返されるレコードの順序は未定義になります。

SQL クエリ`MoveLast`またはクエリ定義に基づいてレコードセット オブジェクトを呼び出すと、クエリは強制的に完了し、レコードセット オブジェクトは完全に設定されます。

レコードセット オブジェクト内の現在のレコードの位置を、特定のレコード数だけ前後に移動するには`Move`、 を呼び出します。

関連情報については、DAO ヘルプの「移動メソッド」および「最初に移動、最後に移動、次に移動、前のメソッドを移動する」を参照してください。

## <a name="cdaorecordsetmovenext"></a><a name="movenext"></a>コダオレコードセット::次に移動

レコードセットの次のレコードをカレント レコードにする場合は、このメンバー関数を呼び出します。

```
void MoveNext();
```

### <a name="remarks"></a>解説

前のレコードに移動する`IsBOF`前に電話することをお勧めします。 呼`MovePrev`び出しは、if`IsBOF`が 0 以外の値を`CDaoException`スローし、最初のレコードの前に既にスクロールしたか、レコードセットによって選択されていないレコードを示します。

> [!CAUTION]
> レコードセットに`Move`レコードがない場合、関数を呼び出すと例外がスローされます。 一般に、Move `IsBOF` `IsEOF`操作の前と両方を呼び出して、レコードセットにレコードがあるかどうかを確認します。 または`Open``Requery`を呼び出した`IsBOF`後`IsEOF`、 または を呼び出します。

> [!NOTE]
> 現在のレコードの`Move`更新または追加中にいずれかの関数を呼び出すと、警告なしに更新が失われます。

条件を`Move`適用せずにレコード間を移動するには、関数を使用します。 検索操作を使用して、特定の条件を満たすダイナセット タイプまたはスナップショット タイプのレコードセット オブジェクト内のレコードを検索します。 テーブル タイプのレコードセット オブジェクト内のレコードを検索`Seek`するには、 を呼び出します。

レコードセットがテーブル タイプのレコードセットを参照している場合、移動はテーブルの現在のインデックスに従います。 現在のインデックスを設定する場合は、基になる DAO オブジェクトの Index プロパティを使用します。 現在のインデックスを設定しない場合、返されるレコードの順序は未定義になります。

レコードセット オブジェクト内の現在のレコードの位置を、特定のレコード数だけ前後に移動するには`Move`、 を呼び出します。

関連情報については、DAO ヘルプの「移動メソッド」および「最初に移動、最後に移動、次に移動、前のメソッドを移動する」を参照してください。

## <a name="cdaorecordsetmoveprev"></a><a name="moveprev"></a>コダレコード::ムーブプレフ

レコードセットの前のレコードをカレント レコードにする場合は、このメンバー関数を呼び出します。

```
void MovePrev();
```

### <a name="remarks"></a>解説

前のレコードに移動する`IsBOF`前に電話することをお勧めします。 呼`MovePrev`び出しは、if`IsBOF`が 0 以外の値を`CDaoException`スローし、最初のレコードの前に既にスクロールしたか、レコードセットによって選択されていないレコードを示します。

> [!CAUTION]
> レコードセットに`Move`レコードがない場合、関数を呼び出すと例外がスローされます。 一般に、Move `IsBOF` `IsEOF`操作の前と両方を呼び出して、レコードセットにレコードがあるかどうかを確認します。 または`Open``Requery`を呼び出した`IsBOF`後`IsEOF`、 または を呼び出します。

> [!NOTE]
> 現在のレコードの`Move`更新または追加中にいずれかの関数を呼び出すと、警告なしに更新が失われます。

条件を`Move`適用せずにレコード間を移動するには、関数を使用します。 検索操作を使用して、特定の条件を満たすダイナセット タイプまたはスナップショット タイプのレコードセット オブジェクト内のレコードを検索します。 テーブル タイプのレコードセット オブジェクト内のレコードを検索`Seek`するには、 を呼び出します。

レコードセットがテーブル タイプのレコードセットを参照している場合、移動はテーブルの現在のインデックスに従います。 現在のインデックスを設定する場合は、基になる DAO オブジェクトの Index プロパティを使用します。 現在のインデックスを設定しない場合、返されるレコードの順序は未定義になります。

前方スクロール専用スナップショット`MoveFirst`を`MovePrev`使用して、 または メンバー関数を呼び出すことはできません。

レコードセット オブジェクト内の現在のレコードの位置を、特定のレコード数だけ前後に移動するには`Move`、 を呼び出します。

関連情報については、DAO ヘルプの「移動メソッド」および「最初に移動、最後に移動、次に移動、前のメソッドを移動する」を参照してください。

## <a name="cdaorecordsetopen"></a><a name="open"></a>セオレコード::オープン

レコードセットのレコードを取得するには、このメンバー関数を呼び出す必要があります。

```
virtual void Open(
    int nOpenType = AFX_DAO_USE_DEFAULT_TYPE,
    LPCTSTR lpszSQL = NULL,
    int nOptions = 0);

virtual void Open(
    CDaoTableDef* pTableDef,
    int nOpenType = dbOpenTable,
    int nOptions = 0);

virtual void Open(
    CDaoQueryDef* pQueryDef,
    int nOpenType = dbOpenDynaset,
    int nOptions = 0);
```

### <a name="parameters"></a>パラメーター

*n開くタイプ*<br/>
次のいずれかの値:

- `dbOpenDynaset`双方向スクロールを伴うダイナセット タイプのレコードセット。 これは既定値です。

- `dbOpenTable`双方向スクロールを含むテーブル タイプのレコードセット。

- `dbOpenSnapshot`双方向スクロールを伴うスナップショット タイプのレコードセット。

*Lpszsql*<br/>
次のいずれかを含む文字列ポインター:

- NULL ポインター。

- 1 つ以上のテーブル定義またはクエリ定義 (コンマ区切り) の名前。

- SQL **SELECT**ステートメント (オプションで SQL **WHERE**句または**ORDERBY**句を使用)。

- パススルー クエリ。

*nオプション*<br/>
以下に示すオプションの 1 つ以上。 既定値は 0 です。 使用できる値は次のとおりです。

- `dbAppendOnly`新しいレコードのみを追加できます (ダイナセット タイプのレコードセットのみ)。 このオプションは、文字通りレコードを追加することしかできないということを意味します。 MFC ODBC データベース クラスには、レコードを取得して追加できる追加専用オプションがあります。

- `dbForwardOnly`レコードセットは前方スクロールのみのスナップショットです。

- `dbSeeChanges`編集中のデータを別のユーザーが変更している場合は、例外を生成します。

- `dbDenyWrite`他のユーザーは、レコードの変更や追加を行うことはできません。

- `dbDenyRead`他のユーザーはレコードを表示できません (テーブル タイプのレコードセットのみ)。

- `dbReadOnly`表示できるのはレコードだけです。他のユーザーは変更できます。

- `dbInconsistent`一貫性のない更新が許可されます (ダイナセット タイプのレコードセットのみ)。

- `dbConsistent`一貫した更新のみが許可されます (ダイナセット タイプのレコードセットのみ)。

> [!NOTE]
> 定数は`dbConsistent`相互`dbInconsistent`に排他的です。 いずれか一方を使用できますが、指定したインスタンスでは両方を使用することはできません`Open`。

*をクリックします。*<br/>
[オブジェクトへの](../../mfc/reference/cdaotabledef-class.md)ポインター。 このバージョンは、テーブル タイプのレコードセットに対してのみ有効です。 このオプションを使用する場合`CDaoDatabase`、 を`CDaoRecordset`構築するために使用されるポインターは使用されません。代わりに、テーブル定義が存在するデータベースが使用されます。

*を使用します。*<br/>
[オブジェクトへの](../../mfc/reference/cdaoquerydef-class.md)ポインター。 このバージョンは、ダイナセット タイプおよびスナップショット タイプのレコードセットに対してのみ有効です。 このオプションを使用する場合`CDaoDatabase`、 を`CDaoRecordset`構築するために使用されるポインターは使用されません。代わりに、クエリ定義が存在するデータベースが使用されます。

### <a name="remarks"></a>解説

を呼`Open`び出す前に、レコードセット オブジェクトを作成する必要があります。 これにはいくつかの方法があります。

- レコードセット オブジェクトを構築する場合は、既に`CDaoDatabase`開いているオブジェクトへのポインターを渡します。

- レコードセット オブジェクトを構築するときに、開いていないオブジェクトへの`CDaoDatabase`ポインターを渡します。 レコードセットはオブジェクト`CDaoDatabase`を開きますが、レコードセット オブジェクトが閉じるときには閉じられません。

- レコードセット オブジェクトを構築する場合は、NULL ポインターを渡します。 レコードセット オブジェクト`GetDefaultDBName`は、Access の名前を取得するために呼び出します。開く MDB ファイル。 次に、レコードセット`CDaoDatabase`はオブジェクトを開き、レコードセットが開いている間は開いたままにします。 レコードセットを`Close`呼び出すと、`CDaoDatabase`オブジェクトも閉じられます。

    > [!NOTE]
    >  レコードセットがオブジェクトを`CDaoDatabase`開くと、データ ソースが排他アクセスで開かれます。

`Open` *lpszSQL*パラメータを使用するバージョンでは、レコードセットが開いたら、いくつかの方法のいずれかでレコードを取得できます。 最初のオプションは、DFX 関数を使用`DoFieldExchange`することです。 2 番目のオプションは、メンバー関数を呼`GetFieldValue`び出して動的バインディングを使用することです。 これらのオプションは、個別に実装することも、組み合わせて実装することもできます。 これらが組み合わされている場合は、 への呼び出しで SQL`Open`ステートメントを自分で渡す必要があります。

オブジェクトを渡す場所の`Open`2 番目のバージョン`CDaoTableDef`を使用すると、結果の列を使用して、DFX`DoFieldExchange`メカニズムを使用してバインドしたり、動的に バインドしたりできます`GetFieldValue`。

> [!NOTE]
> テーブル タイプの`Open`レコードセット`CDaoTableDef`に対してオブジェクトを使用して呼び出すことができます。

オブジェクトを渡す場所の`Open`3 番目のバージョン`CDaoQueryDef`を使用すると、そのクエリが実行され、結果の列を使用して DFX`DoFieldExchange`メカニズムを使用してバインドしたり、動的に バインドしたりできます`GetFieldValue`。

> [!NOTE]
> ダイナセット`Open`タイプおよび`CDaoQueryDef`スナップショット タイプのレコードセットに対してのみオブジェクトを呼び出すことができます。

パラメーターを使用する最初`Open`のバージョンでは、次の表に示す条件に基づいてレコードが選択されます。 `lpszSQL`

|パラメーター `lpszSQL` の値。|レコードの選択基準|例|
|--------------------------------------|----------------------------------------|-------------|
|NULL|`GetDefaultSQL` の返す文字列。||
|1 つ以上のテーブル定義名またはクエリ定義名のコンマ区切りリスト。|で表されるすべての列。 `DoFieldExchange`|`"Customer"`|
|テーブルリスト**から**列リストを**選択**|指定したテーブル定義またはクエリ定義の指定された列。|`"SELECT CustId, CustName`<br /><br /> `FROM Customer"`|

通常のプロシージャは NULL を`Open`に渡します。その場合は、`Open`派生`GetDefaultSQL`クラスを作成するときに ClassWizard によって生成されるオーバーライド可能な`CDaoRecordset`メンバー関数を呼び出します。 この値は、ClassWizard で指定したテーブル定義名またはクエリ定義名を指定します。 代わりに *、lpszSQL*パラメーターに他の情報を指定できます。

渡す値は`Open`何であれ、クエリの最終的な SQL 文字列を構築し (その文字列には、渡した*lpszSQL*文字列に SQL **WHERE**句と**ORDERBY**句が追加されている場合があります)、クエリを実行します。 を呼び出`GetSQL``Open`した後に呼び出すことによって、構築された文字列を調べることができます。

レコードセット クラスのフィールド データ メンバーは、選択したデータの列に結び付けられています。 いくつかのレコードが返された場合、最初のレコードが現在のレコードになります。

フィルタや並べ替えなどのレコードセットのオプションを設定する場合は、レコード`m_strSort`セット`m_strFilter`オブジェクトを作成した後、その後で`Open`を呼び出す前に設定します。 レコードセットが既に開かれた後でレコードセットのレコードを更新する場合は`Requery`、 を呼び出します。

ダイナセット`Open`タイプまたはスナップショット タイプのレコードセットを呼び出す場合、またはデータ ソースがアタッチテーブルを表す SQL ステートメントまたはテーブル定義を参照している`dbOpenTable`場合は、type 引数に使用できません。この場合、MFC は例外をスローします。 テーブル定義オブジェクトがアタッチ テーブルを表しているかどうかを確認するには[、CDaoTableDef](../../mfc/reference/cdaotabledef-class.md)オブジェクトを作成し[、そのメンバー](../../mfc/reference/cdaotabledef-class.md#getconnect)関数を呼び出します。

同じ`dbSeeChanges`レコードを編集または削除するときに、別のユーザーまたはマシン上の別のプログラムによって行われた変更をトラップする場合は、フラグを使用します。 たとえば、2 人のユーザーが同じレコードの編集を開始すると、最初`Update`にメンバー関数を呼び出したユーザーが成功します。 2`Update`番目のユーザーによって呼び出`CDaoException`されると、 がスローされます。 同様に、2 番目のユーザーが`Delete`呼び出してレコードを削除しようとした場合、そのレコードが最初のユーザーによって`CDaoException`既に変更されている場合は、a が発生します。

通常、更新中にユーザーがこれを`CDaoException`取得した場合、コードはフィールドの内容を更新し、新しく変更された値を取得する必要があります。 削除の処理中に例外が発生した場合、コードで新しいレコード データがユーザーに表示され、データが最近変更されたことを示すメッセージが表示される可能性があります。 この時点で、コードはユーザーがレコードを削除する必要があることを確認するように要求できます。

> [!TIP]
> アプリケーションが ODBC データ ソースから`dbForwardOnly`開いたレコードセットを 1 回通過する場合のパフォーマンスを向上させるには、前方スクロールオプション ( ) を使用します。

関連情報については、DAO ヘルプのトピック「OpenRecordset メソッド」を参照してください。

## <a name="cdaorecordsetrequery"></a><a name="requery"></a>コダオレコードセット::再クエリ

レコードセットを再構築 (更新) するには、このメンバー関数を呼び出します。

```
virtual void Requery();
```

### <a name="remarks"></a>解説

いくつかのレコードが返された場合、最初のレコードが現在のレコードになります。

レコードセットに、データ ソースに対して行った追加および削除を反映させるには、 を呼び出`Requery`してレコードセットを再構築する必要があります。 レコードセットがダイナセットの場合、ユーザーまたは他のユーザーが既存のレコードに対して行った更新が自動的に反映されます (追加は行いません)。 レコードセットがスナップショットの場合は、他の`Requery`ユーザーによる編集、追加、削除を反映するために呼び出す必要があります。

ダイナセットまたはスナップショットの場合は、パラメータ値`Requery`を使用してレコードセットを再構築する必要があるときはいつでも呼び出します。 呼び出し`Requery`の前に[、m_strFilter](#m_strfilter)と[m_strSort](#m_strsort)を設定して、新しいフィルタまたは並べ替えを設定します。 を呼び出す`Requery`前に、新しい値をパラメーター データ メンバーに割り当てることで、新しいパラメーターを設定します。

レコードセットの再構築に失敗すると、レコードセットは閉じられます。 を呼び`Requery`出す前に[、CanRestart](#canrestart)メンバー関数を呼び出してレコードセットを再クエリできるかどうかを確認できます。 `CanRestart`は成功を`Requery`保証するものではありません。

> [!CAUTION]
> を`Requery`呼び出した後`Open`にのみ呼び出す。

> [!NOTE]
> [再クエリを](#requery)呼び出すと、DAO のブックマークが変更されます。

呼び出しが`Requery`0 を返す場合は、ダイナセット タイプ`CanRestart`またはスナップショット タイプのレコードセットを呼び出すことも、テーブル タイプのレコードセットで使用することもできません。

両方`IsBOF`を返`IsEOF`し、呼び出`Requery`した後に 0 以外を返す場合、クエリはレコードを返さず、レコードセットにはデータが含まれていません。

関連情報については、DAO ヘルプのトピック「メソッドの再クエリ」を参照してください。

## <a name="cdaorecordsetseek"></a><a name="seek"></a>コダオレコード::シーク

現在のインデックスに対して指定した条件を満たすインデックス付きテーブル タイプのレコードセット オブジェクト内のレコードを検索し、そのレコードをカレント レコードにします。

```
BOOL Seek(
    LPCTSTR lpszComparison,
    COleVariant* pKey1,
    COleVariant* pKey2 = NULL,
    COleVariant* pKey3 = NULL);

BOOL Seek(
    LPCTSTR lpszComparison,
    COleVariant* pKeyArray,
    WORD nKeys);
```

### <a name="parameters"></a>パラメーター

*比較*<br/>
次の文字列式の 1 つ: "<"、"="、"="、">\<="、または ">" 。

*pキー1*<br/>
値がインデックスの最初のフィールドに対応する[COleVariant](../../mfc/reference/colevariant-class.md)へのポインター。 必須。

*pキー2*<br/>
インデックスの 2`COleVariant`番目のフィールドに対応する値を持つ a へのポインター ( 存在する場合)。 既定値は NULL です。

*pキー3*<br/>
インデックスの 3`COleVariant`番目のフィールドに対応する値を持つポインター( 存在する場合)。 既定値は NULL です。

*を配列します。*<br/>
バリアントの配列へのポインター。 配列のサイズは、インデックス内のフィールドの数に対応します。

*nキー*<br/>
インデックス内のフィールドの数である配列のサイズに対応する整数。

> [!NOTE]
> キーにワイルドカードを指定しないでください。 ワイルドカードを使用すると`Seek`、一致するレコードが返されません。

### <a name="return-value"></a>戻り値

一致するレコードが見つかった場合は 0 以外、それ以外の場合は 0。

### <a name="remarks"></a>解説

4 つ以上のフィールドのインデックス`Seek`を処理するには、2 番目の (配列) バージョンを使用します。

`Seek`テーブル タイプのレコードセットで、パフォーマンスの高いインデックス検索を有効にします。 呼び出`Seek`しを行う前`SetCurrentIndex`に、現在のインデックスを設定する必要があります。 インデックスが一意でないキー フィールドを識別する場合は`Seek`、条件を満たす最初のレコードを検索します。 インデックスを設定しない場合は、例外がスローされます。

UNICODE レコードセットを作成しない場合、オブジェクトは`COleVariant`明示的に ANSI として宣言する必要があります。 これは *、vtSrc* `VT_BSTRT`が (ANSI) に設定されたコンストラクターの[COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **、** *vtSrc* **)** 形式を使用するか *、vtSrc*を`VT_BSTRT`設定した`COleVariant`関数[SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **、** *vtSrc* )**を**使用して行うことができます。

呼び出`Seek`しを行うと、1 つ以上のキー値と比較演算子 ("<"、""""""""、">="、\<または ">" ) を渡します。 `Seek`指定されたキー・フィールドを検索し、 *lpszComparison*および*pKey1*で指定された条件を満たす最初のレコードを検索します。 一度見`Seek`つかった場合は、0 以外を返し、そのレコードを現在のレコードにします。 一`Seek`致が見つからない場合は`Seek`、ゼロを返し、現在のレコードは未定義です。 DAO を直接使用する場合は、NoMatch プロパティを明示的にチェックする必要があります。

"=" 、">="、または ">" の場合`lpszComparison`は、`Seek`インデックスの先頭から始まります。 *lpszComparison*が "<" または "<`Seek` =" の場合は、インデックスの末尾から始まり、末尾に重複するインデックス エントリがない限り、逆方向に検索します。 この場合、`Seek`インデックスの末尾にある重複するインデックス エントリの中の任意のエントリから開始します。

を使用`Seek`するときに、現在のレコードが存在する必要はありません。

特定の条件を満たすダイナセット タイプまたはスナップショット タイプのレコードセット内のレコードを検索するには、Find 操作を使用します。 特定の条件を満たすレコードだけでなく、すべてのレコードを含めるには、移動操作を使用してレコード間を移動します。

アタッチされたテーブル`Seek`はダイナセット タイプまたはスナップショット タイプのレコードセットとして開く必要があるため、どのタイプのアタッチテーブルにも呼び出すことはできません。 ただし、インストール可能な`CDaoDatabase::Open`ISAM データベースを直接開く呼び出し`Seek`を行うと、そのデータベース内のテーブルを呼び出すことができますが、パフォーマンスが低下する可能性があります。

関連情報については、DAO ヘルプの「シーク方法」を参照してください。

## <a name="cdaorecordsetsetabsoluteposition"></a><a name="setabsoluteposition"></a>コダレコードセット::セットアブソリュートポジション

レコードセット オブジェクトの現在のレコードの相対レコード番号を設定します。

```
void SetAbsolutePosition(long lPosition);
```

### <a name="parameters"></a>パラメーター

*l位置*<br/>
レコードセット内の現在のレコードの位置を表す序数に対応します。

### <a name="remarks"></a>解説

呼`SetAbsolutePosition`び出しを使用すると、ダイナセット タイプまたはスナップショット タイプのレコードセット内の序数位置に基づいて、現在のレコード ポインタを特定のレコードに配置できます。 現在のレコード番号は[、GetAbsolutePosition](#getabsoluteposition)を呼び出して確認することもできます。

> [!NOTE]
> このメンバー関数は、ダイナセット タイプおよびスナップショット タイプのレコードセットに対してのみ有効です。

基になる DAO オブジェクトの絶対位置プロパティ値は、0 から始まります。0 の設定は、レコードセットの最初のレコードを参照します。 値が入力されたレコードの数より大きい値を設定すると、MFC は例外をスローします。 メンバ関数を呼び出すことで、レコードセットに設定されたレコードの`GetRecordCount`数を確認できます。

カレント レコードが削除されると、AbsolutePosition プロパティ値は定義されず、参照されている場合は例外がスローされます。 新しいレコードがシーケンスの末尾に追加されます。

> [!NOTE]
> このプロパティは、代理レコード番号として使用するためのものではありません。 ブックマークは、指定された位置を保持して戻す方法として推奨され、ブックマークをサポートするすべての種類のレコードセット オブジェクトに現在のレコードを配置する唯一の方法です。 特に、レコードの前にあるレコードが削除されると、特定のレコードの位置が変わります。 また、レコードセット内の個々のレコードの順序は **、ORDERBY**句を使用して SQL ステートメントを使用して作成されない限り、レコードセットが再作成された場合に、そのレコードが同じ絶対位置を持つという保証はありません。

関連情報については、DAO ヘルプの「絶対位置プロパティ」を参照してください。

## <a name="cdaorecordsetsetbookmark"></a><a name="setbookmark"></a>レコードセット::ブックマークを設定します。

指定したブックマークを含むレコードにレコードセットを配置します。

```
void SetBookmark(COleVariant varBookmark);
```

### <a name="parameters"></a>パラメーター

*を見る*<br/>
特定のレコードのブックマーク値を含む[オブジェクト](../../mfc/reference/colevariant-class.md)。

### <a name="remarks"></a>解説

レコードセット オブジェクトを作成または開くと、各レコードには既に一意のブックマークが設定されています。 現在のレコードのブックマークを取得するには、`GetBookmark``COleVariant`値を呼び出してオブジェクトに保存します。 保存されたブックマーク値を使用して呼び`SetBookmark`出すことによって、後でそのレコードに戻ることができます。

> [!NOTE]
> [再クエリを](#requery)呼び出すと、DAO のブックマークが変更されます。

UNICODE レコードセットを作成しない場合、オブジェクトは`COleVariant`明示的に ANSI として宣言する必要があります。 これは *、vtSrc* `VT_BSTRT`が (ANSI) に設定されたコンストラクターの[COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **、** *vtSrc* **)** 形式を使用するか *、vtSrc*を`VT_BSTRT`設定した`COleVariant`関数[SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **、** *vtSrc* )**を**使用して行うことができます。

関連情報については、DAO ヘルプの「ブックマーク プロパティ」および「ブックマーク可能なプロパティ」のトピックを参照してください。

## <a name="cdaorecordsetsetcachesize"></a><a name="setcachesize"></a>レコードセット::セットキャッシュサイズ

キャッシュするレコードの数を設定します。

```
void SetCacheSize(long lSize);
```

### <a name="parameters"></a>パラメーター

*lサイズ*<br/>
レコードの数を指定します。 一般的な値は 100 です。 0 を設定すると、キャッシュがオフになります。 設定は 5 ~ 1200 レコードの間にする必要があります。 キャッシュは、かなりの量のメモリを使用する可能性があります。

### <a name="remarks"></a>解説

キャッシュは、アプリケーションの実行中にデータが再び要求される場合に、サーバーから最後に取得されたデータを保持するローカル メモリ内の領域です。 データ キャッシュを使用すると、ダイナセット タイプのレコードセット オブジェクトを使用してリモート サーバーからデータを取得するアプリケーションのパフォーマンスが向上します。 データが要求されると、Microsoft Jet データベース エンジンは、要求されたデータをサーバーから取得するのではなく、まずキャッシュをチェックします。 ODBC データ ソースから取得されていないデータは、キャッシュに保存されません。

アタッチ テーブルなどの ODBC データ ソースは、ローカル キャッシュを持つことができます。 キャッシュを作成するには、リモート データ ソースからレコードセット オブジェクトを開`SetCacheSize`き`SetCacheStart`、 および メンバー関数を`FillCache`呼び出し、メンバー関数を呼び出すか、Move 操作のいずれかを使用してレコードをステップ実行します。 メンバー関数の`SetCacheSize` *lSize*パラメーターは、アプリケーションが一度に処理できるレコードの数に基づいて指定できます。 たとえば、画面に表示されるデータのソースとしてレコードセットを使用している場合は`SetCacheSize`*、lSize*パラメータを 20 として渡して、一度に 20 個のレコードを表示できます。

関連情報については、DAO ヘルプの「CacheSize、CacheStart プロパティ」を参照してください。

## <a name="cdaorecordsetsetcachestart"></a><a name="setcachestart"></a>レコードセット::セットキャッシュスタート

キャッシュするレコードセットの最初のレコードのブックマークを指定します。

```
void SetCacheStart(COleVariant varBookmark);
```

### <a name="parameters"></a>パラメーター

*を見る*<br/>
キャッシュされるレコードセットの最初のレコードのブックマークを指定する[COleVariant](../../mfc/reference/colevariant-class.md)です。

### <a name="remarks"></a>解説

メンバー関数の*varBookmark*パラメーターには、任意のレコードのブックマーク値`SetCacheStart`を使用できます。 現在のレコードでキャッシュを開始するレコードを作成し、 [SetBookmark](#setbookmark)を使用してそのレコードのブックマークを設定し、メンバー関数のパラメーターとしてブックマーク`SetCacheStart`値を渡します。

Microsoft Jet データベース エンジンはキャッシュ範囲内のレコードをキャッシュから要求し、キャッシュ範囲外のレコードをサーバーから要求します。

キャッシュから取得されたレコードには、他のユーザーがソース データに対して同時に行った変更は反映されません。

キャッシュされたすべてのデータを強制的に更新するには *、lSize*パラメーターを`SetCacheSize`0 として渡し、`SetCacheSize`最初に要求したキャッシュのサイズで再度呼び出してから、メンバー`FillCache`関数を呼び出します。

UNICODE レコードセットを作成しない場合、オブジェクトは`COleVariant`明示的に ANSI として宣言する必要があります。 これは *、vtSrc* `VT_BSTRT`が (ANSI) に設定されたコンストラクターの[COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **、** *vtSrc* **)** 形式を使用するか *、vtSrc*を`VT_BSTRT`設定した`COleVariant`関数[SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **、** *vtSrc* )**を**使用して行うことができます。

関連情報については、DAO ヘルプの「CacheSize、CacheStart プロパティ」を参照してください。

## <a name="cdaorecordsetsetcurrentindex"></a><a name="setcurrentindex"></a>レコードセット::セットカレントインデックス

テーブル タイプのレコードセットにインデックスを設定します。

```
void SetCurrentIndex(LPCTSTR lpszIndex);
```

### <a name="parameters"></a>パラメーター

*インデックスを使用します。*<br/>
設定するインデックスの名前を含むポインター。

### <a name="remarks"></a>解説

ベース テーブルのレコードは、特定の順序で保存されません。 インデックスを設定すると、データベースから返されるレコードの順序は変わりますが、レコードの格納順序には影響しません。 指定されたインデックスは既に定義されている必要があります。 存在しないインデックス オブジェクトを使用しようとした場合、または[Seek](#seek)を呼び出したときにインデックスが設定されていない場合、MFC は例外をスローします。

テーブルの新しいインデックスを作成するには[、CDaoTableDef::CreateIndex](../../mfc/reference/cdaotabledef-class.md#createindex)を呼び出し、[基](../../mfc/reference/cdaotabledef-class.md#append)になるテーブル定義のインデックス コレクションに新しいインデックスを追加します。

テーブル タイプのレコードセットから返されるレコードは、基になるテーブル定義に定義されたインデックスによってのみ順序付けることができます。 他の順序でレコードを並べ替えるには[、CDaoRecordset::m_strSort](#m_strsort)に格納されている SQL **ORDERBY**句を使用して、ダイナセット タイプまたはスナップショット タイプのレコードセットを開きます。

関連情報については、DAO ヘルプのトピック「インデックス オブジェクト」および「現在のインデックス」の定義を参照してください。

## <a name="cdaorecordsetsetfielddirty"></a><a name="setfielddirty"></a>セオレコードセット::セットフィールドダーティ

レコードセットのフィールド データ メンバーに変更または変更なしとしてフラグを設定します。

```
void SetFieldDirty(
    void* pv,
    BOOL bDirty = TRUE);
```

### <a name="parameters"></a>パラメーター

*pv*<br/>
レコードセット内のフィールド データ メンバーのアドレスを格納します。 NULL の場合、レコードセット内のすべてのフィールド データ メンバにフラグが設定されます。 (C++ NULL は、データベース用語では NULL と同じではありません。

*bダーティ*<br/>
フィールド データ メンバーに "ダーティ" (変更) のフラグを付ける場合は TRUE。 それ以外の場合は FALSE を指定すると、フィールド データ メンバーは "クリーン" (変更なし) としてフラグが設定されます。

### <a name="remarks"></a>解説

フィールドを変更しないマークを付け、フィールドが更新されないことを確認します。

フレームワークは、変更されたフィールド データ メンバーをマークして、DAO レコード フィールド エクスチェンジ (DFX) 機構によってデータ ソースのレコードに書き込まれるようにします。 フィールドの値を変更すると、通常はフィールドが自動的にダーティになるため、自分で`SetFieldDirty`呼び出す必要が生じることはめったにありませんが、フィールド データ メンバーの値に関係なく、列を明示的に更新または挿入する必要がある場合があります。 DFX メカニズムでは、PSEUDONULL の使用も使用されます。 詳細については[、「CDaoFieldExchange::m_nOperation」](../../mfc/reference/cdaofieldexchange-class.md#m_noperation)を参照してください。

ダブル バッファリングメカニズムが使用されていない場合、フィールドの値を変更しても、フィールドはダーティとして自動的に設定されません。 この場合、フィールドをダーティとして明示的に設定する必要があります。 [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields)に含まれるフラグは、この自動フィールド検査を制御します。

> [!NOTE]
> このメンバー関数は、呼び出した後に[[編集]](#edit)または[[AddNew]](#addnew)を呼び出した後にのみ呼び出します。

関数の最初の引数に NULL を使用すると、関数はすべての`outputColumn`フィールドに適用され **、param**フィールドには適用されません`CDaoFieldExchange`。 たとえば、コール

[!code-cpp[NVC_MFCDatabase#6](../../mfc/codesnippet/cpp/cdaorecordset-class_6.cpp)]

フィールドのみを`outputColumn`NULL に設定します。**param**フィールドは影響を受けません。

**param**で作業するには、次のように、作業する個々の**パラメータ**の実際のアドレスを指定する必要があります。

[!code-cpp[NVC_MFCDatabase#7](../../mfc/codesnippet/cpp/cdaorecordset-class_7.cpp)]

つまり、すべての**param**フィールドを NULL`outputColumn`に設定することはできません。

`SetFieldDirty`を通じて`DoFieldExchange`実装されます。

## <a name="cdaorecordsetsetfieldnull"></a><a name="setfieldnull"></a>レコードセット::セットフィールドヌル

レコードセットのフィールド データ メンバーに、Null (特に値がない) または Null 以外のフィールド データ メンバーにフラグを設定します。

```
void SetFieldNull(
    void* pv,
    BOOL bNull = TRUE);
```

### <a name="parameters"></a>パラメーター

*pv*<br/>
レコードセット内のフィールド データ メンバーのアドレスを格納します。 NULL の場合、レコードセット内のすべてのフィールド データ メンバにフラグが設定されます。 (C++ NULL は、データベース用語では NULL と同じではありません。

*を返す*<br/>
フィールド データ メンバーに値なし (Null) のフラグを設定する場合は、0 以外の値を指定します。 それ以外の場合は、フィールド データ メンバーに Null 以外のフラグが設定されます。

### <a name="remarks"></a>解説

`SetFieldNull`は、機構内でバインドされた`DoFieldExchange`フィールドに使用されます。

レコードセットに新しいレコードを追加すると、すべてのフィールド データ メンバーは、最初は Null 値に設定され、"ダーティ" (変更) としてフラグが設定されます。 データ ソースからレコードを取得する場合、その列には既に値があるか、Null です。 フィールドを Null にすることが適切でない場合は[、CDaoException が](../../mfc/reference/cdaoexception-class.md)スローされます。

たとえば、現在のレコードのフィールドに値がないとして指定する場合は、ダブル バッファリングメカニズムを使用している場合は *、bNull*を TRUE`SetFieldNull`に設定して Null としてフラグを設定します。 フィールドが以前に Null としてマークされている場合に値を指定する場合は、単に新しい値を設定します。 Null フラグを削除する必要はありません`SetFieldNull`。 フィールドが Null にできるかどうかを判断するには[、IsFieldNullable](#isfieldnullable)を呼び出します。

ダブル バッファリングメカニズムを使用していない場合、フィールドの値を変更しても、フィールドが自動的にダーティおよび非 Null として設定されることはありません。 フィールドは、ダーティで Null 以外のフィールドを明示的に設定する必要があります。 [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields)に含まれるフラグは、この自動フィールド検査を制御します。

DFX メカニズムは、PSEUDONULL を使用します。 詳細については[、「CDaoFieldExchange::m_nOperation」](../../mfc/reference/cdaofieldexchange-class.md#m_noperation)を参照してください。

> [!NOTE]
> このメンバー関数は、呼び出した後に[[編集]](#edit)または[[AddNew]](#addnew)を呼び出した後にのみ呼び出します。

関数の最初の引数に NULL を使用すると、関数は`outputColumn`フィールドにのみ適用され **、param**のフィールドには適用されません`CDaoFieldExchange`。 たとえば、コール

[!code-cpp[NVC_MFCDatabase#8](../../mfc/codesnippet/cpp/cdaorecordset-class_8.cpp)]

フィールドのみを`outputColumn`NULL に設定します。**param**フィールドは影響を受けません。

## <a name="cdaorecordsetsetfieldvalue"></a><a name="setfieldvalue"></a>コダレコード::セットフィールド値

序数の位置または文字列の値の変更によって、フィールドの値を設定します。

```
virtual void SetFieldValue(
    LPCTSTR lpszName,
    const COleVariant& varValue);

virtual void SetFieldValue(
    int nIndex,
    const COleVariant& varValue);

void SetFieldValue(
    LPCTSTR lpszName,
    LPCTSTR lpszValue);

void SetFieldValue(
    int nIndex,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>パラメーター

*名前を指定します。*<br/>
フィールドの名前を含む文字列へのポインター。

*値*<br/>
フィールドの内容の値を含む[COleVariant](../../mfc/reference/colevariant-class.md)オブジェクトへの参照。

*nIndex*<br/>
レコードセットの Fields コレクション内のフィールドの序数位置を表す整数です (0 から始まる)。

*値*<br/>
フィールドの内容の値を含む文字列へのポインター。

### <a name="remarks"></a>解説

DoFieldExchange メカニズムを使用`SetFieldValue`して列を静的に連結するのではなく、実行時にフィールドを動的にバインドするには、 および[GetFieldValue](#getfieldvalue)を使用します。 [DoFieldExchange](#dofieldexchange)

UNICODE レコードセットを作成しない場合は、`SetFieldValue``COleVariant`パラメータを含まない形式を使用するか、オブジェクトを`COleVariant`明示的に ANSI として宣言する必要があります。 これは *、vtSrc* `VT_BSTRT`が (ANSI) に設定されたコンストラクターの[COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **、** *vtSrc* **)** 形式を使用するか *、vtSrc*を`VT_BSTRT`設定した`COleVariant`関数[SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **、** *vtSrc* )**を**使用して行うことができます。

関連情報については、DAO ヘルプの「フィールド オブジェクト」および「値のプロパティ」を参照してください。

## <a name="cdaorecordsetsetfieldvaluenull"></a><a name="setfieldvaluenull"></a>レコードセット::セットフィールド値Null

フィールドを Null 値に設定します。

```
void SetFieldValueNull(int nIndex);
void SetFieldValueNull(LPCTSTR lpszName);
```

### <a name="parameters"></a>パラメーター

*nIndex*<br/>
レコードセット内のフィールドのインデックスで、0 から始まるインデックスを検索します。

*名前を指定します。*<br/>
名前で検索するレコードセット内のフィールドの名前。

### <a name="remarks"></a>解説

C++ NULL は NULL と同じではありません。

関連情報については、DAO ヘルプの「フィールド オブジェクト」および「値のプロパティ」を参照してください。

## <a name="cdaorecordsetsetlockingmode"></a><a name="setlockingmode"></a>セオロックモード::セットロックモード

レコードセットのロックの種類を設定します。

```
void SetLockingMode(BOOL bPessimistic);
```

### <a name="parameters"></a>パラメーター

*bペシミスティック*<br/>
ロックの種類を示すフラグ。

### <a name="remarks"></a>解説

悲観ロックが有効な場合、編集中のレコードを含む 2K ページは`Edit`、メンバー関数を呼び出すとすぐにロックされます。 または メンバー関数または移動操作または`Update``Close`検索操作を呼び出すと、ページのロックが解除されます。

オプティミスティック・ロックが有効な場合、レコードがメンバー関数で更新されている間だけ、レコードを含む`Update`2K ページがロックされます。

ページがロックされている場合、他のユーザーは同じページのレコードを編集できません。 呼び出`SetLockingMode`しを行って 0 以外の値を渡した場合に、別のユーザーが既に`Edit`ロックされているページを持っている場合は、 を呼び出すと例外がスローされます。 他のユーザーは、ロックされたページからデータを読み取ることができます。

ページが別`SetLockingMode`のユーザーによってロックされている間に`Update`ゼロ値を指定して呼び出すと、例外が発生します。 別のユーザーによってレコードに加えられた変更を表示するには (および変更を失う`SetBookmark`場合)、現在のレコードのブックマーク値を使用してメンバー関数を呼び出します。

ODBC データ ソースを操作する場合、ロック モードは常にオプティミスティックです。

## <a name="cdaorecordsetsetparamvalue"></a><a name="setparamvalue"></a>コダレコード::セットパラム値

実行時にレコードセットのパラメータの値を設定します。

```
virtual void SetParamValue(
    int nIndex,
    const COleVariant& varValue);

virtual void SetParamValue(
    LPCTSTR lpszName,
    const COleVariant& varValue);
```

### <a name="parameters"></a>パラメーター

*nIndex*<br/>
クエリ定義の Parameters コレクション内のパラメーターの数値位置。

*Var*<br/>
設定する値。「解説」を参照してください。

*名前を指定します。*<br/>
値を設定するパラメータの名前。

### <a name="remarks"></a>解説

パラメータは、レコードセットの SQL 文字列の一部として既に設定されている必要があります。 パラメーターには、名前またはコレクション内のインデックス位置を使用してアクセスできます。

オブジェクトとして設定する値を`COleVariant`指定します。 `COleVariant`オブジェクト内の目的の値と型の設定については、「クラス[COleVariant](../../mfc/reference/colevariant-class.md)」を参照してください。 UNICODE レコードセットを作成しない場合、オブジェクトは`COleVariant`明示的に ANSI として宣言する必要があります。 これは *、vtSrc* `VT_BSTRT`が (ANSI) に設定されたコンストラクターの[COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **、** *vtSrc* **)** 形式を使用するか *、vtSrc*を`VT_BSTRT`設定した`COleVariant`関数[SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **、** *vtSrc* )**を**使用して行うことができます。

## <a name="cdaorecordsetsetparamvaluenull"></a><a name="setparamvaluenull"></a>クオダレコードセット::セットパラム値Null

パラメーターを Null 値に設定するには、このメンバー関数を呼び出します。

```
void SetParamValueNull(int nIndex);
void SetParamValueNull(LPCTSTR lpszName);
```

### <a name="parameters"></a>パラメーター

*nIndex*<br/>
レコードセット内のフィールドのインデックスで、0 から始まるインデックスを検索します。

*名前を指定します。*<br/>
名前で検索するレコードセット内のフィールドの名前。

### <a name="remarks"></a>解説

C++ NULL は NULL と同じではありません。

## <a name="cdaorecordsetsetpercentposition"></a><a name="setpercentposition"></a>コダレコードセット::設定パーセントポジション

レコードセット内のレコードの割合に基づいて、レコードセット オブジェクト内の現在のレコードのおおよその位置を変更する値を設定します。

```
void SetPercentPosition(float fPosition);
```

### <a name="parameters"></a>パラメーター

*fポジション*<br/>
0 ～ 100 の値。

### <a name="remarks"></a>解説

ダイナセット タイプまたはスナップショット タイプのレコードセットを操作する場合は、呼び出す`SetPercentPosition`前に最後のレコードに移動してレコードセットを設定します。 レコードセットを`SetPercentPosition`完全に設定する前に呼び出した場合、移動の量は[GetRecordCount](#getrecordcount)の値で示されるアクセスレコードの数に対して相対的になります。 を呼び出`MoveLast`して、最後のレコードに移動できます。

呼び出`SetPercentPosition`しを行うと、その値に対応する近似位置のレコードが現在のレコードになります。

> [!NOTE]
> レコード`SetPercentPosition`セット内の特定のレコードに現在のレコードを移動する呼び出しは推奨されません。 代わりに[、メンバー関数を呼](#setbookmark)び出します。

関連情報については、DAO ヘルプのトピック「パーセント位置プロパティ」を参照してください。

## <a name="cdaorecordsetupdate"></a><a name="update"></a>セオレコード::更新

または メンバー関数を呼び出した`AddNew`後`Edit`、このメンバー関数を呼び出します。

```
virtual void Update();
```

### <a name="remarks"></a>解説

この呼び出しは、 `AddNew` `Edit`または 操作を完了するために必要です。

また`AddNew`、`Edit`データ ソースに保存するために、追加または編集したデータが格納される編集バッファーを準備します。 `Update`データを保存します。 変更済みとしてマークまたは検出されたフィールドのみが更新されます。

データ ソースがトランザクションをサポートしている場合は、トランザクション`Update`の呼び出し`AddNew` `Edit` (およびそれに対応する呼び出し) の一部を作成できます。

> [!CAUTION]
> を最初に`Update`呼び出さず`AddNew`に`Edit`呼`Update`び出す`CDaoException`場合は、 または をスローします。 または`AddNew``Edit`を呼び出す場合`Update`は[、MoveNext](#movenext)を呼び出す前に呼び出すか、レコードセットまたはデータ ソース接続を閉じる必要があります。 それ以外の場合、変更は通知なしで失われます。

マルチユーザー環境でレコードセット オブジェクトが悲観的にロックされている場合、レコード`Edit`は更新が完了するまで使用されるまでロックされたままになります。 レコードセットがオプティミスティックロックされている場合、レコードはロックされ、データベースで更新される直前に、編集前のレコードと比較されます。 呼び出`Edit`し後にレコードが変更された`Update`場合、操作は失敗し、MFC は例外をスローします。 ロック モードは で変更`SetLockingMode`できます。

> [!NOTE]
> オプティミスティック・ロックは、ODBC やインストール可能な ISAM などの外部データベース形式で常に使用されます。

関連情報については、DAO ヘルプのトピック「AddNew メソッド」、「キャンセル更新メソッド」、「メソッドの削除」、「プロパティの変更」、「メソッドの更新」、および「EditMode プロパティ」を参照してください。

## <a name="see-also"></a>関連項目

[Cオブジェクトクラス](../../mfc/reference/cobject-class.md)<br/>
[階層グラフ](../../mfc/hierarchy-chart.md)<br/>
[クラス](../../mfc/reference/cdaotabledef-class.md)<br/>
[CDAOワークスペースクラス](../../mfc/reference/cdaoworkspace-class.md)<br/>
[CDaoDatabase クラス](../../mfc/reference/cdaodatabase-class.md)<br/>
[クラス](../../mfc/reference/cdaoquerydef-class.md)<br/>
