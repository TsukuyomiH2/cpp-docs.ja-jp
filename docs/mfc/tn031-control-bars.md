---
description: '詳細情報: テクニカルノート 31: コントロールバー'
title: 'テクニカル ノート 31: コントロール バー'
ms.date: 11/04/2016
f1_keywords:
- vc.controls.bars
helpviewer_keywords:
- control bars [MFC], styles
- CStatusBar class [MFC], Tech Note 31 usage
- CControlBar class [MFC], Tech Note 31 usage
- CControlBar class [MFC], deriving from
- control bars [MFC], classes [MFC]
- CDialogBar class [MFC], Tech Note 31 usage
- CToolBar class [MFC], Tech Note 31 usage
- TN031
- styles [MFC], control bars
ms.assetid: 8cb895c0-40ea-40ef-90ee-1dd29f34cfd1
ms.openlocfilehash: 42dddf1afabdf2ab04ba8441208e7109eeacbd65
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/11/2020
ms.locfileid: "97215548"
---
# <a name="tn031-control-bars"></a>テクニカル ノート 31: コントロール バー

> [!NOTE]
> 次のテクニカル ノートは、最初にオンライン ドキュメントの一部とされてから更新されていません。 結果として、一部のプロシージャおよびトピックが最新でないか、不正になります。 最新の情報について、オンライン ドキュメントのキーワードで関係のあるトピックを検索することをお勧めします。

このメモでは、MFC のコントロールバークラス (general [CControlBar](#_mfcnotes_ccontrolbar)、 [CStatusBar](#_mfcnotes_cstatusbar)、 [CToolBar](#_mfcnotes_ctoolbar)、 [CDialogBar](#_mfcnotes_cdialogbar)、および) について説明し `CDockBar` ます。

## <a name="ccontrolbar"></a><a name="_mfcnotes_ccontrolbar"></a> CControlBar

は、 `ControlBar` `CWnd` 次のようなの派生クラスです。

- フレーム ウィンドウの上部または下部に配置されます。

- 子項目として、HWND ベースのコントロール ( `CDialogBar`など) または`HWND` ベースではない項目 ( `CToolBar`、 `CStatusBar`など) のいずれかを含むことができます。

コントロール バーでは、次の追加スタイルがサポートされています。

- CBRS_TOP (既定) コントロールバーを上部に固定します。

- CBRS_BOTTOM コントロールバーを下部に固定します。

- CBRS_NOALIGN、親のサイズ変更時にコントロールバーの位置を変更しません。

`CControlBar` からの派生クラスには、次のような、さらに興味深い実装が用意されています。

- `CStatusBar` : ステータス バー。項目はテキストを含むステータス バー ペインです。

- `CToolBar` : ツール バー。項目は 1 列に配置されたビットマップ ボタンです。

- `CDialogBar` : 標準ウィンドウ コントロールを含む、ツール バーに似たフレーム (ダイアログ テンプレート リソースから作成できます)。

- `CDockBar` 他の派生オブジェクトの一般化されたドッキング領域 `CControlBar` 。 このクラスで利用できる特定のメンバー関数および変数は、今後のリリースで変更される可能性があります。

すべてのコントロール バー オブジェクト/ウィンドウが、一部の親フレーム ウィンドウの子ウィンドウになります。 これらは通常、フレームのクライアント領域 (たとえば、MDI クライアントまたはビュー) に兄弟として追加されます。 コントロール バーの子ウィンドウ ID は重要な ID です。 コントロール バーの既定のレイアウトは、ID が AFX_IDW_CONTROLBAR_FIRST ～ AFX_IDW_CONTROLBAR_LAST の範囲内にあるコントロール バーに対してのみ有効です。 コントロール バー ID の範囲が 256 まである場合でも、最初の 32 までは特殊なコントロール バー ID です (印刷プレビューのアーキテクチャによって直接サポートされるため)。

`CControlBar` クラスには、次の目的に利用できる標準実装が用意されています。

- コントロール バーをフレームの上部、下部、左側、または右側に配置する。

- コントロール項目の配列を割り当てる。

- 派生クラスの実装をサポートする。

通常、C++ コントロール バー オブジェクトは `CFrameWnd` 派生クラスのメンバーとして埋め込まれ、親の `HWND` とオブジェクトが破棄された場合にはクリーンアップされます。 ヒープ上にコントロール バー オブジェクトを割り当てる必要がある場合は、 *が破棄されたときにコントロール バーが "* delete this **" を実行するように、** m_bAutoDestruct **メンバーを** TRUE `HWND` に設定します。

> [!NOTE]
> `CControlBar`、、またはなど、MFC の派生クラスの1つを使用するのではなく、独自の派生クラスを作成する場合 `CStatusBar` は、 `CToolBar` `CDialogBar` *m_dwStyle* データメンバーを設定する必要があります。 これは、次のオーバーライドで実行でき `Create` ます。

```
// CMyControlBar is derived from CControlBar
BOOL CMyControlBar::Create(CWnd* pParentWnd,
    DWORD dwStyle,
    UINT nID)
{
    m_dwStyle = dwStyle;

.
.
.
}
```

**コントロール バー レイアウトのアルゴリズム**

コントロール バー レイアウトのアルゴリズムは非常に単純です。 フレーム ウィンドウは、メッセージ WM_SIZEPARENT をコントロール バーの範囲内にあるすべての子に送信します。 このメッセージと共に、親のクライアント領域の四角形を指すポインターが渡されます。 このメッセージは、Z オーダーで子に送信されます。 コントロール バーの子は、この情報を使用して自身を配置し、親のクライアント領域のサイズを縮小します。 通常のクライアント領域用に残された最後の四角形 (コントロール バー以外の領域) は、メイン クライアント ウィンドウ (通常は MDI クライアント、ビュー、または分割ウィンドウ) を配置するために使用されます。

詳細については、「 `CWnd::RepositionBars` 」と「 `CFrameWnd::RecalcLayout` 」を参照してください。

WM_SIZEPARENT を含む MFC プライベート Windows メッセージについては、 [テクニカルノート 24](../mfc/tn024-mfc-defined-messages-and-resources.md)に記載されています。

## <a name="cstatusbar"></a><a name="_mfcnotes_cstatusbar"></a> CStatusBar

ステータス バーとは、テキスト出力ペインの行を持つコントロール バーです。 テキスト出力ペインの使用方法としては、次の 2 つの方法が一般的です。

- メッセージ行として使用する方法

     (たとえば、標準メニューのヘルプ メッセージ行)。 通常、これらのメッセージ行には 0 から始まるインデックスによってアクセスします。

- ステータス インジケーターとして使用する方法

     (たとえば、CAP、NUM、および SCRL インジケーター)。 通常、これらのインジケーターには文字列/コマンド ID によってアクセスします。

ステータス バーのフォントは 10 ポイント MS P ゴシックです (Windows インターフェイス アプリケーション デザイン ガイド、またはフォント マッパーにより 10 ポイント Swiss プロポーショナル フォントに最適なフォントとして指定)。 日本語版など、特定のバージョンの Windows では、選択されるフォントが異なります。

ステータス バーで使用される色は、Windows インターフェイス アプリケーション デザイン ガイドの推奨事項にも適合しています。 これらの色はハード コーディングされていないため、コントロール パネルでのユーザーによるカスタマイズに応じて動的に変化します。

|アイテム|Windows COLOR 値|既定の RGB|
|----------|-------------------------|-----------------|
|ステータス バーの背景|COLOR_BTNFACE|RGB (192, 192, 192)|
|ステータス バーのテキスト|COLOR_BTNTEXT|RGB (000, 000, 000)|
|ステータス バーの上端/左端|COLOR_BTNHIGHLIGHT|RGB (255, 255, 255)|
|ステータス バーの下端/右端|COLOR_BTNSHADOW|RGB (128, 128, 128)|

**CStatusBar 用の CCmdUI のサポート**

通常、インジケーターは、ON_UPDATE_COMMAND_UI メカニズムを使用して更新されます。 アイドル時に、ステータスバーは、インジケーターペインの文字列 ID を使用して ON_UPDATE_COMMAND_UI ハンドラーを呼び出します。

ON_UPDATE_COMMAND_UI ハンドラーは次を呼び出すことができます。

- `Enable`: ペインを有効または無効にします。 無効なペインの見た目は有効なペインとまったく同じですが、テキストが非表示になります (つまり、テキスト インジケーターが無効になります)。

- `SetText`: テキストを変更します。 これを使用する場合は、ペインのサイズが自動的に変更されない点に注意してください。

[の作成およびカスタマイズ API の詳細については、](../mfc/reference/cstatusbar-class.md) クラス ライブラリ リファレンス *の* CStatusBar `CStatusBar` クラスを参照してください。 ステータス バーのカスタマイズの大部分は、ステータス バーの初回表示前に行う必要があります。

ステータス バーでは、可変幅ペインが 1 つだけサポートされており、通常は最初のペインがこれにあたります。 このペインのサイズは、実際には最小サイズです。 ステータス バーがすべてのペインの最小サイズより大きい場合、余分な幅は可変幅ペインに与えられます。 ステータス バーを持つ既定のアプリケーションは、最初のペインが可変幅であるため、CAP、NUM、および SCRL 用のインジケーターが右揃えになります。

## <a name="ctoolbar"></a><a name="_mfcnotes_ctoolbar"></a> CToolBar

ツール バーとは、ビットマップ ボタンの行を持つコントロール バーであり、区分線を含むことができます。 プッシュ ボタンとチェック ボックス ボタンという 2 つのスタイルがサポートされます。 オプショングループの機能は、チェックボックスボタンと ON_UPDATE_COMMAND_UI を使用して作成できます。

ツール バー内のすべてのビットマップ ボタンは、1 つのビットマップから取得します。 このビットマップには、ボタンごとに 1 つの画像またはグリフが含まれている必要があります。 通常、ビットマップ内の画像/グリフの順序は、画面に描画される順序と同じです (この順序はカスタマイズ API を使用して変更できます)。

各ボタンは同じサイズにする必要があります。 既定値は標準の 24 x 22 ピクセルです。 各画像/グリフは同じサイズにする必要があり、ビットマップ内で横並びに配置する必要があります。 既定の画像/グリフのサイズは 16 x 15 ピクセルです。 そのため、10 個のボタンを持つツール バー (標準サイズを使用) には、幅 160 ピクセル、高さ 15 ピクセルのビットマップが必要です。

各ボタンは、画像/グリフを 1 つだけ持ちます。 ボタンのさまざまな状態とスタイル (押されている状態、アップ状態、ダウン状態、無効な状態、無効なダウン状態、不確定状態など) は、その 1 つの画像/グリフからアルゴリズムによって生成されます。 理論上は、どのような色のビットマップや DIB でも使用できます。 ボタンのさまざまな状態を生成するためのアルゴリズムは、元の画像がグレースケールの場合に最も効果的に機能します。 参考例については、MFC 標準サンプルの [CLIPART](../overview/visual-cpp-samples.md) で提供されている標準ツール バー ボタンとツール バー ボタン クリップアートを参照してください。

ツール バーで使用される色は、Windows インターフェイス アプリケーション デザイン ガイドの推奨事項にも適合しています。 これらの色はハード コーディングされていないため、コントロール パネルでのユーザーによるカスタマイズに応じて動的に変化します。

|アイテム|Windows COLOR 値|既定の RGB|
|----------|-------------------------|-----------------|
|ツール バーの背景|COLOR_BTNFACE|RGB (192, 192, 192)|
|ツール バー ボタンの上端/左端|COLOR_BTNHIGHLIGHT|RGB (255, 255, 255)|
|ツール バー ボタンの下端/右端|COLOR_BTNSHADOW|RGB (128, 128, 128)|

また、ツール バーのビットマップ ボタンの色は、それが標準 Windows ボタン コントロールであるかのように塗り直されます。 この色の変更は、ビットマップがリソースから読み込まれたときに発生するほか、コントロール パネルでのユーザーによるカスタマイズに応じてシステム カラーの変更が行われた場合にも発生します。 ツール バーのビットマップに次の色が含まれている場合、その色は自動的に変更されるため、注意して使用する必要があります。 ビットマップの色が部分的に変更されることが好ましくない場合は、マップされた RGB 値に近い色を使用してください。 マッピングは正確な RGB 値に基づいて行われます。

|RGB 値|動的にマップされた COLOR 値|
|---------------|------------------------------------|
|RGB (000, 000, 000)|COLOR_BTNTEXT|
|RGB (128, 128, 128)|COLOR_BTNSHADOW|
|RGB (192, 192, 192)|COLOR_BTNFACE|
|RGB (255, 255, 255)|COLOR_BTNHIGHLIGHT|

[の作成およびカスタマイズ API の詳細については、](../mfc/reference/ctoolbar-class.md) クラス ライブラリ リファレンス *の* CToolBar `CToolBar` クラスを参照してください。 ツール バーのカスタマイズの大部分は、ツール バーの初回表示前に行う必要があります。

カスタマイズ API を使用すると、ボタン ID、スタイル、スペーサー幅のほか、どのボタンに対してどの画像/グリフを使用するかを調整できます。 既定では、これらの API を使用する必要はありません。

## <a name="ccmdui-support-for-ctoolbar"></a>CToolBar 用の CCmdUI のサポート

ツールバーのボタンは、常に ON_UPDATE_COMMAND_UI メカニズムを使用して更新されます。 アイドル時には、ツールバーはそのボタンのコマンド ID を使用して ON_UPDATE_COMMAND_UI ハンドラーを呼び出します。 区切り記号に ON_UPDATE_COMMAND_UI は呼び出されませんが、プッシュボタンとチェックボックスボタンに対して呼び出されます。

ON_UPDATE_COMMAND_UI ハンドラーは次を呼び出すことができます。

- `Enable`: ボタンを有効または無効にします。 これはプッシュ ボタンでもチェック ボックス ボタンでも同様に機能します。

- `SetCheck`: ボタンのチェック状態を設定します。 これをツール バーのボタンに対して呼び出すと、そのボタンがチェック ボックス ボタンに変わります。 `SetCheck` には、パラメーターとして 0 (オフ)、1 (オン)、または 2 (不確定) を指定できます。

- `SetRadio`: `SetCheck`の短縮形です。

チェック ボックス ボタンは "AUTO" チェック ボックス ボタンです。つまり、ユーザーがそのボタンを押すと、すぐにボタンの状態が変化します。 オン状態は、ダウン状態または押されている状態です。 組み込みのユーザー インターフェイスには、ボタンを "不確定" 状態に変更する方法はありません。この操作はコードを通じて実行する必要があります。

カスタマイズ Api を使用すると、特定のツールバーボタンの状態を変更できます。そのため、ツールバーボタンが表すコマンドの ON_UPDATE_COMMAND_UI ハンドラーでこれらの状態を変更することをお勧めします。 アイドル処理によってツールバーボタンの状態が ON_UPDATE_COMMAND_UI ハンドラーに変更されるので、SetButtonStyle によるこれらの状態への変更は、次にアイドル状態になると失われる可能性があることに注意してください。

ツールバーのボタンは、通常のボタンやメニュー項目などの WM_COMMAND メッセージを送信し、通常は ON_UPDATE_COMMAND_UI ハンドラーを提供するのと同じクラスの ON_COMMAND ハンドラーによって処理されます。

ツール バーのボタンには 4 つのスタイル (TBBS_ 値) があり、次の状態を表示するために使用されます。

- TBBS_CHECKED: チェック ボックスは現在、オン (ダウン) になっています。

- TBBS_INDETERMINATE: チェック ボックスは現在、不確定状態になっています。

- TBBS_DISABLED: ボタンは現在、無効になっています。

- TBBS_PRESSED: ボタンは現在、押されています。

公式の Windows インターフェイス アプリケーション デザイン ガイドによる 6 種類のボタン スタイルは、次の TBBS 値で表されます。

- Up = 0

- マウスダウン = TBBS_PRESSED (他のスタイルの &#124;)

- Disabled (無効) = TBBS_DISABLED

- Down (ダウン) = TBBS_CHECKED

- Down Disabled = TBBS_CHECKED &#124; TBBS_DISABLED

- Indeterminate (不確定) = TBBS_INDETERMINATE

## <a name="cdialogbar"></a><a name="_mfcnotes_cdialogbar"></a> CDialogBar

ダイアログ バーとは、標準の Windows コントロールが含まれるコントロール バーです。 ダイアログと同様にコントロールが含まれ、コントロール間でのタブ移動をサポートします。 また、バーを表すためにダイアログ テンプレートを使用する点もダイアログと同様です。

`CDialogBar` は、標準のプッシュ ボタン コントロールを含む印刷プレビュー ツール バーに使用されています。

`CDialogBar` は、 `CFormView`と同じような方法で使用します。 ダイアログ バー用にダイアログ テンプレートを定義し、WS_CHILD を除くすべてのスタイルを削除する必要があります。 ダイアログは表示することができない点に注意してください。

`CDialogBar` のコントロール通知はコントロール バーの親に送信されます (ツール バーのボタンと同様)。

## <a name="ccmdui-support-for-cdialogbar"></a>CDialogBar 用の CCmdUI のサポート

ダイアログバーのボタンは、ON_UPDATE_COMMAND_UI ハンドラーのメカニズムを使用して更新する必要があります。 アイドル時に、ダイアログバーは、ID >= 0x8000 (つまり、コマンド Id の範囲内) のすべてのボタンのコマンド ID を使用して、ON_UPDATE_COMMAND_UI ハンドラーを呼び出します。

ON_UPDATE_COMMAND_UI ハンドラーは次を呼び出すことができます。

- Enable: ボタンを有効または無効にします。

- SetText: ボタンのテキストを変更します。

カスタマイズは、標準ウィンドウ マネージャー API を使用して行うことができます。

## <a name="see-also"></a>関連項目

[番号別テクニカルノート](../mfc/technical-notes-by-number.md)<br/>
[カテゴリ別テクニカルノート](../mfc/technical-notes-by-category.md)
