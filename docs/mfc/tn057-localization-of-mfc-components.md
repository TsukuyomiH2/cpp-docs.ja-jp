---
description: '詳細については、「テクニカルノート 57: MFC コンポーネントのローカライズ」を参照してください。'
title: 'テクニカル ノート 57: MFC コンポーネントのローカライズ'
ms.date: 06/28/2018
helpviewer_keywords:
- components [MFC], localizing
- TN057
- resources [MFC], localization
- localization [MFC], MFC resources
- localization [MFC], MFC components
- MFC DLLs [MFC], localizing
- DLLs [MFC], localizing MFC
- localization [MFC], resources
ms.assetid: 5376d329-bd45-41bd-97f5-3d895a9a0af5
ms.openlocfilehash: d4a331e74acd2b5b38ae059ea180a0a2148e3a0f
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/11/2020
ms.locfileid: "97214807"
---
# <a name="tn057-localization-of-mfc-components"></a>テクニカル ノート 57: MFC コンポーネントのローカライズ

> [!NOTE]
> 次のテクニカル ノートは、最初にオンライン ドキュメントの一部とされてから更新されていません。 結果として、一部のプロシージャおよびトピックが最新でないか、不正になります。 最新の情報について、オンライン ドキュメントのキーワードで関係のあるトピックを検索することをお勧めします。

このメモでは、コンポーネントをローカライズするために使用できるデザインと手順について説明します。これには、アプリケーション、OLE コントロール、または MFC を使用する DLL が必要です。

## <a name="overview"></a>概要

MFC を使用するコンポーネントをローカライズする場合、解決すべき問題が2つあります。 まず、独自のリソース (文字列、ダイアログ、およびコンポーネントに固有のその他のリソース) をローカライズする必要があります。 MFC を使用して構築されたほとんどのコンポーネントには、MFC で定義されている多くのリソースが含まれ、使用されます。 また、ローカライズされた MFC リソースも用意する必要があります。 さいわい、MFC 自体にはいくつかの言語が既に用意されています。

また、コンポーネントをターゲット環境 (欧州または DBCS 対応の環境) で実行できるように準備する必要があります。 ほとんどの場合、これは、上位ビットが正しく設定され、2バイト文字の文字列を処理するアプリケーションによって異なります。 既定では、両方の環境で MFC が有効になっています。これは、セットアップ時に接続されているリソースが異なるすべてのプラットフォームで、世界中の単一のバイナリを使用できるようにするためです。

## <a name="localizing-your-components-resources"></a>コンポーネントのリソースのローカライズ

アプリケーションまたは DLL をローカライズする場合は、リソースをターゲット言語に一致するリソースに置き換えるだけで済みます。 独自のリソースについては、リソースエディターでリソースを編集し、アプリケーションをビルドするのが比較的単純です。 コードが適切に記述されている場合、C++ ソースコードにハードコーディングする文字列やテキストはありません。すべてのローカリゼーションは、単にリソースを変更するだけで行うことができます。 実際には、ローカライズされたバージョンを提供するすべてのものが元のコードのビルドに関与しないように、コンポーネントを実装することができます。 これはより複雑ですが、これは非常に価値があり、MFC 自体に対して選択されたメカニズムです。 また、EXE ファイルまたは DLL ファイルをリソースエディターに読み込み、リソースを直接編集することによって、アプリケーションをローカライズすることもできます。 可能な限り、アプリケーションの新しいバージョンをビルドするたびに、これらの変更を reapplication する必要があります。

これを回避する方法の1つとして、個別の DLL 内のすべてのリソース (サテライト DLL と呼ばれることもあります) を検索する方法があります。 この DLL は、実行時に動的に読み込まれ、すべてのコードを含むメインモジュールからではなく、その DLL からリソースが読み込まれます。 MFC では、この方法を直接サポートしています。 MYAPP.EXE と呼ばれるアプリケーションを考えてみましょう。すべてのリソースが MYRES.DLL という DLL に格納されている可能性があります。 アプリケーションでは、その `InitInstance` DLL を読み込むために次の処理を実行し、MFC がその場所からリソースを読み込みます。

```cpp
CMyApp::InitInstance()
{
    // one of the first things in the init code
    HINSTANCE hInst = LoadLibrary("myres.dll");

    if (hInst != NULL)
        AfxSetResourceHandle(hInst);

    // other initialization code would follow
    // ...
}
```

その後、MFC は、myapp.exe からではなく、その DLL からリソースを読み込みます。 ただし、すべてのリソースがその DLL 内に存在している必要があります。MFC は、特定のリソースの検索でアプリケーションのインスタンスを検索しません。 この手法は、OLE コントロールだけでなく、通常の MFC Dll にも同様に適用されます。 セットアッププログラムは、ユーザーが希望するリソースロケールに応じて、適切なバージョンの MYRES.DLL をコピーします。

リソースのみの DLL を作成するのは比較的簡単です。 DLL プロジェクトを作成し、を追加します。それにファイルを追加し、必要なリソースを追加します。 この手法を使用しない既存のプロジェクトがある場合は、そのプロジェクトからリソースをコピーできます。 リソースファイルをプロジェクトに追加した後、プロジェクトをビルドする準備がほぼ完了します。 必要なのは、 **/NOENTRY** を含むようにリンカーオプションを設定することだけです。 これは、DLL にエントリポイントがないことをリンカーに指示します。コードがないため、エントリポイントがありません。

> [!NOTE]
> Visual C++ 4.0 以降のリソースエディターでは、1つのにつき複数の言語がサポートされています。RC ファイル。 これにより、1つのプロジェクトでローカライズを簡単に管理できるようになります。 各言語のリソースは、リソースエディターによって生成されるプリプロセッサディレクティブによって制御されます。

## <a name="using-the-provided-mfc-localized-resources"></a>提供されている MFC ローカライズ済みリソースの使用

ビルドするすべての MFC アプリケーションは、MFC からの2つの処理 (コードとリソース) を再利用します。 つまり、mfc には、さまざまなエラーメッセージ、組み込みダイアログ、および MFC クラスによって使用されるその他のリソースが用意されています。 アプリケーションを完全にローカライズするには、アプリケーションのリソースだけでなく、MFC から直接取得したリソースもローカライズする必要があります。 MFC では、さまざまな言語リソースファイルが自動的に提供されるため、対象とする言語が既にサポートされている言語のいずれかである場合は、これらのローカライズされたリソースを使用する必要があります。

このドキュメントの執筆時点で、MFC では、中国語、ドイツ語、スペイン語、フランス語、イタリア語、日本語、および韓国語がサポートされています。 これらのローカライズされたバージョンが含まれているファイルは、次のように指定します。 ("L" はローカライズされた) ディレクトリです。 ドイツ語ファイルは MFC\INCLUDE\L.DEU にあります。たとえば、のようになります。 アプリケーションで、MFC/INCLUDE にあるファイルではなく、これらの RC ファイルを使用するようにするには、を `/IC:\PROGRAM FILES\MICROSOFT VISUAL STUDIO .NET 2003\VC7\MFC\INCLUDE\L.DEU` RC コマンドラインに追加します (これは例にすぎません。選択したロケールや、Visual C++ をインストールしたディレクトリに置き換える必要があります)。

アプリケーションが MFC と静的にリンクしている場合は、上記の手順が機能します。 ほとんどのアプリケーションは動的にリンクされます (これが AppWizard の既定値であるため)。 このシナリオでは、コードだけでなく、リソースも動的にリンクされます。 その結果、アプリケーションでリソースをローカライズできますが、MFC 実装リソースは引き続き MFC7x.DLL (またはそれ以降のバージョン) から読み込まれるか、または存在する場合は MFC7xLOC.DLL から読み込まれます。 これは、2つの異なる角度からアプローチできます。

より複雑な方法として、ローカライズされた MFC7xLOC.DLLs (MFC7xDEU、MFC7xESP.DLL ドイツ語、スペイン語など)、またはそれ以降のバージョンのいずれかを出荷し、ユーザーがアプリケーションをインストールするときに適切な MFC7xLOC.DLL をシステムディレクトリにインストールする方法があります。 これは、開発者とエンドユーザーの両方にとって非常に複雑な場合があるため、推奨されません。 この手法とその注意事項の詳細については、「 [テクニカルノート 56](../mfc/tn056-installation-of-localized-mfc-components.md) 」を参照してください。

最も簡単で安全な方法は、ローカライズされた MFC リソースをアプリケーションまたは DLL 自体 (使用している場合はそのサテライト DLL) に含めることです。 これにより、MFC7xLOC.DLL を適切にインストールする際の問題が回避されます。 これを行うには、前に示した静的ケースと同じ手順に従います (ローカライズされたリソースを指すように RC コマンドラインを適切に設定します)。ただし、 `/D_AFXDLL` AppWizard によって追加された定義も削除する必要があります。 `/D_AFXDLL`が定義されている場合は、afxres.h になります。H (およびその他の MFC RC ファイル) では、実際にはリソースが定義されていません (代わりに、MFC Dll からプルされるため)。

## <a name="see-also"></a>関連項目

[番号別テクニカルノート](../mfc/technical-notes-by-number.md)<br/>
[カテゴリ別テクニカルノート](../mfc/technical-notes-by-category.md)
