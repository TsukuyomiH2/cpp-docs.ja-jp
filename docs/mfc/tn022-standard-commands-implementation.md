---
description: '詳細情報: テクニカルノート 22: 標準コマンドの実装'
title: 'テクニカル ノート 22: 標準コマンドの実装'
ms.date: 11/04/2016
f1_keywords:
- vc.commands
helpviewer_keywords:
- ID_PREV_PANE command [MFC]
- ID_APP_EXIT command [MFC]
- ID_NEXT_PANE command [MFC]
- ID_INDICATOR_REC command [MFC]
- ID_WINDOW_SPLIT command [MFC]
- ID_FILE_PRINT_PREVIEW command [MFC]
- ID_WINDOW_CASCADE command [MFC]
- ID_FILE_CLOSE command [MFC]
- ID_FILE_SAVE_COPY_AS command [MFC]
- ID_WINDOW_ARRANGE command [MFC]
- ID_EDIT_FIND command [MFC]
- ID_FILE_OPEN command [MFC]
- ID_FILE_PAGE_SETUP command [MFC]
- ID_OLE_VERB_FIRST command [MFC]
- ID_EDIT_UNDO command [MFC]
- ID_EDIT_CLEAR command [MFC]
- ID_INDICATOR_CAPS command [MFC]
- ID_HELP_INDEX command [MFC]
- commands [MFC], standard
- ID_FILE_PRINT_SETUP command [MFC]
- ID_DEFAULT_HELP command [MFC]
- ID_INDICATOR_SCRL command [MFC]
- ID_FILE_PRINT command [MFC]
- ID_INDICATOR_OVR command [MFC]
- ID_INDICATOR_KANA command [MFC]
- ID_EDIT_COPY command [MFC]
- ID_EDIT_REDO command [MFC]
- ID_EDIT_PASTE command [MFC]
- ID_OLE_INSERT_NEW command [MFC]
- ID_OLE_EDIT_LINKS command [MFC]
- ID_EDIT_PASTE_SPECIAL command [MFC]
- ID_INDICATOR_EXT command [MFC]
- ID_HELP_USING command [MFC]
- standard commands
- ID_VIEW_STATUS_BAR command [MFC]
- ID_FILE_SAVE_AS command [MFC]
- ID_EDIT_CLEAR_ALL command [MFC]
- ID_WINDOW_NEW command [MFC]
- ID_CONTEXT_HELP command [MFC]
- ID_EDIT_REPLACE command [MFC]
- ID_WINDOW_TILE_HORZ command [MFC]
- ID_APP_ABOUT command [MFC]
- TN022
- ID_VIEW_TOOLBAR command [MFC]
- ID_HELP command [MFC]
- ID_WINDOW_TILE_VERT command [MFC]
- ID_EDIT_CUT command [MFC]
- ID_FILE_UPDATE command [MFC]
- ID_EDIT_REPEAT command [MFC]
- ID_FILE_SAVE command [MFC]
- ID_EDIT_PASTE_LINK command [MFC]
- ID_EDIT_SELECT_ALL command [MFC]
- ID_FILE_NEW command [MFC]
- ID_INDICATOR_NUM command
ms.assetid: a7883b46-23f7-4870-ac3a-804aed9258b5
ms.openlocfilehash: 7c8540dcf0e41e5f6d5f00a4f22568c4df0fcdbe
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/11/2020
ms.locfileid: "97215808"
---
# <a name="tn022-standard-commands-implementation"></a>テクニカル ノート 22: 標準コマンドの実装

> [!NOTE]
> 次のテクニカル ノートは、最初にオンライン ドキュメントの一部とされてから更新されていません。 結果として、一部のプロシージャおよびトピックが最新でないか、不正になります。 最新の情報について、オンライン ドキュメントのキーワードで関係のあるトピックを検索することをお勧めします。

このメモでは、MFC 2.0 で提供される標準のコマンド実装について説明します。 標準コマンドの多くを実装するために使用されるメカニズムについて説明しているので、「 [テクニカルノート 21](../mfc/tn021-command-and-message-routing.md) 」を参照してください。

この説明は、MFC アーキテクチャ、Api、および一般的なプログラミング手法についての知識を前提としています。 ドキュメント化された "実装のみ" の Api についても説明します。 これは、の機能、または MFC でのプログラミング方法について学習を開始するための場所ではありません。 詳細については、Visual C++ と、ドキュメント化された Api の詳細については、「」を参照してください。

## <a name="the-problem"></a>問題

MFC では、ヘッダーファイル AFXRES.H に多くの標準コマンド Id が定義されています。 これらのコマンドのフレームワークのサポートはさまざまです。 フレームワーククラスがこれらのコマンドを処理する場所と方法を理解することは、フレームワークが内部でどのように動作するかを示すだけでなく、標準実装をカスタマイズする方法についての有用な情報を提供し、独自のコマンドハンドラーを実装するためのいくつかの手法について説明します。

## <a name="contents-of-this-technical-note"></a>このテクニカルノートの内容

各コマンド ID については、次の2つのセクションで説明します。

- タイトル: コマンド ID のシンボル名 (たとえば、ID_FILE_SAVE) の後にコマンドの目的 (たとえば、"現在のドキュメントを保存する") がコロンで区切られて指定されます。

- コマンドを実装するクラスと既定の実装の動作について説明する1つ以上の段落

ほとんどの既定のコマンド実装は、フレームワークの基本クラスメッセージマップで事前に設定されています。 派生クラスでの明示的な配線を必要とするコマンド実装がいくつかあります。 これらの詳細については、「注」を参照してください。 AppWizard で適切なオプションを選択した場合、生成されたスケルトンアプリケーションでこれらの既定のハンドラーが接続されます。

## <a name="naming-convention"></a>命名規則

標準コマンドは、可能であれば使用することをお勧めする単純な名前付け規則に従います。 ほとんどの標準コマンドは、アプリケーションのメニューバーの標準の場所にあります。 コマンドのシンボリック名は、"ID_" で始まり、その後に標準のポップアップメニュー名が続き、その後にメニュー項目名が続きます。 シンボリック名は、大文字と小文字が区別されます。 標準のメニュー項目名がないコマンドの場合は、"ID_" で始まる論理コマンド名が定義されます (たとえば、ID_NEXT_PANE)。

"ID_" というプレフィックスを使用して、メニュー項目、ツールバーボタン、その他のコマンドユーザーインターフェイスオブジェクトにバインドするように設計されたコマンドを示します。 "ID_" コマンドを処理するコマンドハンドラーでは、MFC コマンドアーキテクチャの ON_COMMAND と ON_UPDATE_COMMAND_UI のメカニズムを使用する必要があります。

コマンドアーキテクチャに従わないメニュー項目には、標準の "IDM_" プレフィックスを使用することをお勧めします。メニュー項目を有効または無効にするには、メニュー固有のコードが必要です。 もちろん、メニュー固有のコマンドの数は小さくなります。これは、MFC コマンドのアーキテクチャに従うだけでなく、ツールバーで動作するため、コマンドハンドラーコードを再利用できるようになるためです。

## <a name="id-ranges"></a>ID 範囲

MFC での ID 範囲の使用の詳細については、 [テクニカルノート 20](../mfc/tn020-id-naming-and-numbering-conventions.md) を参照してください。

MFC 標準コマンドは、0xE000 から0xEFFF までの範囲に分類されます。 将来のバージョンのライブラリで変更される可能性があるため、これらの Id の特定の値に依存しないでください。

アプリケーションでは、0x8000 ~ から0xdfff の範囲のコマンドを定義する必要があります。

## <a name="standard-command-ids"></a>標準コマンド Id

各コマンド ID には、ファイルプロンプトに表示される標準のメッセージ行プロンプト文字列があります。リターン. メニュープロンプトの文字列 ID は、コマンド ID と同じである必要があります。

- ID_FILE_NEW 新しいドキュメントまたは空のドキュメントを作成します。

    > [!NOTE]
    >  この `CWinApp` 機能を有効にするには、を派生クラスのメッセージマップに接続する必要があります。

   `CWinApp::OnFileNew` では、アプリケーション内のドキュメントテンプレートの数に応じて、このコマンドが異なる方法で実装されます。 が1つしかない場合は `CDocTemplate` 、 `CWinApp::OnFileNew` その種類の新しいドキュメントだけでなく、適切なフレームおよびビュークラスも作成されます。

   複数のが存在する場合は `CDocTemplate` 、 `CWinApp::OnFileNew` ユーザーにダイアログ (AFX_IDD_NEWTYPEDLG) を入力して、使用するドキュメントの種類を選択するように指示します。 選択したは、 `CDocTemplate` ドキュメントの作成に使用されます。

   ID_FILE_NEW の一般的なカスタマイズの1つは、ドキュメントの種類をさまざまにグラフィカルに選択できるようにすることです。 この場合は、独自のを実装 `CMyApp::OnFileNew` し、ではなくメッセージマップに配置することができ `CWinApp::OnFileNew` ます。 基底クラスの実装を呼び出す必要はありません。

   ID_FILE_NEW のもう1つの一般的なカスタマイズは、各種類のドキュメントを作成するための個別のコマンドを提供することです。 この場合は、ID_FILE_NEW_CHART や ID_FILE_NEW_SHEET などの新しいコマンド Id を定義する必要があります。

- ID_FILE_OPEN 既存のドキュメントを開きます。

    > [!NOTE]
    >  この `CWinApp` 機能を有効にするには、を派生クラスのメッセージマップに接続する必要があります。

   `CWinApp::OnFileOpen` には、 `CWinApp::DoPromptFileName` `CWinApp::OpenDocumentFile` ファイル名またはパス名を指定してを呼び出すという、非常に単純なの実装があります。 `CWinApp`実装ルーチンは、標準の FileOpen ダイアログを表示し、現在の `DoPromptFileName` ドキュメントテンプレートから取得したファイル拡張子を入力します。

   ID_FILE_OPEN の一般的なカスタマイズの1つは、FileOpen ダイアログをカスタマイズするか、ファイルフィルターを追加することです。 これをカスタマイズするには、既定の実装を独自の FileOpen ダイアログに置き換え、 `CWinApp::OpenDocumentFile` ドキュメントのファイル名またはパス名を指定してを呼び出すことをお勧めします。 基底クラスを呼び出す必要はありません。

- ID_FILE_CLOSE 現在開いているドキュメントを閉じます。

   `CDocument::OnFileClose` を呼び出して、 `CDocument::SaveModified` ドキュメントが変更されている場合は保存するようにユーザーに要求し、を呼び出し `OnCloseDocument` ます。 すべての終了ロジック (ドキュメントの破棄を含む) は、ルーチンで実行され `OnCloseDocument` ます。

    > [!NOTE]
    >  ID_FILE_CLOSE は、WM_CLOSE メッセージ、またはドキュメントフレームウィンドウに送信される SC_CLOSE システムコマンドとは異なる方法で動作します。 ウィンドウを閉じると、ドキュメントを表示している最後のフレームウィンドウである場合にのみ、ドキュメントが閉じられます。 ID_FILE_CLOSE でドキュメントを閉じると、ドキュメントが閉じるだけでなく、ドキュメントを表示しているすべてのフレームウィンドウが閉じます。

- ID_FILE_SAVE は、現在のドキュメントを保存します。

   実装では、 `CDocument::DoSave` との両方に使用されるヘルパールーチンを使用し `OnFileSave` `OnFileSaveAs` ます。 以前に保存されていないドキュメントを保存した場合 (FileNew の場合のようにパス名が指定されていない場合や、読み取り専用ドキュメントから読み取られた場合)、 `OnFileSave` ロジックは ID_FILE_SAVE_AS コマンドのように機能し、新しいファイル名を入力するようにユーザーに要求します。 ファイルを開いて保存を行う実際のプロセスは、仮想関数を使用して行い `OnSaveDocument` ます。

   ID_FILE_SAVE をカスタマイズする一般的な理由は2つあります。 保存しないドキュメントの場合は、単にユーザーインターフェイスから ID_FILE_SAVE メニュー項目とツールバーボタンを削除します。 また、ドキュメントがダーティにならないようにし (つまり、を呼び出さない)、フレームワークによってドキュメントが保存されないようにし `CDocument::SetModifiedFlag` ます。 ディスクファイル以外の場所に保存されるドキュメントの場合は、その操作に対して新しいコマンドを定義します。

   の場合 `COleServerDoc` 、ID_FILE_SAVE は、ファイルの保存 (通常のドキュメントの場合) とファイル更新 (埋め込みドキュメントの場合) の両方に使用されます。

   ドキュメントデータが個々のディスクファイルに格納されていても、既定のシリアル化の実装を使用しない場合は `CDocument` 、の代わりにをオーバーライドする必要があり `CDocument::OnSaveDocument` `OnFileSave` ます。

- ID_FILE_SAVE_AS は、現在のドキュメントを別のファイル名で保存します。

   `CDocument::OnFileSaveAs`実装では、と同じヘルパールーチンを使用し `CDocument::DoSave` `OnFileSave` ます。 この `OnFileSaveAs` コマンドは、ドキュメントの保存前にファイル名がない場合に ID_FILE_SAVE と同様に処理されます。 `COleServerDoc::OnFileSaveAs` 通常のドキュメントデータファイルを保存したり、他のアプリケーションに埋め込まれている OLE オブジェクトを表すサーバードキュメントを別のファイルとして保存したりするためのロジックを実装します。

   ID_FILE_SAVE のロジックをカスタマイズする場合は、同様の方法で ID_FILE_SAVE_AS をカスタマイズするか、"名前を付けて保存" 操作をドキュメントに適用できない可能性があります。 メニュー項目が不要な場合は、メニューバーから削除できます。

- ID_FILE_SAVE_COPY_AS は、新しい名前の下にコピーの現在のドキュメントを保存します。

   の `COleServerDoc::OnFileSaveCopyAs` 実装はとよく似てい `CDocument::OnFileSaveAs` ますが、保存後にドキュメントオブジェクトが基になるファイルに "添付" される点が異なります。 つまり、メモリ内のドキュメントが保存前に "変更" されていた場合でも、"変更" されます。 また、このコマンドは、ドキュメントに格納されているパス名またはタイトルには影響しません。

- ID_FILE_UPDATE は、埋め込みドキュメントを保存するようコンテナーに通知します。

   この `COleServerDoc::OnUpdateDocument` 実装は、埋め込みを保存するコンテナーを単純に notifiies します。 次に、埋め込みオブジェクトを保存するために、コンテナーは適切な OLE Api を呼び出します。

- ID_FILE_PAGE_SETUP によって、アプリケーション固有のページ設定/レイアウトダイアログが呼び出されます。

   現在、このダイアログには標準はありません。フレームワークには、このコマンドの既定の実装がありません。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- 標準の [印刷設定] ダイアログ ID_FILE_PRINT_SETUP 起動します。

    > [!NOTE]
    >  この `CWinApp` 機能を有効にするには、を派生クラスのメッセージマップに接続する必要があります。

   このコマンドは、標準の [印刷の設定] ダイアログを呼び出します。このダイアログボックスでは、少なくともこのドキュメントまたはこのアプリケーション内のすべてのドキュメントについて、プリンターと印刷の設定をカスタマイズできます。 コントロールパネルを使用して、システム全体の既定のプリンター設定を変更する必要があります。

   `CWinApp::OnFilePrintSetup` には、オブジェクトを作成し、実装関数を呼び出す、非常に単純な実装があり `CPrintDialog` `CWinApp::DoPrintDialog` ます。 これにより、アプリケーションの既定のプリンター設定が設定されます。

   このコマンドをカスタマイズするための一般的なニーズは、ドキュメントごとのプリンター設定を許可することです。これは、保存時にドキュメントと共に保存する必要があります。 これを行うには、オブジェクトを作成するメッセージマップハンドラーをクラスに追加し、 `CDocument` `CPrintDialog` 適切なプリンター属性 (通常は *Hdevmode* と *hDevNames*) を使用して初期化し、を呼び出して、 `CPrintDialog::DoModal` 変更されたプリンターの設定を保存します。 堅牢な実装については、 `CWinApp::DoPrintDialog` エラーを検出し、実用的な既定値を処理し、システム全体のプリンターの変更を追跡するために、の実装を検討する必要があり `CWinApp::UpdatePrinterSelection` ます。

- 現在のドキュメントの標準印刷を ID_FILE_PRINT します。

    > [!NOTE]
    >  この `CView` 機能を有効にするには、を派生クラスのメッセージマップに接続する必要があります。

   このコマンドは、現在のドキュメントを印刷します。または、より正確に印刷処理を開始します。これには、標準の [印刷] ダイアログを呼び出し、印刷エンジンを実行します。

   `CView::OnFilePrint` このコマンドとメインの print ループを実装します。 このコマンドは、仮想を呼び出して、ユーザーに対して [ `CView::OnPreparePrinting` 印刷] ダイアログでプロンプトを表示します。 次に、プリンターに移動するように出力 DC を準備し、[印刷の進行状況] ダイアログ (AFX_IDD_PRINTDLG) を起動して、 `StartDoc` エスケープをプリンターに送信します。 `CView::OnFilePrint` には、メインページ指向の印刷ループも含まれています。 各ページについて、仮想の後にエスケープを呼び出し、 `CView::OnPrepareDC` `StartPage` `CView::OnPrint` そのページの仮想を呼び出します。 完了すると、仮想 `CView::OnEndPrinting` が呼び出され、[印刷の進行状況] ダイアログボックスが閉じます。

   MFC の印刷アーキテクチャは、印刷と印刷プレビューのためのさまざまな方法でフックするように設計されています。 通常は、ページ指向の印刷タスクに適したさまざまなオーバーライド可能な関数を見つけ `CView` ます。 ページ指向以外の出力にプリンターを使用するアプリケーションの場合にのみ、ID_FILE_PRINT の実装を置き換える必要があります。

- 現在のドキュメントの印刷/プレビューモードに ID_FILE_PRINT_PREVIEW します。

    > [!NOTE]
    >  この `CView` 機能を有効にするには、を派生クラスのメッセージマップに接続する必要があります。

   `CView::OnFilePrintPreview` ドキュメント化されたヘルパー関数を呼び出すことにより、印刷プレビューモードを開始し `CView::DoPrintPreview` ます。 `CView::DoPrintPreview` は、印刷ループのメインエンジンと同じように、印刷プレビューループのメインエンジンです `OnFilePrint` 。

   印刷プレビュー操作は、さまざまなパラメーターをに渡すことによって、さまざまな方法でカスタマイズでき `DoPrintPreview` ます。 印刷プレビューの詳細とカスタマイズ方法については、「 [テクニカルノート 30](../mfc/tn030-customizing-printing-and-print-preview.md)」を参照してください。

- ID_FILE_MRU_FILE1...FILE16 ファイルの **一覧** のコマンド id の範囲を指定します。

   `CWinApp::OnUpdateRecentFileMenu` は、ON_UPDATE_COMMAND_UI メカニズムの高度な使用方法の1つである update コマンド UI ハンドラーです。 メニューリソースでは、ID ID_FILE_MRU_FILE1 を持つメニュー項目を1つだけ定義する必要があります。 そのメニュー項目は、最初は無効のままです。

   MRU リストが拡大するにつれて、一覧に追加のメニュー項目が追加されます。 標準の実装は、既定では、 `CWinApp` 最近使用した4つのファイルの標準制限に設定されています。 `CWinApp::LoadStdProfileSettings`より大きな値または小さい値を指定してを呼び出すことによって、既定のを変更できます。 MRU リストはアプリケーションのに格納されます。INI ファイル。 を呼び出した場合、リストはアプリケーションの関数に読み込まれ、 `InitInstance` `LoadStdProfileSettings` アプリケーションの終了時に保存されます。 MRU 更新コマンドの UI ハンドラーでは、絶対パスを相対パスに変換して [ファイル] メニューに表示することもできます。

   `CWinApp::OnOpenRecentFile` は、実際のコマンドを実行する ON_COMMAND ハンドラーです。 MRU リストからファイル名を取得し、を呼び出します `CWinApp::OpenDocumentFile` 。これにより、ファイルを開いて mru リストを更新する作業がすべて実行されます。

   このコマンドハンドラーのカスタマイズはお勧めしません。

- 現在の選択範囲をクリア ID_EDIT_CLEAR

   現在、このコマンドの標準実装はありません。 各派生クラスに対してこれを実装する必要があり `CView` ます。

   `CEditView` を使用して、このコマンドの実装を提供 `CEdit::Clear` します。 現在選択されていない場合、コマンドは無効になります。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_CLEAR_ALL ドキュメント全体をクリアします。

   現在、このコマンドの標準実装はありません。 各派生クラスに対してこれを実装する必要があり `CView` ます。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。 実装の例については、「MFC チュートリアルのサンプル [SCRIBBLE](../overview/visual-cpp-samples.md) 」を参照してください。

- 現在の選択項目をクリップボードにコピー ID_EDIT_COPY ます。

   現在、このコマンドの標準実装はありません。 各派生クラスに対してこれを実装する必要があり `CView` ます。

   `CEditView` このコマンドの実装を提供します。このコマンドは、現在選択されているテキストを、を使用して CF_TEXT としてクリップボードにコピーし `CEdit::Copy` ます。 現在選択されていない場合、コマンドは無効になります。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- 現在の選択範囲をクリップボードに ID_EDIT_CUT ます。

   現在、このコマンドの標準実装はありません。 各派生クラスに対してこれを実装する必要があり `CView` ます。

   `CEditView` このコマンドの実装を提供します。を使用して CF_TEXT 現在選択されているテキストをクリップボードに切り取り `CEdit::Cut` ます。 現在選択されていない場合、コマンドは無効になります。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_FIND によって検索操作が開始され、モードレスの [検索] ダイアログが表示されます。

   現在、このコマンドの標準実装はありません。 各派生クラスに対してこれを実装する必要があり `CView` ます。

   `CEditView` このコマンドの実装を提供します。このコマンドは、 `OnEditFindReplace` 前の検索/置換設定を使用してプライベート実装変数に格納するための実装ヘルパー関数を呼び出します。 クラスは、 `CFindReplaceDialog` ユーザーにプロンプトを表示するためのモードレスダイアログを管理するために使用されます。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_PASTE は、現在のクリップボードの内容を挿入します。

   現在、このコマンドの標準実装はありません。 各派生クラスに対してこれを実装する必要があり `CView` ます。

   `CEditView` このコマンドの実装を提供します。これにより、を使用して、選択したテキストを置き換える現在のクリップボードデータがコピーされ `CEdit::Paste` ます。 クリップボードに **CF_TEXT** がない場合、コマンドは無効になります。

   `COleClientDoc` は、このコマンドの更新コマンド UI ハンドラーを提供するだけです。 クリップボードに埋め込み OLE 項目またはオブジェクトが含まれていない場合、コマンドは無効になります。 実際の貼り付けを行う実際のコマンドのハンドラーを記述する必要があります。 OLE アプリケーションで他の形式も貼り付けることができる場合は、独自の更新コマンド UI ハンドラーをビューまたはドキュメント (コマンドターゲットルーティングの前の場所) に指定する必要があり `COleClientDoc` ます。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

   標準の OLE 実装を置き換えるには、を使用し `COleClientItem::CanPaste` ます。

- ID_EDIT_PASTE_LINK は、現在のクリップボードの内容からリンクを挿入します。

   現在、このコマンドの標準実装はありません。 各派生クラスに対してこれを実装する必要があり `CView` ます。

   `COleDocument` は、このコマンドの更新コマンド UI ハンドラーを提供するだけです。 クリップボードにリンク可能 OLE item/object が含まれていない場合、コマンドは無効になります。 実際の貼り付けを行う実際のコマンドのハンドラーを記述する必要があります。 OLE アプリケーションで他の形式も貼り付けることができる場合は、独自の更新コマンド UI ハンドラーをビューまたはドキュメント (コマンドターゲットルーティングの前の場所) に指定する必要があり `COleDocument` ます。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

   標準の OLE 実装を置き換えるには、を使用し `COleClientItem::CanPasteLink` ます。

- ID_EDIT_PASTE_SPECIAL は、オプションを使用して現在のクリップボードの内容を挿入します。

   現在、このコマンドの標準実装はありません。 各派生クラスに対してこれを実装する必要があり `CView` ます。 MFC では、このダイアログは提供されません。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_REPEAT は最後の操作を繰り返します。

   現在、このコマンドの標準実装はありません。 各派生クラスに対してこれを実装する必要があり `CView` ます。

   `CEditView` 最後の検索操作を繰り返すために、このコマンドの実装を提供します。 最後の検索のためのプライベート実装変数が使用されます。 検索を実行できない場合、コマンドは無効になっています。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_REPLACE 置換操作を開始すると、モードレス置換ダイアログが表示されます。

   現在、このコマンドの標準実装はありません。 各派生クラスに対してこれを実装する必要があり `CView` ます。

   `CEditView` このコマンドの実装を提供します。このコマンドは、 `OnEditFindReplace` 前の検索/置換設定を使用してプライベート実装変数に格納するための実装ヘルパー関数を呼び出します。 クラスは、 `CFindReplaceDialog` ユーザーに入力を求めるモードレスダイアログを管理するために使用されます。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_SELECT_ALL ドキュメント全体を選択します。

   現在、このコマンドの標準実装はありません。 各派生クラスに対してこれを実装する必要があり `CView` ます。

   `CEditView` ドキュメント内のすべてのテキストを選択する、このコマンドの実装を提供します。 選択するテキストがない場合、コマンドは無効になります。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_UNDO 最後の操作を元に戻します。

   現在、このコマンドの標準実装はありません。 各派生クラスに対してこれを実装する必要があり `CView` ます。

   `CEditView` を使用して、このコマンドの実装を提供 `CEdit::Undo` します。 が FALSE を返す場合、コマンドは無効になり `CEdit::CanUndo` ます。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_REDO 最後の操作をやり直します。

   現在、このコマンドの標準実装はありません。 各派生クラスに対してこれを実装する必要があり `CView` ます。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_WINDOW_NEW 作業中のドキュメントで別のウィンドウを開きます。

   `CMDIFrameWnd::OnWindowNew` は、現在のドキュメントのドキュメントテンプレートを使用して、現在のドキュメントの別のビューを含む別のフレームを作成することによって、この強力な機能を実装します。

   多くのマルチドキュメントインターフェイス (MDI) ウィンドウメニューコマンドと同様に、アクティブな MDI 子ウィンドウがない場合、コマンドは無効になります。

   このコマンドハンドラーのカスタマイズはお勧めしません。 追加のビューまたはフレームウィンドウを作成するコマンドを指定する場合は、独自のコマンドをにせよことをお勧めします。 からコードを複製し、 `CMDIFrameWnd::OnWindowNew` 特定のフレームおよびビュークラスに変更できます。

- ID_WINDOW_ARRANGE、MDI ウィンドウの下部にアイコンを整列します。

   `CMDIFrameWnd` この標準の MDI コマンドを実装ヘルパー関数で実装 `OnMDIWindowCmd` します。 このヘルパーは、コマンド Id を MDI Windows メッセージにマップするため、多数のコードを共有できます。

   MDI ウィンドウのほとんどのメニューコマンドと同様に、アクティブな MDI 子ウィンドウがない場合、コマンドは無効になります。

   このコマンドハンドラーのカスタマイズはお勧めしません。

- ID_WINDOW_CASCADE は、重なっているウィンドウを重ねます。

   `CMDIFrameWnd` この標準の MDI コマンドを実装ヘルパー関数で実装 `OnMDIWindowCmd` します。 このヘルパーは、コマンド Id を MDI Windows メッセージにマップするため、多数のコードを共有できます。

   MDI ウィンドウのほとんどのメニューコマンドと同様に、アクティブな MDI 子ウィンドウがない場合、コマンドは無効になります。

   このコマンドハンドラーのカスタマイズはお勧めしません。

- ID_WINDOW_TILE_HORZ ウィンドウを水平方向に並べます。

   このコマンドは、ID_WINDOW_CASCADE と同様にで実装され `CMDIFrameWnd` ます。ただし、操作には別の MDI Windows メッセージが使用されます。

   アプリケーションの既定のタイルの向きを選択する必要があります。 これを行うには、ウィンドウの [タイル] メニュー項目の ID を ID_WINDOW_TILE_HORZ または ID_WINDOW_TILE_VERT に変更します。

- ID_WINDOW_TILE_VERT ウィンドウを垂直方向に並べます。

   このコマンドは、ID_WINDOW_CASCADE と同様にで実装され `CMDIFrameWnd` ます。ただし、操作には別の MDI Windows メッセージが使用されます。

   アプリケーションの既定のタイルの向きを選択する必要があります。 これを行うには、ウィンドウの [タイル] メニュー項目の ID を ID_WINDOW_TILE_HORZ または ID_WINDOW_TILE_VERT に変更します。

- ID_WINDOW_SPLIT のキーボードインターフェイスをスプリッターにします。

   `CView` 実装に対してこのコマンドを処理 `CSplitterWnd` します。 ビューがスプリッターウィンドウの一部である場合、このコマンドは実装関数にデリゲートし `CSplitterWnd::DoKeyboardSplit` ます。 これにより、キーボードユーザーがスプリッターウィンドウを分割または解除できるモードでスプリッターが配置されます。

   ビューがスプリッターに含まれていない場合、このコマンドは無効になります。

   このコマンドハンドラーのカスタマイズはお勧めしません。

- ID_APP_ABOUT は、[バージョン情報] ダイアログボックスを呼び出します。

   アプリケーションの [バージョン情報] ボックスの標準実装はありません。 既定の AppWizard で作成したアプリケーションは、アプリケーションのカスタムダイアログクラスを作成し、[バージョン情報] ボックスとして使用します。 また、AppWizard は、このコマンドを処理してダイアログを呼び出す自明なコマンドハンドラーも記述します。

   ほとんどの場合、このコマンドを実装します。

- ID_APP_EXIT アプリケーションを終了します。

   `CWinApp::OnAppExit` アプリケーションのメインウィンドウに WM_CLOSE メッセージを送信することによって、このコマンドを処理します。 アプリケーションの標準のシャットダウン (ダーティファイルの要求など) は、実装によって処理され `CFrameWnd` ます。

   このコマンドハンドラーのカスタマイズはお勧めしません。 `CWinApp::SaveAllModified`または終了ロジックをオーバーライドする `CFrameWnd` ことをお勧めします。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_HELP_INDEX には、のヘルプトピックが一覧表示されます。HLP ファイル。

    > [!NOTE]
    >  この `CWinApp` 機能を有効にするには、を派生クラスのメッセージマップに接続する必要があります。

   `CWinApp::OnHelpIndex` このコマンドは、を普通に呼び出して処理 `CWinApp::WinHelp` します。

   このコマンドハンドラーのカスタマイズはお勧めしません。

- ID_HELP_USING ヘルプの使用方法に関するヘルプが表示されます。

    > [!NOTE]
    >  この `CWinApp` 機能を有効にするには、を派生クラスのメッセージマップに接続する必要があります。

   `CWinApp::OnHelpUsing` このコマンドは、を普通に呼び出して処理 `CWinApp::WinHelp` します。

   このコマンドハンドラーのカスタマイズはお勧めしません。

- ID_CONTEXT_HELP によって、SHIFT + F1 ヘルプモードに切り替わります。

    > [!NOTE]
    >  この `CWinApp` 機能を有効にするには、を派生クラスのメッセージマップに接続する必要があります。

   `CWinApp::OnContextHelp` ヘルプモードカーソルを設定して、モーダルループに入り、ユーザーがウィンドウを選択してヘルプを表示するまで待機することで、このコマンドを処理します。 MFC ヘルプの実装の詳細については、 [テクニカルノート 28](../mfc/tn028-context-sensitive-help-support.md) を参照してください。

   このコマンドハンドラーのカスタマイズはお勧めしません。

- ID_HELP は現在のコンテキストに関するヘルプを提供します

    > [!NOTE]
    >  この `CWinApp` 機能を有効にするには、を派生クラスのメッセージマップに接続する必要があります。

   `CWinApp::OnHelp` 現在のアプリケーションコンテキストの適切なヘルプコンテキストを取得することによって、このコマンドを処理します。 これにより、単純な F1 ヘルプ、メッセージボックスのヘルプなどが処理されます。 MFC ヘルプの実装の詳細については、 [テクニカルノート 28](../mfc/tn028-context-sensitive-help-support.md) を参照してください。

   このコマンドハンドラーのカスタマイズはお勧めしません。

- ID_DEFAULT_HELP コンテキストの既定のヘルプを表示する

    > [!NOTE]
    >  この `CWinApp` 機能を有効にするには、を派生クラスのメッセージマップに接続する必要があります。

   このコマンドは、通常、にマップされ `CWinApp::OnHelpIndex` ます。

   既定のヘルプとヘルプインデックスの区別が必要な場合は、別のコマンドハンドラーを指定できます。

- 次のペインに移動 ID_NEXT_PANE

   `CView` 実装に対してこのコマンドを処理 `CSplitterWnd` します。 ビューがスプリッターウィンドウの一部である場合、このコマンドは実装関数にデリゲートし `CSplitterWnd::OnNextPaneCmd` ます。 これにより、アクティブなビューがスプリッターの次のペインに移動します。

   このコマンドは、ビューがスプリッターに含まれていない場合、または次のウィンドウが表示されない場合には無効になります。

   このコマンドハンドラーのカスタマイズはお勧めしません。

- 前のペインに移動 ID_PREV_PANE

   `CView` 実装に対してこのコマンドを処理 `CSplitterWnd` します。 ビューがスプリッターウィンドウの一部である場合、このコマンドは実装関数にデリゲートし `CSplitterWnd::OnNextPaneCmd` ます。 これにより、アクティブなビューがスプリッターの前のペインに移動します。

   このコマンドは、ビューがスプリッターに含まれていない場合、または前のウィンドウがない場合は無効になります。

   このコマンドハンドラーのカスタマイズはお勧めしません。

- ID_OLE_INSERT_NEW 新しい OLE オブジェクトを挿入します。

   現在、このコマンドの標準実装はありません。 を派生クラスに実装して、 `CView` 現在の選択範囲に新しい OLE 項目/オブジェクトを挿入する必要があります。

   すべての OLE クライアントアプリケーションは、このコマンドを実装する必要があります。 AppWizard を OLE オプションと共に使用すると、完了する必要のあるのスケルトン実装が `OnInsertObject` ビュークラスに作成されます。

   このコマンドの完全な実装については、MFC OLE サンプル [OCLIENT](../overview/visual-cpp-samples.md) の例を参照してください。

- OLE リンクを編集 ID_OLE_EDIT_LINKS には

   `COleDocument` MFC に用意されている標準の OLE リンクダイアログの実装を使用して、このコマンドを処理します。 このダイアログの実装には、クラスを使用してアクセスし `COleLinksDialog` ます。 現在のドキュメントにリンクが含まれていない場合、コマンドは無効になります。

   このコマンドハンドラーのカスタマイズはお勧めしません。

- ID_OLE_VERB_FIRST...OLE 動詞の最後の ID 範囲

   `COleDocument` は、現在選択されている OLE 項目またはオブジェクトでサポートされている動詞に対して、このコマンド ID 範囲を使用します。 指定された OLE 項目またはオブジェクトの型が、0個以上のカスタム動詞をサポートできるため、これは範囲である必要があります。 アプリケーションのメニューには、ID_OLE_VERB_FIRST の ID を持つメニュー項目が1つ必要です。 プログラムを実行すると、メニューは適切なメニュー動詞の説明 (または動詞の多いポップアップメニュー) で更新されます。 OLE メニューの管理は、 `AfxOleSetEditMenu` このコマンドの update コマンド UI ハンドラーで実行したによって処理されます。

   この範囲のコマンド ID を処理するための明示的なコマンドハンドラーはありません。 `COleDocument::OnCmdMsg` は、この範囲内のすべてのコマンド Id をトラップして、0から始まる動詞番号に変換し、その動詞のサーバーを起動します (を使用 `COleClientItem::DoVerb` )。

   このコマンド ID 範囲のカスタマイズまたはその他の使用は推奨されていません。

- ID_VIEW_TOOLBAR ツールバーのオン/オフを切り替えます。

   `CFrameWnd` このコマンドと、ツールバーの表示状態を切り替えるための更新コマンド UI ハンドラーを処理します。 ツールバーは、AFX_IDW_TOOLBAR の子ウィンドウ ID を持つフレームの子ウィンドウである必要があります。 コマンドハンドラーは、実際には、ツールバーウィンドウの表示を切り替えます。 `CFrameWnd::RecalcLayout` は、新しい状態のツールバーを使用してフレームウィンドウを再描画するために使用されます。 ツールバーが表示されている場合、更新コマンドの UI ハンドラーによってメニュー項目がチェックされます。

   このコマンドハンドラーのカスタマイズはお勧めしません。 他のツールバーを追加する場合は、このコマンドのコマンドハンドラーと更新コマンド UI ハンドラーを複製して変更する必要があります。

- ステータスバーのオンとオフを切り替える ID_VIEW_STATUS_BAR

   このコマンドは `CFrameWnd` 、ID_VIEW_TOOLBAR と同様に、異なる子ウィンドウ ID (AFX_IDW_STATUS_BAR) が使用される点を除いて、に実装されています。

## <a name="update-only-command-handlers"></a>Update-Only コマンドハンドラー

いくつかの標準コマンド Id は、ステータスバーでインジケーターとして使用されます。 これらは、同じ更新コマンド UI 処理機構を使用して、アプリケーションのアイドル時間中に現在のビジュアル状態を表示します。 ユーザーが選択することはできないため (ステータスバーペインをプッシュすることはできません)、これらのコマンド Id に ON_COMMAND ハンドラーを設定することは意味がありません。

- ID_INDICATOR_CAPS: キャップロックインジケーター。

- ID_INDICATOR_NUM: NUM lock インジケーター。

- ID_INDICATOR_SCRL: SCRL lock インジケーター。

- ID_INDICATOR_KANA: かな lock インジケーター (日本語システムのみに適用)。

これら3つはすべて `CFrameWnd::OnUpdateKeyIndicator` 、コマンド ID を使用して適切な仮想キーにマップする実装ヘルパーである、で実装されています。 共通の実装では、 `CCmdUI` 適切な仮想キーが現在ロックされているかどうかに応じて、オブジェクトを有効または無効にします (ステータスペインが無効になっている場合)。

このコマンドハンドラーのカスタマイズはお勧めしません。

- ID_INDICATOR_EXT: 拡張選択インジケーター。

- ID_INDICATOR_OVR: 上書きインジケーター。

- ID_INDICATOR_REC: 記録インジケーター。

現時点では、これらのインジケーターの標準実装はありません。

これらのインジケーターを実装することを選択した場合は、これらのインジケーター Id を使用して、ステータスバーのインジケーターの順序 (つまり、EXT、CAP、NUM、SCRL、上書、REC) を維持することをお勧めします。

## <a name="see-also"></a>関連項目

[番号別テクニカルノート](../mfc/technical-notes-by-number.md)<br/>
[カテゴリ別テクニカルノート](../mfc/technical-notes-by-category.md)
