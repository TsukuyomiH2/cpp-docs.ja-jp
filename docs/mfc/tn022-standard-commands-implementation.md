---
title: 'テクニカル ノート 22: 標準コマンドの実装'
ms.date: 11/04/2016
f1_keywords:
- vc.commands
helpviewer_keywords:
- ID_PREV_PANE command [MFC]
- ID_APP_EXIT command [MFC]
- ID_NEXT_PANE command [MFC]
- ID_INDICATOR_REC command [MFC]
- ID_WINDOW_SPLIT command [MFC]
- ID_FILE_PRINT_PREVIEW command [MFC]
- ID_WINDOW_CASCADE command [MFC]
- ID_FILE_CLOSE command [MFC]
- ID_FILE_SAVE_COPY_AS command [MFC]
- ID_WINDOW_ARRANGE command [MFC]
- ID_EDIT_FIND command [MFC]
- ID_FILE_OPEN command [MFC]
- ID_FILE_PAGE_SETUP command [MFC]
- ID_OLE_VERB_FIRST command [MFC]
- ID_EDIT_UNDO command [MFC]
- ID_EDIT_CLEAR command [MFC]
- ID_INDICATOR_CAPS command [MFC]
- ID_HELP_INDEX command [MFC]
- commands [MFC], standard
- ID_FILE_PRINT_SETUP command [MFC]
- ID_DEFAULT_HELP command [MFC]
- ID_INDICATOR_SCRL command [MFC]
- ID_FILE_PRINT command [MFC]
- ID_INDICATOR_OVR command [MFC]
- ID_INDICATOR_KANA command [MFC]
- ID_EDIT_COPY command [MFC]
- ID_EDIT_REDO command [MFC]
- ID_EDIT_PASTE command [MFC]
- ID_OLE_INSERT_NEW command [MFC]
- ID_OLE_EDIT_LINKS command [MFC]
- ID_EDIT_PASTE_SPECIAL command [MFC]
- ID_INDICATOR_EXT command [MFC]
- ID_HELP_USING command [MFC]
- standard commands
- ID_VIEW_STATUS_BAR command [MFC]
- ID_FILE_SAVE_AS command [MFC]
- ID_EDIT_CLEAR_ALL command [MFC]
- ID_WINDOW_NEW command [MFC]
- ID_CONTEXT_HELP command [MFC]
- ID_EDIT_REPLACE command [MFC]
- ID_WINDOW_TILE_HORZ command [MFC]
- ID_APP_ABOUT command [MFC]
- TN022
- ID_VIEW_TOOLBAR command [MFC]
- ID_HELP command [MFC]
- ID_WINDOW_TILE_VERT command [MFC]
- ID_EDIT_CUT command [MFC]
- ID_FILE_UPDATE command [MFC]
- ID_EDIT_REPEAT command [MFC]
- ID_FILE_SAVE command [MFC]
- ID_EDIT_PASTE_LINK command [MFC]
- ID_EDIT_SELECT_ALL command [MFC]
- ID_FILE_NEW command [MFC]
- ID_INDICATOR_NUM command
ms.assetid: a7883b46-23f7-4870-ac3a-804aed9258b5
ms.openlocfilehash: 5c7041f40c7e30592f642d29d9d02812a9596864
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81370399"
---
# <a name="tn022-standard-commands-implementation"></a>テクニカル ノート 22: 標準コマンドの実装

> [!NOTE]
> 次のテクニカル ノートは、最初にオンライン ドキュメントの一部とされてから更新されていません。 結果として、一部のプロシージャおよびトピックが最新でないか、不正になります。 最新の情報について、オンライン ドキュメントのキーワードで関係のあるトピックを検索することをお勧めします。

このノートでは、MFC 2.0 で提供される標準のコマンド実装について説明します。 標準コマンドの多くを実装するために使用されるメカニズムについて説明しているので、最初に[テクニカル ノート 21](../mfc/tn021-command-and-message-routing.md)を読んでください。

ここでは、MFC アーキテクチャ、API、および一般的なプログラミングの実践について説明します。 文書化された「実装のみ」API と同様に、文書化された API についても説明します。 ここでは、MFC の機能やプログラミング方法について学習する場所ではありません。 一般的な情報と、文書化された API の詳細については、「Visual C++」を参照してください。

## <a name="the-problem"></a>問題

MFC では、ヘッダー ファイル AFXRES に多くの標準コマンド ID が定義されています。H。 これらのコマンドに対するフレームワークのサポートはさまざまです。 フレームワーク クラスがこれらのコマンドを処理する場所と方法を理解することは、フレームワークが内部的にどのように機能するかを示すだけでなく、標準実装をカスタマイズする方法に関する有用な情報を提供し、独自のコマンド ハンドラーを実装するためのいくつかのテクニックを説明します。

## <a name="contents-of-this-technical-note"></a>このテクニカルノートの内容

各コマンド ID は、次の 2 つのセクションで説明されています。

- タイトル: コマンド ID のシンボル名 (例えば、ID_FILE_SAVE) の後にコマンドの目的 (たとえば、「現在の文書を保存する」) をコロンで区切ります。

- コマンドを実装するクラスと、既定の実装で何が行われるかを説明する 1 つ以上の段落

ほとんどの既定のコマンドの実装は、フレームワークの基本クラスのメッセージ マップに事前に接続されています。 派生クラスで明示的な配線を必要とするコマンドの実装がいくつかあります。 これらは「メモ」で説明されています。 AppWizard で適切なオプションを選択した場合、これらのデフォルトのハンドラーは、生成されたスケルトンアプリケーションで自動的に接続されます。

## <a name="naming-convention"></a>命名規則

標準コマンドは、可能であれば使用することをお勧めする単純な命名規則に従います。 ほとんどの標準コマンドは、アプリケーションのメニューバーの標準の場所にあります。 コマンドのシンボル名は、"ID_" で始まり、その後に標準のポップアップメニュー名が続き、メニュー項目名が続きます。 シンボル名は、アンダースコアの単語区切りで大文字になります。 標準のメニュー項目名を持たないコマンドの場合、論理コマンド名は「ID_」で始まる (例えば、ID_NEXT_PANE) 定義されます。

プレフィックス「ID_」を使用して、メニュー項目、ツールバー ボタン、またはその他のコマンド ユーザー インターフェイス オブジェクトにバインドするように設計されたコマンドを示します。 "ID_" コマンドを処理するコマンド ハンドラーは、MFC コマンド アーキテクチャのON_COMMANDおよびON_UPDATE_COMMAND_UI機構を使用する必要があります。

コマンド アーキテクチャに従わないメニュー項目に対しては、標準の "IDM_" プレフィックスを使用し、それらを有効または無効にするメニュー固有のコードを使用することをお勧めします。 もちろん、MFC コマンド アーキテクチャに従うと、コマンド ハンドラーが (ツール バーで動作するため) が強力になるだけでなく、コマンド ハンドラー コードを再利用可能にするため、メニュー固有のコマンドの数は少ないはずです。

## <a name="id-ranges"></a>ID 範囲

MFC での ID 範囲の使用の詳細については、[テクニカル ノート 20](../mfc/tn020-id-naming-and-numbering-conventions.md)を参照してください。

MFC 標準コマンドは、0xE000 から 0xEFFF の範囲内に収める。 これらの ID の特定の値は、将来のバージョンのライブラリで変更される可能性があるため、この ID の特定の値に依存しないでください。

アプリケーションでは、0x8000 から 0xDFFF の範囲でコマンドを定義する必要があります。

## <a name="standard-command-ids"></a>標準コマンド ID

各コマンド ID には、ファイル PROMPTS に含まれる標準のメッセージ行プロンプト文字列があります。Rc。 そのメニュー プロンプトの文字列 ID は、コマンド ID と同じである必要があります。

- ID_FILE_NEW 新しいドキュメントまたは空のドキュメントを作成します。

    > [!NOTE]
    >  この機能を`CWinApp`有効にするには、このクラスを派生クラスのメッセージ マップに接続する必要があります。

   `CWinApp::OnFileNew`アプリケーション内のドキュメント テンプレートの数によって、このコマンドを実装する方法が異なります。 が 1 つ`CDocTemplate`し`CWinApp::OnFileNew`かない場合は、そのタイプの新しいドキュメントと、適切なフレームとビュー クラスが作成されます。

   複数の`CDocTemplate`場合は、`CWinApp::OnFileNew`ダイアログ (AFX_IDD_NEWTYPEDLG) をユーザーに表示して、使用するドキュメントの種類を選択します。 選択した`CDocTemplate`ドキュメントの作成に使用されます。

   ID_FILE_NEWの一般的なカスタマイズの 1 つは、ドキュメントの種類の異なるグラフィカルな選択肢を提供することです。 この場合、独自`CMyApp::OnFileNew`のを実装し、`CWinApp::OnFileNew`ではなくメッセージ マップに配置できます。 基本クラスの実装を呼び出す必要はありません。

   ID_FILE_NEWの別の一般的なカスタマイズは、各タイプのドキュメントを作成するための個別のコマンドを提供することです。 この場合、ID_FILE_NEW_CHARTやID_FILE_NEW_SHEETなどの新しいコマンド ID を定義する必要があります。

- ID_FILE_OPEN 既存のドキュメントを開きます。

    > [!NOTE]
    >  この機能を`CWinApp`有効にするには、このクラスを派生クラスのメッセージ マップに接続する必要があります。

   `CWinApp::OnFileOpen`は、開くファイルのファイル`CWinApp::DoPromptFileName`名または`CWinApp::OpenDocumentFile`パス名を指定して、呼び出しの非常に単純な実装を持っています。 実装`CWinApp`ルーチン`DoPromptFileName`は、標準の FileOpen ダイアログを表示し、現在のドキュメント テンプレートから取得したファイル拡張子を設定します。

   ID_FILE_OPENの一般的なカスタマイズの 1 つは、ファイルを開くダイアログをカスタマイズするか、ファイル フィルターを追加することです。 これをカスタマイズする方法としては、既定の実装を独自の FileOpen ダイアログ ボックスに`CWinApp::OpenDocumentFile`置き換え、ドキュメントのファイル名またはパス名を指定して呼び出すことをお勧めします。 基本クラスを呼び出す必要はありません。

- ID_FILE_CLOSE 現在開いているドキュメントを閉じます。

   `CDocument::OnFileClose`ドキュメント`CDocument::SaveModified`が変更されている場合は、ユーザーにドキュメントを保存するよう求めるメッセージを`OnCloseDocument`表示し、 を呼び出します。 ドキュメントの破棄を含むすべての終了ロジックは、`OnCloseDocument`ルーチンで実行されます。

    > [!NOTE]
    >  ID_FILE_CLOSE、ドキュメント フレーム ウィンドウに送信されるWM_CLOSE メッセージやSC_CLOSEシステム コマンドとは異なる動作をします。 ウィンドウを閉じると、そのウィンドウが最後に表示されている場合にのみ、ドキュメントが閉じます。 ID_FILE_CLOSEを使用してドキュメントを閉じると、ドキュメントが閉じられますが、ドキュメントを表示しているすべてのフレーム ウィンドウが閉じます。

- ID_FILE_SAVE 現在のドキュメントを保存します。

   実装では、ヘルパー ルーチン`CDocument::DoSave`を使用して、`OnFileSave`と`OnFileSaveAs`の両方に使用します。 以前に保存されていないドキュメント (FileNew の場合のようにパス名がない) や読み取り専用ドキュメントから読み取られたドキュメントを保存すると、`OnFileSave`ロジックはID_FILE_SAVE_ASコマンドと同様に動作し、ユーザーに新しいファイル名を指定するように求めます。 ファイルを開いて保存を行う実際のプロセスは、 仮想関数`OnSaveDocument`を通じて行われます。

   ID_FILE_SAVEをカスタマイズする一般的な理由は 2 つあります。 保存しないドキュメントの場合は、ID_FILE_SAVEメニュー項目とツールバー ボタンをユーザー インターフェイスから削除するだけです。 また、ドキュメントに汚れがないようにしてください (つまり、呼び`CDocument::SetModifiedFlag`出すことはありません) とフレームワークがドキュメントを保存することはありません。 ディスク ファイル以外の場所に保存するドキュメントの場合は、その操作に対して新しいコマンドを定義します。

   `COleServerDoc`の場合、ID_FILE_SAVEは、ファイル保存 (通常のドキュメントの場合) とファイル更新 (埋め込みドキュメントの場合) の両方に使用されます。

   ドキュメント データが個々のディスク ファイルに格納されているが、既定`CDocument`のシリアル化実装を使用しない場合は、 の`CDocument::OnSaveDocument``OnFileSave`代わりにオーバーライドする必要があります。

- ID_FILE_SAVE_AS 現在のドキュメントを別のファイル名で保存します。

   実装`CDocument::OnFileSaveAs`では、 と`CDocument::DoSave`同じヘルパー`OnFileSave`ルーチンを使用します。 保存`OnFileSaveAs`前にドキュメントにファイル名がない場合、コマンドはID_FILE_SAVEと同じように処理されます。 `COleServerDoc::OnFileSaveAs`は、通常のドキュメント データ ファイルを保存するロジックを実装するか、別のアプリケーションに埋め込まれた OLE オブジェクトを表すサーバー ドキュメントを別のファイルとして保存します。

   ID_FILE_SAVEのロジックをカスタマイズする場合は、ID_FILE_SAVE_ASを同様の方法でカスタマイズするか、または [名前を付けて保存] の操作がドキュメントに適用されない場合があります。 必要がない場合は、メニュー バーからメニュー項目を削除できます。

- ID_FILE_SAVE_COPY_AS 現在のドキュメントを新しい名前で保存します。

   実装`COleServerDoc::OnFileSaveCopyAs`は、保存後に`CDocument::OnFileSaveAs`基になるファイルにドキュメント オブジェクトが "アタッチ" されないことを除いて、 とよく似ています。 つまり、メモリ内のドキュメントが保存前に "変更" された場合、そのドキュメントは "変更" されます。 また、このコマンドは、ドキュメントに格納されているパス名やタイトルには影響しません。

- ID_FILE_UPDATE 埋め込みドキュメントを保存するためにコンテナーに通知します。

   実装`COleServerDoc::OnUpdateDocument`は、単に埋め込みを保存する必要があるコンテナーを知っています。 コンテナーは、埋め込みオブジェクトを保存するために適切な OLE API を呼び出します。

- ID_FILE_PAGE_SETUP アプリケーション固有のページ設定/レイアウト ダイアログを呼び出します。

   現在、このダイアログには標準はなく、フレームワークにはこのコマンドの既定の実装はありません。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_FILE_PRINT_SETUP 標準の [印刷設定] ダイアログを呼び出します。

    > [!NOTE]
    >  この機能を`CWinApp`有効にするには、このクラスを派生クラスのメッセージ マップに接続する必要があります。

   このコマンドは、ユーザーが少なくともこのドキュメントまたはこのアプリケーション内のほとんどのドキュメントのプリンタと印刷設定をカスタマイズできるようにする標準の印刷設定ダイアログを起動します。 システム全体のデフォルトのプリンタ設定を変更するには、コントロール パネルを使用する必要があります。

   `CWinApp::OnFilePrintSetup`は、オブジェクトを作成し、`CPrintDialog`実装関数を呼`CWinApp::DoPrintDialog`び出す非常に単純な実装を持っています。 これにより、アプリケーションのデフォルトプリンター設定が設定されます。

   このコマンドをカスタマイズする一般的な必要性は、ドキュメントごとのプリンター設定を許可することです。 そのためには、`CDocument``CPrintDialog`オブジェクトを作成するメッセージ マップ ハンドラーをクラスに追加し、適切なプリンター属性 (通常は hDevMode と*hDevNames)* を`CPrintDialog::DoModal`使用して初期化し、 を呼び出して、変更したプリンター設定を保存します。 *hDevMode* 堅牢な実装を行う場合は、エラーの検出`CWinApp::DoPrintDialog`、`CWinApp::UpdatePrinterSelection`およびシステム全体のプリンターの変更の追跡に関する実装を確認する必要があります。

- 現在のドキュメントの標準印刷をID_FILE_PRINT

    > [!NOTE]
    >  この機能を`CView`有効にするには、このクラスを派生クラスのメッセージ マップに接続する必要があります。

   このコマンドは、現在のドキュメントを印刷しますが、印刷処理を正しく開始します。

   `CView::OnFilePrint`は、このコマンドとメインの印刷ループを実装します。 これは、印刷ダイアログ`CView::OnPreparePrinting`でユーザーのプロンプトを表示する仮想を呼び出します。 次に、プリンターに移動する出力 DC を準備し、印刷の進行状況ダイアログ (AFX_IDD_PRINTDLG) を`StartDoc`表示し、プリンターにエスケープを送信します。 `CView::OnFilePrint`また、ページ指向のメイン印刷ループも含まれています。 各ページに対して、仮想`CView::OnPrepareDC`を呼び出`StartPage`し、そのページの`CView::OnPrint`エスケープを呼び出し、そのページの仮想を呼び出します。 完了すると、仮想`CView::OnEndPrinting`が呼び出され、印刷の進行状況ダイアログが閉じます。

   MFC の印刷アーキテクチャは、印刷と印刷プレビューにさまざまな方法でフックするように設計されています。 通常、ページ指向印刷タスクに`CView`適した、オーバーライド可能なさまざまな関数を見つけることができます。 非ページ指向の出力にプリンターを使用するアプリケーションの場合にのみ、ID_FILE_PRINT実装を置き換える必要がある場合。

- ID_FILE_PRINT_PREVIEW 現在のドキュメントの印刷プレビュー モードに入ります。

    > [!NOTE]
    >  この機能を`CView`有効にするには、このクラスを派生クラスのメッセージ マップに接続する必要があります。

   `CView::OnFilePrintPreview`文書化されたヘルパー関数`CView::DoPrintPreview`を呼び出して印刷プレビュー モードを開始します。 `CView::DoPrintPreview`は、印刷ループのメイン エンジンと同様`OnFilePrint`に、印刷プレビュー ループのメイン エンジンです。

   印刷プレビュー操作は、さまざまなパラメータをに渡すことによって、さまざまな方法でカスタマイズできます`DoPrintPreview`。 印刷プレビューの詳細とカスタマイズ方法については、[テクニカル ノート 30](../mfc/tn030-customizing-printing-and-print-preview.md)を参照してください。

- ID_FILE_MRU_FILE1.FILE16 ファイル MRU**リスト**のコマンド ID の範囲。

   `CWinApp::OnUpdateRecentFileMenu`は、ON_UPDATE_COMMAND_UIメカニズムのより高度な使用の 1 つである更新コマンド UI ハンドラーです。 メニュー リソースでは、ID ID_FILE_MRU_FILE1を持つ 1 つのメニュー項目のみを定義する必要があります。 このメニュー項目は、最初は無効のままです。

   MRU リストが大きくなると、メニュー項目がリストに追加されます。 標準`CWinApp`実装では、最近使用した 4 つのファイルの標準制限がデフォルトで設定されます。 より大きい値または小さい`CWinApp::LoadStdProfileSettings`値で呼び出すことによって、既定値を変更できます。 MRU リストは、アプリケーションの .INI ファイル。 リストは、 を呼び出`InitInstance``LoadStdProfileSettings`すとアプリケーションの関数に読み込まれ、アプリケーションが終了すると保存されます。 MRU update コマンド UI ハンドラーは、絶対パスを相対パスに変換してファイル メニューに表示します。

   `CWinApp::OnOpenRecentFile`は、実際のコマンドを実行するON_COMMAND ハンドラーです。 これは、単にMRUリストからファイル名を取得し`CWinApp::OpenDocumentFile`、ファイルを開いてMRUリストを更新するすべての作業を行います。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_EDIT_CLEAR 現在の選択内容をクリアします。

   現在、このコマンドの標準実装はありません。 これは、派生クラスごとに`CView`実装する必要があります。

   `CEditView`を使用して、このコマンドの`CEdit::Clear`実装を提供します。 現在の選択がない場合、このコマンドは無効になります。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_CLEAR_ALL 文書全体をクリアします。

   現在、このコマンドの標準実装はありません。 これは、派生クラスごとに`CView`実装する必要があります。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。 実装例については、MFC チュートリアルサンプル[SCRIBBLE](../overview/visual-cpp-samples.md)を参照してください。

- ID_EDIT_COPY 現在の選択範囲をクリップボードにコピーします。

   現在、このコマンドの標準実装はありません。 これは、派生クラスごとに`CView`実装する必要があります。

   `CEditView`では、このコマンドの実装が提供され、現在選択されているテキストがを使用して`CEdit::Copy`CF_TEXTとしてクリップボードにコピーされます。 現在の選択がない場合、このコマンドは無効になります。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_CUT 現在の選択範囲をクリップボードに切り取ります。

   現在、このコマンドの標準実装はありません。 これは、派生クラスごとに`CView`実装する必要があります。

   `CEditView`では、このコマンドの実装が提供され、現在選択されているテキストを を使用して`CEdit::Cut`CF_TEXTとしてクリップボードに切り取ります。 現在の選択がない場合、このコマンドは無効になります。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_FIND検索操作を開始し、モードレス検索ダイアログを表示します。

   現在、このコマンドの標準実装はありません。 これは、派生クラスごとに`CView`実装する必要があります。

   `CEditView`このコマンドの実装を提供し、実装ヘルパー関数`OnEditFindReplace`を呼び出して、以前の find/replace 設定をプライベート実装変数に使用して格納します。 この`CFindReplaceDialog`クラスは、ユーザーにプロンプトを表示するためのモードレス ダイアログを管理するために使用されます。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_PASTE 現在のクリップボードの内容を挿入します。

   現在、このコマンドの標準実装はありません。 これは、派生クラスごとに`CView`実装する必要があります。

   `CEditView`このコマンドの実装を提供し、選択したテキストを置き換える現在の`CEdit::Paste`クリップボード データを を を使用してコピーします。 クリップボードに**CF_TEXT**がない場合、このコマンドは無効になります。

   `COleClientDoc`このコマンドの更新コマンド UI ハンドラーを提供するだけです。 埋め込み可能な OLE アイテム/オブジェクトがクリップボードに含まれていない場合、コマンドは無効になります。 実際の貼り付けを行う実際のコマンドのハンドラーを記述する必要があります。 OLE アプリケーションで他の形式を貼り付けることもできますが、ビューまたはドキュメント (つまり、コマンド ターゲット ルーティングの前`COleClientDoc`の任意の場所) に独自の update コマンド UI ハンドラーを用意する必要があります。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

   標準の OLE 実装を置`COleClientItem::CanPaste`き換える場合は、 を使用します。

- ID_EDIT_PASTE_LINK 現在のクリップボードの内容からリンクを挿入します。

   現在、このコマンドの標準実装はありません。 これは、派生クラスごとに`CView`実装する必要があります。

   `COleDocument`このコマンドの更新コマンド UI ハンドラーを提供するだけです。 クリップボードにリンク可能な OLE アイテムまたはオブジェクトが含まれていない場合、コマンドは無効になります。 実際の貼り付けを行う実際のコマンドのハンドラーを記述する必要があります。 OLE アプリケーションで他の形式を貼り付けることもできますが、ビューまたはドキュメント (つまり、コマンド ターゲット ルーティングの前`COleDocument`の任意の場所) に独自の update コマンド UI ハンドラーを用意する必要があります。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

   標準の OLE 実装を置`COleClientItem::CanPasteLink`き換える場合は、 を使用します。

- ID_EDIT_PASTE_SPECIAL 現在のクリップボードの内容をオプション付きで挿入します。

   現在、このコマンドの標準実装はありません。 これは、派生クラスごとに`CView`実装する必要があります。 MFC にはこのダイアログボックスは用意されていません。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_REPEAT 最後の操作を繰り返します。

   現在、このコマンドの標準実装はありません。 これは、派生クラスごとに`CView`実装する必要があります。

   `CEditView`は、最後の検索操作を繰り返すために、このコマンドの実装を提供します。 最後の検索のプライベート実装変数が使用されます。 検索を実行できない場合、コマンドは無効になります。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_REPLACE置換操作を開始し、モードレス置換ダイアログを表示します。

   現在、このコマンドの標準実装はありません。 これは、派生クラスごとに`CView`実装する必要があります。

   `CEditView`このコマンドの実装を提供し、実装ヘルパー関数`OnEditFindReplace`を呼び出して、以前の find/replace 設定をプライベート実装変数に使用して格納します。 この`CFindReplaceDialog`クラスは、ユーザーにプロンプトを表示するモードレス ダイアログを管理するために使用されます。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_SELECT_ALL ドキュメント全体を選択します。

   現在、このコマンドの標準実装はありません。 これは、派生クラスごとに`CView`実装する必要があります。

   `CEditView`では、このコマンドの実装が提供され、ドキュメント内のすべてのテキストが選択されます。 選択するテキストがない場合、このコマンドは無効になります。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_UNDO 最後の操作を元に行います。

   現在、このコマンドの標準実装はありません。 これは、派生クラスごとに`CView`実装する必要があります。

   `CEditView`を使用して、このコマンドの実装`CEdit::Undo`を提供します。 FALSE を返す`CEdit::CanUndo`場合、コマンドは無効になります。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_EDIT_REDO 最後の操作を再実行します。

   現在、このコマンドの標準実装はありません。 これは、派生クラスごとに`CView`実装する必要があります。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_WINDOW_NEW 作業中の文書に別のウィンドウを開きます。

   `CMDIFrameWnd::OnWindowNew`は、現在のドキュメントのドキュメント テンプレートを使用して、現在のドキュメントの別のビューを含む別のフレームを作成することにより、この強力な機能を実装します。

   ほとんどのマルチ ドキュメント インターフェイス (MDI) ウィンドウ メニュー コマンドと同様に、アクティブな MDI 子ウィンドウがない場合は、コマンドは無効になります。

   このコマンド ハンドラーのカスタマイズは推奨されません。 追加のビューやフレームウィンドウを作成するコマンドを提供する場合は、おそらく独自のコマンドを作成する方が良いでしょう。 コードをクローンから作成`CMDIFrameWnd::OnWindowNew`し、特定のフレームに変更し、好みのクラスを表示できます。

- ID_WINDOW_ARRANGE MDI ウィンドウの下部にアイコンを配置します。

   `CMDIFrameWnd`実装ヘルパー関数`OnMDIWindowCmd`でこの標準の MDI コマンドを実装します。 このヘルパーは、コマンド ID を MDI Windows メッセージにマップするため、多くのコードを共有できます。

   ほとんどの MDI ウィンドウ メニュー コマンドと同様に、アクティブな MDI 子ウィンドウがない場合は、コマンドは無効になります。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_WINDOW_CASCADE ウィンドウが重なるようにウィンドウを重ねて表示します。

   `CMDIFrameWnd`実装ヘルパー関数`OnMDIWindowCmd`でこの標準の MDI コマンドを実装します。 このヘルパーは、コマンド ID を MDI Windows メッセージにマップするため、多くのコードを共有できます。

   ほとんどの MDI ウィンドウ メニュー コマンドと同様に、アクティブな MDI 子ウィンドウがない場合は、コマンドは無効になります。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_WINDOW_TILE_HORZ タイル ウィンドウを水平方向に表示します。

   このコマンドは、ID_WINDOW_CASCADEと`CMDIFrameWnd`同じように実装されていますが、操作に別の MDI Windows メッセージが使用される点が異なります。

   アプリケーションの既定のタイルの向きを選択する必要があります。 これを行うには、ウィンドウの 「タイル」 メニュー項目の ID を ID_WINDOW_TILE_HORZ またはID_WINDOW_TILE_VERTに変更します。

- ID_WINDOW_TILE_VERTウィンドウを垂直に並べて表示します。

   このコマンドは、ID_WINDOW_CASCADEと`CMDIFrameWnd`同じように実装されていますが、操作に別の MDI Windows メッセージが使用される点が異なります。

   アプリケーションの既定のタイルの向きを選択する必要があります。 これを行うには、ウィンドウの 「タイル」 メニュー項目の ID を ID_WINDOW_TILE_HORZ またはID_WINDOW_TILE_VERTに変更します。

- ID_WINDOW_SPLITキーボードインターフェイスをスプリッタにします。

   `CView`実装に対してこの`CSplitterWnd`コマンドを処理します。 ビューが分割ウィンドウの一部である場合、このコマンドは実装関数`CSplitterWnd::DoKeyboardSplit`にデリゲートします。 これにより、分割ウィンドウをキーボード ユーザーが分割または分割解除できるモードに分割されます。

   このコマンドは、ビューがスプリッターにない場合は無効になります。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_APP_ABOUT [情報] ダイアログ ボックスを呼び出します。

   アプリケーションの [情報] ボックスには、標準の実装はありません。 AppWizard で作成された既定のアプリケーションは、アプリケーション用のカスタム ダイアログ クラスを作成し、[情報] ボックスとして使用します。 AppWizard は、このコマンドを処理し、ダイアログを呼び出す簡単なコマンド ハンドラーも記述します。

   ほとんどの場合、このコマンドを実装します。

- ID_APP_EXIT アプリケーションを終了します。

   `CWinApp::OnAppExit`このコマンドは、アプリケーションのメイン ウィンドウにWM_CLOSEメッセージを送信することによって処理されます。 アプリケーションの標準シャットダウン (ダーティ ファイルの確認など) は、実装によって処理`CFrameWnd`されます。

   このコマンド ハンドラーのカスタマイズは推奨されません。 オーバーライド`CWinApp::SaveAllModified`または`CFrameWnd`終了ロジックを使用することをお勧めします。

   このコマンドを実装する場合は、このコマンド ID を使用することをお勧めします。

- ID_HELP_INDEX のヘルプ トピックを一覧表示します。HLP ファイル。

    > [!NOTE]
    >  この機能を`CWinApp`有効にするには、このクラスを派生クラスのメッセージ マップに接続する必要があります。

   `CWinApp::OnHelpIndex`このコマンドは、簡単に呼`CWinApp::WinHelp`び出すことによって処理されます。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_HELP_USING ヘルプの使用方法に関するヘルプが表示されます。

    > [!NOTE]
    >  この機能を`CWinApp`有効にするには、このクラスを派生クラスのメッセージ マップに接続する必要があります。

   `CWinApp::OnHelpUsing`このコマンドは、簡単に呼`CWinApp::WinHelp`び出すことによって処理されます。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_CONTEXT_HELP Shift - F1 ヘルプ モードを入力します。

    > [!NOTE]
    >  この機能を`CWinApp`有効にするには、このクラスを派生クラスのメッセージ マップに接続する必要があります。

   `CWinApp::OnContextHelp`ヘルプ モード カーソルを設定し、モーダル ループに入り、ユーザーがヘルプを表示するウィンドウを選択するのを待つことによって、このコマンドを処理します。 MFC ヘルプの実装の詳細については、[テクニカル ノート 28](../mfc/tn028-context-sensitive-help-support.md)を参照してください。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_HELP 現在のコンテキストに関するヘルプを提供します。

    > [!NOTE]
    >  この機能を`CWinApp`有効にするには、このクラスを派生クラスのメッセージ マップに接続する必要があります。

   `CWinApp::OnHelp`現在のアプリケーション コンテキストの適切なヘルプ コンテキストを取得することによって、このコマンドを処理します。 これは、簡単な F1 ヘルプ、メッセージ ボックスのヘルプなどを処理します。 MFC ヘルプの実装の詳細については、[テクニカル ノート 28](../mfc/tn028-context-sensitive-help-support.md)を参照してください。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_DEFAULT_HELP コンテキストの既定のヘルプを表示します

    > [!NOTE]
    >  この機能を`CWinApp`有効にするには、このクラスを派生クラスのメッセージ マップに接続する必要があります。

   このコマンドは通常、 に`CWinApp::OnHelpIndex`マップされます。

   既定のヘルプとヘルプ インデックスを区別する必要がある場合は、別のコマンド ハンドラーを提供できます。

- ID_NEXT_PANE 次のペインに移動

   `CView`実装に対してこの`CSplitterWnd`コマンドを処理します。 ビューが分割ウィンドウの一部である場合、このコマンドは実装関数`CSplitterWnd::OnNextPaneCmd`にデリゲートします。 これにより、アクティブなビューがスプリッターの次のペインに移動します。

   このコマンドは、ビューがスプリッタにない場合、または移動先の次のペインがない場合は無効になります。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_PREV_PANE 前のペインに移動します

   `CView`実装に対してこの`CSplitterWnd`コマンドを処理します。 ビューが分割ウィンドウの一部である場合、このコマンドは実装関数`CSplitterWnd::OnNextPaneCmd`にデリゲートします。 これにより、アクティブなビューがスプリッターの前のペインに移動します。

   このコマンドは、ビューがスプリッタにない場合、または移動先の前のペインがない場合は無効になります。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_OLE_INSERT_NEW 新しい OLE オブジェクトを挿入します。

   現在、このコマンドの標準実装はありません。 現在の選択項目に新`CView`しい OLE アイテム/オブジェクトを挿入するには、派生クラスに対してこれを実装する必要があります。

   すべての OLE クライアント アプリケーションは、このコマンドを実装する必要があります。 AppWizard は、OLE オプションを使用して、ビュー`OnInsertObject`クラスでのスケルトン実装を作成し、完了する必要があります。

   このコマンドの完全な実装については、MFC OLE サンプル[OCLIENT](../overview/visual-cpp-samples.md)の例を参照してください。

- ID_OLE_EDIT_LINKS編集の OLE リンク

   `COleDocument`このコマンドは、MFC が提供する標準の OLE リンク ダイアログの実装を使用して処理します。 このダイアログの実装には、クラスを通`COleLinksDialog`じてアクセスします。 現在のドキュメントにリンクが含まれていない場合、コマンドは無効になります。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_OLE_VERB_FIRST.LAST OLE 動詞の ID 範囲

   `COleDocument`では、現在選択されている OLE アイテム/オブジェクトでサポートされている動詞に対して、このコマンド ID 範囲を使用します。 指定された OLE アイテム/オブジェクト型は、0 個以上のカスタム動詞をサポートできるため、範囲を指定する必要があります。 アプリケーションのメニューには、ID_OLE_VERB_FIRSTの ID を持つメニュー項目が 1 つ必要です。 プログラムが実行されると、メニューは適切なメニュー動詞の説明(または多くの動詞を含むポップアップメニュー)で更新されます。 OLE メニューの管理は、`AfxOleSetEditMenu`このコマンドの更新コマンド UI ハンドラーで行います。

   この範囲の各コマンド ID を処理するための明示的なコマンド ハンドラーはありません。 `COleDocument::OnCmdMsg`この範囲内のすべてのコマンド ID をトラップし、それらをゼロから始まる動詞番号に変換し、その動詞のサーバーを起動する (`COleClientItem::DoVerb`を使用して) オーバーライドされます。

   このコマンド ID 範囲のカスタマイズやその他の使用は推奨されません。

- ID_VIEW_TOOLBAR ツールバーのオン/オフを切り替えます。

   `CFrameWnd`は、このコマンドと更新コマンド UI ハンドラーを処理して、ツール バーの表示状態を切り替えます。 ツール バーは、子ウィンドウ ID が AFX_IDW_TOOLBAR のフレームの子ウィンドウである必要があります。 コマンド ハンドラーは、実際にはツール バー ウィンドウの表示を切り替えます。 `CFrameWnd::RecalcLayout`は、新しい状態のツールバーでフレーム ウィンドウを再描画するために使用されます。 更新コマンド UI ハンドラーは、ツール バーが表示されているときにメニュー項目をチェックします。

   このコマンド ハンドラーのカスタマイズは推奨されません。 ツールバーを追加する場合は、このコマンドのコマンド ハンドラーと update-command UI ハンドラーを複製して変更します。

- ID_VIEW_STATUS_BAR ステータス バーのオンとオフを切り替えます。

   このコマンドは、ID_VIEW_TOOLBARと`CFrameWnd`同じように実装されていますが、別の子ウィンドウ ID (AFX_IDW_STATUS_BAR) が使用される点が異なります。

## <a name="update-only-command-handlers"></a>更新専用コマンド ハンドラー

ステータス バーでは、いくつかの標準コマンド ID がインジケータとして使用されます。 これらは、アプリケーションのアイドル時間中に現在の表示状態を表示するのと同じ update-command UI 処理メカニズムを使用します。 ユーザーが選択できない (つまり、ステータス バー ペインをプッシュすることはできません)、これらのコマンド ID に対してON_COMMAND ハンドラーを持つことは意味がありません。

- ID_INDICATOR_CAPS : CAPロックインジケータ。

- ID_INDICATOR_NUM : NUM ロックインジケーター

- ID_INDICATOR_SCRL : SCRL ロックインジケータ。

- ID_INDICATOR_KANA : KANAロックインジケータ(日本語システムにのみ適用)

これら 3 つすべてが`CFrameWnd::OnUpdateKeyIndicator`、コマンド ID を使用して適切な仮想キーにマップする実装ヘルパーを実装します。 共通の実装では、適切な仮想キーが現在ロックされているかどうかに応じて、オブジェクト`CCmdUI`を有効または無効にします (ステータス ペインの場合は無効に = テキストなし)。

このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_INDICATOR_EXT : 選択インジケーターを選択します。

- ID_INDICATOR_OVR : OVeRstrike インジケータ.

- ID_INDICATOR_REC : RECordingインジケーター。

現在、これらの指標の標準実装はありません。

これらの指標を実装する場合は、これらのインジケータIDを使用し、ステータスバーでのインジケータの順序を維持することをお勧めします(つまり、この順序では、EXT、CAP、NUM、SCRL、OVR、REC)。

## <a name="see-also"></a>関連項目

[番号順テクニカル ノート](../mfc/technical-notes-by-number.md)<br/>
[カテゴリ別テクニカル ノート](../mfc/technical-notes-by-category.md)
